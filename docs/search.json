[
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "ECE244 tidy notes",
    "section": "Motivation",
    "text": "Motivation\nWe will learn about a programming paradigm (style/philosophy of programming) called object-oriented programming using C++"
  },
  {
    "objectID": "index.html#why-object-oriented-programming",
    "href": "index.html#why-object-oriented-programming",
    "title": "ECE244 tidy notes",
    "section": "Why object-oriented programming?",
    "text": "Why object-oriented programming?\n\nModular code — divide code into independent pieces\nReusable code\nEasily extend code\nEasier to maintain\nEasier to collaborate with large teams\nPopular programming paradigm"
  },
  {
    "objectID": "index.html#why-c",
    "href": "index.html#why-c",
    "title": "ECE244 tidy notes",
    "section": "Why C++?",
    "text": "Why C++?\n\nGenerally C/C++ are more difficult as they are closer to the hardware\nCan manage memory\nEasier to learn other languages once you know C/C++"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ECE244 Tidy Notes",
    "section": "",
    "text": "This course provides a foundation in programming using an object-oriented programming language. Topics include classes and objects, inheritance, basic data structures (lists, tree, hash tables, etc.), Big-O complexity analysis, and testing and debugging. The laboratory assignments emphasize the use of object-oriented programming constructs in the design and implementation of reasonably large programs."
  },
  {
    "objectID": "lecture2.html#today",
    "href": "lecture2.html#today",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Today",
    "text": "Today\nIntroduction to C++"
  },
  {
    "objectID": "lecture2.html#assumption",
    "href": "lecture2.html#assumption",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Assumption",
    "text": "Assumption\nYou are familiar with basic C programming (i.e., data types, variables, if statements, loops and functions)"
  },
  {
    "objectID": "lecture2.html#structure-of-a-c-program",
    "href": "lecture2.html#structure-of-a-c-program",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Structure of a C++ program",
    "text": "Structure of a C++ program\n\nHello world printing in C++\n#include &lt;iostream&gt; // standard I/O library in C++\nusing namespace std; // container for \"names\"\nint main() {\n    // cout: output in C++\n    // &lt;&lt;: operator to output\n    // endl: end of line or new line\n    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl;\n    return 0;\n}\nRecall in C it was:\n#include &lt;studio.h&gt;\nint main() {\n    printf(\"Hello world!\\n\");\n    return 0;\n}\n\n\nUser enters a value\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    // cin: input in C++\n    // &gt;&gt;: operator to input\n    // &lt;&lt; value: output a variable\n    int value;\n    cout &lt;&lt; \"Enter an integer: \" &lt;&lt; endl;\n    cin &gt;&gt; value;\n    cout &lt;&lt; \"The integer is: \" &lt;&lt; value &lt;&lt; endl;\n    return 0;\n}\nRecall in C it was:\n#include &lt;studio.h&gt;\nint main() {\n    int value;\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &value);\n    printf(\"The integer is: %d\\n\", value);\n    return 0;\n}\n\n\nData types in C++ and C\nThese are similar between the two languages.\nIntegers: 7, 10, 0, -200 (e.g., int attendees 126;)\n\nint: 32 bits, with range -2^31 to 2^31-1\nshort: 16 bits, with range -2^15 to 2^15-1\nlong: &gt;= 32 bits\n\nReal numbers: 2.7, -101.25 (e.g. double height = 1.72;)\n\nfloat: 32 bits, with 7 digits precision\ndouble: 64 bits, with 15 digits precision\nlong double: &gt;= 64 bits, with 19 digits precision\n\nCharacters: a, b, $ (e.g. char firstInitial = 's';)\nLogic: true, false (e.g. bool isRaining = false;)\nArrays can be used to store multiple data elements of same type under one variable (e.g. int arr[7] = {1, 2, 3, 4, 5, 6, 7};).\nStrings, in C, were null-terminted character arrays (e.g. char h[6] = \"hello\";). Hello is 5 characters, but we need 6 to store the null character as in hello\\0.\nIn C, you can access the string library functions strcmp, strl;en, strcpy from # include &lt;string.h&gt; (e.g. int x = strlen(str)).\nIn C++, we have a string “class” that allows you to create a string type variable. You need to include it using #include &lt;string&gt; (e.g. string courseTitle = \"Programming Fundamentals\";).\nYou can do interesting operations on strings with\n\n+: concatenate\n==: equal to\n!=: not equal to\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n    // == compares strings\n    string courseDepart, courseNum, courseCode;\n    cout &lt;&lt; \"Enter the course department and code: \" &lt;&lt; endl;\n    cin &gt;&gt; courseDepart &gt;&gt; courseNum;\n    courseCode = courseDepart + courseNum;\n    if (courseCode == \"ECE244\") {\n        cout &lt;&lt; \"That's Programming Fundamentals\" &lt;&lt; endl;\n    }\n    return 0;\n}\n\n\nExpressions and statements\nThese are the same as C\n\nArithmetic and relational expressions: x + y, x &gt;= y\nLogical conditions: A || B, A && B, !A\nDecision-making: if and if-else statements\nRepetition: while, do-while, and for loops\n\n\n\nFunctions\nAll code must have at least one function (i.e., main function)\nFunctions allow you to\n\nDivide code into pieces\nAvoid repetition -&gt; you can reuse code\nEasier to debug\n\nExample: Write a function that gets the factorial of a number\n\\[\nn! = n \\times (n-1) \\times (n-2) \\times \\cdots 3 \\times 2 \\times 1\n\\]\n// Function definition\nint factorial(int n) {\n    int fact = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nint main() {\n    int n = 4;\n    // fact: return value stored in fact\n    // factorial(n): pass variable\n    int fact = factorial(n);\n    cout &lt;&lt; \"Factorial of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; fact &lt;&lt; endl;\n    return 0;\n}\nWe can’t call a function before it’s declaration. It’s good practice to declare functions first and then define them after the main function.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Function declaration\nint factorial(int n); // or int factorial(int);\n\n// for int factorial(int);\n// the first int is the return type\n// the second int is the parameter type\n\nint main() {\n    int n = 4;\n    // fact: return value stored in fact\n    // factorial(n): pass variable\n    int fact = factorial(n);\n    cout &lt;&lt; \"Factorial of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; fact &lt;&lt; endl;\n    return 0;\n}\n\n// Function definition\nint factorial(int n) {\n    int fact = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}"
  },
  {
    "objectID": "index.html#about-ece244---programming-fundamentals",
    "href": "index.html#about-ece244---programming-fundamentals",
    "title": "ECE244 Tidy Notes",
    "section": "About ECE244 - Programming Fundamentals",
    "text": "About ECE244 - Programming Fundamentals\nThis course provides a foundation in programming using an object-oriented programming language. Topics include classes and objects, inheritance, basic data structures (lists, tree, hash tables, etc.), Big-O complexity analysis, and testing and debugging. The laboratory assignments emphasize the use of object-oriented programming constructs in the design and implementation of reasonably large programs."
  },
  {
    "objectID": "lecture1.html#motivation",
    "href": "lecture1.html#motivation",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Motivation",
    "text": "Motivation\nWe will learn about a programming paradigm (style/philosophy of programming) called object-oriented programming using C++"
  },
  {
    "objectID": "lecture1.html#why-object-oriented-programming",
    "href": "lecture1.html#why-object-oriented-programming",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Why object-oriented programming?",
    "text": "Why object-oriented programming?\n\nModular code — divide code into independent pieces\nReusable code\nEasily extend code\nEasier to maintain\nEasier to collaborate with large teams\nPopular programming paradigm"
  },
  {
    "objectID": "lecture1.html#why-c",
    "href": "lecture1.html#why-c",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Why C++?",
    "text": "Why C++?\n\nGenerally C/C++ are more difficult as they are closer to the hardware\nCan manage memory\nEasier to learn other languages once you know C/C++"
  },
  {
    "objectID": "lecture2.html#big-picture",
    "href": "lecture2.html#big-picture",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Big picture",
    "text": "Big picture\nBasic computer structure"
  },
  {
    "objectID": "index.html#pachas-notes",
    "href": "index.html#pachas-notes",
    "title": "ECE244 Tidy Notes",
    "section": "Pacha’s notes",
    "text": "Pacha’s notes\n\nThe notes are 100% adjusted to the class.\nIn the snippets folder, I have included some (unofficial) code snippets with the same examples from the notes, that I use to check if the code compiles.\nSome of the examples in the notes have small additions, such as using namespace std; or #include &lt;iostream&gt;, to make them compile.\nThe diagrams are kinda ugly, my apologies! I’m not a graphic designer."
  },
  {
    "objectID": "lecture1.html#summary",
    "href": "lecture1.html#summary",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss what we will learn in this course, motivate object-oriented programming, and how is the course planned/organized/managed."
  },
  {
    "objectID": "lecture2.html#summary",
    "href": "lecture2.html#summary",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss computer hardware, input-output using cin and cout, data types and strings. if time permits, we will dig into functions."
  },
  {
    "objectID": "lecture3.html#summary",
    "href": "lecture3.html#summary",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we review functions, passing-by-value and by-pointers. We introduce passing-by-reference, and introduce multiple files programs."
  },
  {
    "objectID": "lecture3.html#last-lecture",
    "href": "lecture3.html#last-lecture",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nIntroduction to C++"
  },
  {
    "objectID": "lecture3.html#today",
    "href": "lecture3.html#today",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Today",
    "text": "Today\nFunctions and passing parameters\nExample: Write a function that gets the factorial of a number \\(n! = n \\times (n-1) \\times (n-2) \\times \\cdots 3 \\times 2 \\times 1\\)\nint factorial (int n) {\n    int fact = 1;\n    for (int i=0; i &lt;= n; i++) {\n        fact = fact * i;\n    }\n    return fact;\n}\nWe can invoke the function in main\nint main() {\n    int n = 4;\n    // fact: return value stored in fact\n    // factorial: call function that will return n!\n    // n: pass variable\n    int fact = factorial(n);\n    cout &lt;&lt; \"Factorial of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; fact &lt;&lt; endl;\n    return 0;\n}\nWe passed the variable n by value. This means we only passed a copy of n. If we change n in the factorial function, it will not be changed in main.\nThis is called pass-by-value.\nTherefore, if we swap two variables in the following functions, they will not get swapped in main.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap(int x, int y) {\n    int temp = x;\n    x = y;\n    y = temp;\n}\n\nint main() {\n    int x = 7, y = 13;\n    cout &lt;&lt; \"Before swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    swap(x, y);\n    cout &lt;&lt; \"After swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}\nIn C, we resolved this issue by passing the address of the two variables to the swap function.\nvoid swap(int* px, int* py) {\n    // *px: *(&(x)) = x in main\n    int temp = *px;\n    *px = *py;\n    *py = temp;\n}\n\nint main() {\n    int x = 7, y = 13;\n    // &x: address of x\n    // &y: address of y\n    swap(&x, &y);\n    return 0;\n}\nIn C++, there is pass-by-reference syntax that allows a function to access the original variable with no usage of pointers.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap(int& x, int& y) {\n    // no change\n    int temp = x;\n    x = y;\n    y = temp;\n}\n\nint main() {\n    // Pacha's note: I added the cout statements\n    int x = 7, y = 13;\n    cout &lt;&lt; \"Before swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    swap(x, y);\n    cout &lt;&lt; \"After swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}"
  },
  {
    "objectID": "lecture3.html#program-organization",
    "href": "lecture3.html#program-organization",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Program organization",
    "text": "Program organization\nLarge programs are typically organized into multiple files. This helps when we divide tasks in a team.\nThis also can speed up compilation, and we will explain how.\n\nSingle file program\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printNum(int x);\nint userInputNum();\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\nTo compile, run the following command in the terminal\ng++ lecture3-example3.cpp -o lecture3-example3.so\nUse “.exe” instead of “.so” on Windows.\nThis command generates the executable file, which contains zeroes and ones.\n\n\nMultiple files program\nWe can divide the program into multiple files.\nThe function declarations are in the header files (i.e. .h files).\nThe function implementations are in the source files (i.e. .cpp files).\n\nmain.cpp\n// &lt;&gt;: searches in standard library locations\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// \"\": searches in current directory\n#include \"print.h\"\n#include \"input.h\"\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\n\nprint.h\nvoid printNum(int x);\n\n\ninput.h\nint userInputNum();\n\n\nprint.cpp\n#include \"print.h\"\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\n\ninput.cpp\n#include \"input.h\"\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\nTo compile this program with multiple files, there are different ways.\ng++ main.cpp print.cpp input.cpp -o lecture3-example4.so\nWhat happens under the hood?"
  },
  {
    "objectID": "lecture3.html#notes",
    "href": "lecture3.html#notes",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Notes",
    "text": "Notes\n\n#includebelongs to a class of instructions called pre-processor directives.\nPreprocessing happens before the compilation.\nPreprocessing textually replaces the #include with the content of the filename.\nYou can include .cpp files instead of .h files. It is bad practice! Why?\nLinking appends function implementations to produce the executable file.\nLinking takes much less time than compiling.\n\nWhat if I update:\n\nmain.cpp: print.o and input.o will not change. Only main.o will change.\n\ng++ main.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.cpp: main.o and input.o will not change. Only print.o will change.\n\ng++ print.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.h: This changes #include \"print.h\" in main.cpp and print.cpp.\n\ng++ main.cpp\ng++ print.cpp\ng++ main.o print.o input.o -o main.so\nWhat happens if I include the same .h file multiple times? Why would someone do that? Next lecture."
  },
  {
    "objectID": "lecture4.html#summary",
    "href": "lecture4.html#summary",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we review what’s a reference variable, and delve deeply into what happens when we compile a multiple file program."
  },
  {
    "objectID": "lecture4.html#last-lecture",
    "href": "lecture4.html#last-lecture",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nFunctions: pass-by-value and pass-by-reference."
  },
  {
    "objectID": "lecture4.html#today",
    "href": "lecture4.html#today",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Today",
    "text": "Today\nMultiple file programs and separate compilation."
  },
  {
    "objectID": "lecture4.html#references",
    "href": "lecture4.html#references",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "References",
    "text": "References\nA reference is an alias, an alternate name, to a variable.\nExample\nint a = 7, b = 12;\nint& ra = a; // ra refers to a\ncout &lt;&lt; ra &lt;&lt; endl; // prints value of a = 7\nra = b; // changes value of a to 12\n\nReference cannot be re-assigned.\nMust be initialized when declared.\nReference does not have a separate memory location.\n\nAfter executing the following, what are the values of x and y?\nint x = 10;\nint& y = x;\ny = 20;\nx is 20, y is 20.\nWhat is the value of a, ra and b after executing the following?\nint a = 7, b = 12;\nint& ra = a;\nra = b;\na is 12, ra is 12, and b is 12."
  },
  {
    "objectID": "lecture4.html#program-organization",
    "href": "lecture4.html#program-organization",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Program organization",
    "text": "Program organization\nWe want to split code accross multiple files.\n\nOrganized\nEasier to collaborate\nFaster to compile - Why? Today’s topic.\n\n\nSingle file program\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printNum(int x);\nint userInputNum();\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\nTo compile, run the following command in the terminal:\ng++ lecture4-example1.cpp -o lecture4-example1.so\nThis command generates the executable file, which contains zeroes and ones.\n\n\nMultiple file program\n\nmain.cpp\nCorrection to the example from lectura 3: We do not need #include &lt;iostream&gt; nor using namespace std because we are not using cout and cin in this file.\n// \"\": searches in current directory\n#include \"print.h\"\n#include \"input.h\"\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\n\nprint.h\nvoid printNum(int x);\n\n\ninput.h\nint userInputNum();\n\n\nprint.cpp\nWe include iostream here.\nPacha’s note: I added using namespace std here to make it work.\n#include \"print.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\n\ninput.cpp\nPacha’s note: I added using namespace std here to make it work.\n#include \"input.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\n\n\n\nOrganization\n\nFunction declaration goes in header files (i.e., .h files)\nFunction implementation goes in source files (i.e., .cpp files)\n\n\n\nCompilation\nTo compile this program with multiple files, there are different ways.\n\nCase 1\nTo compile, run the following command in the terminal:\ng++ main.cpp print.cpp input.cpp -o main.so\nThis command needs some explanation.\n\nWhat happens under the hood? Remind the diagram from lecture 3.\n\n\nSource file: Has function implementations (e.g, print.cpp, main.cpp).\nHeader file: Has function declarations (e.g., print.h, input.h).\nCompiler: Converts high-level programming language to machine language.\nObject file (cannot be executed): Has machine code with references to other variables in another file (e.g., main.o)\nLinking: A linker combines object files to produce one executable.\nExecutable file: Can be run directly on a CPU.\n\nStory of compilation:\n\n#include belongs to a class of instructions called pre-processor directives.\nBefore compiler compiles to object files, pre-processing textually replaces #include \"file-name\" with contents of the file name.\nCompiler converts pre-processed C++ code to an object file.\nObject file has machine code with references to other files.\nLinking appends function implementation in object files to create an executable.\nLinking takes much less time than compilation.\n\n\n\nCase 2\nSince linking takes less time compared to compiling, we can do separate compilation into\n\ng++ -c main.cpp produces main.o\ng++ -c print.cpp produces print.o\ng++ -c input.cpp produces input.o\ng++ main.o print.o input.o -o main.so produces main.so\n\nWhat if I update\n\nmain.cpp: print.o and input.o will not change. Only main.o will change.\n\ng++ -c main.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.cpp: main.o and input.o will not change. Only print.o will change.\n\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.h: This changes #include \"print.h\" in main.cpp and print.cpp. This is tricky!\n\ng++ -c main.cpp\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\nIDEs, like VS Code, and Make files keep track of what file you changed and minimizes compile commands as they take time.\nIn short, dividing code across multiple files can save compilation time."
  },
  {
    "objectID": "lecture5.html#summary",
    "href": "lecture5.html#summary",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss #ifndef include guards for header files, and introduce C++ I/O."
  },
  {
    "objectID": "lecture5.html#last-lecture",
    "href": "lecture5.html#last-lecture",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nMultiple file programs and separate compilation."
  },
  {
    "objectID": "lecture5.html#today",
    "href": "lecture5.html#today",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Today",
    "text": "Today\nMacros and C++ I/O."
  },
  {
    "objectID": "lecture5.html#recap-from-previous-lecture",
    "href": "lecture5.html#recap-from-previous-lecture",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Recap from previous lecture",
    "text": "Recap from previous lecture\n\nmain.cpp: print.o and input.o will not change. Only main.o will change.\n\ng++ -c main.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.cpp: main.o and input.o will not change. Only print.o will change.\n\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.h: This changes #include \"print.h\" in main.cpp and print.cpp. This is tricky!\n\ng++ -c main.cpp\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\nIDEs, like VS Code, and Make files keep track of what file you changed and minimizes compile commands as they take time.\nIn short, dividing code across multiple files can save compilation time."
  },
  {
    "objectID": "lecture5.html#macros",
    "href": "lecture5.html#macros",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Macros",
    "text": "Macros\nWhat happens if I include the same header (.h file) multiple times?\nWhy would someone do that?\nWhat happens if?\n\nTo solve this, a preprocessor #ifndef guards against including a header file several times.\nSolution\n// a.h\n\n#ifdef A_H\n#define A_H\n\nstruct A {\n    ...\n}l\n\n#endif\nThe first time “a.h” is read, it will find A_H is not defined.\nThen it will define A_H and struct A.\nThe next time it reads “a.h”, A_H will be defined and hence would skip instructions until #endif.\nIn general, #ifdef [MACRO]ignores the whole code until #endif if [MACRO] is defined.\n#ifndef [MACRO] ignores the whole code until #endif if [MACRO] is not defined.\nWhy do we need header files? Can we just have .cpp files and include it?\nExample\n// main .cpp\n\n#include \"print.cpp\"\n\nint main() {\n    ...\n}\n// print.cpp\n\n#include &lt;iostream&gt;\n\nvoid printNum(int x) {\n    ...\n}\nThis means wheter I change print.cpp, I will have to re-compile main.cpp and print.cpp.\nAlso, linking will fail as main.cpp will have printNum() implemented and print.cpp too. You will have multiple definitions of printNum in the executable main, which is not allowed.\n\n\nmain.o will have printNum() implementation\nprint.o already has printNum() implementation\nprintNum() is defined twiece, so linking will fail."
  },
  {
    "objectID": "lecture5.html#c-io",
    "href": "lecture5.html#c-io",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "C++ I/O",
    "text": "C++ I/O\nThere are many ways to take input and produce output.\n\nStandard input-output\nUsing cout and cin from iostream.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int x;\n    cout \"Hello world\" &lt;&lt; endl;\n    cin &gt;&gt; x;\n    return 0;\n}\n\n\nFile input-output\nUsing ifstream (input file) and ofstream (output file) from fstream.\n\nOutput to a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n    ofstream outFile(\"myFile.txt\");\n    string name = \"We are engineers!\";\n    outFile &lt;&lt; name;\n    outFile.close();\n}\nIf a file does not exist , it will be created. If it exists, its contents will be overwritten.\nTo append a file, use ofstream outFile(\"myFile.txt\", ios::app);.\n\n\nInput from a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n    ifstream inputFile;\n    inputFile.open(\"myFile.txt\");\n\n    // or ifstream inputFile(\"myFile.txt\");\n    // to replace the two lines above\n\n    int num1, num2, num3;\n    \n    // input from file\n    inputFile &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;\n\n    inputFile.close();\n\n    return 0;\n}\n\nWhere to find the file?\n\n```cpp\n// absolute path\ninFile.open(\"/u/prof/emarasal/ece244/lab1/myFile.txt\")\n\n// relative path\ninFile.open(\"lab1/myFile.txt\")\ninFile.open(\"../myFile.txt\")\n\n// current directory\ninFile.open(\"myFile.txt\")\nBuffering\n\nThe output is not immediately written to a file.\nIt will be written in “chunks”.\nWhy buffering? Writing in a buffer is much faster than writing in a file.\nTo optimize resources, writing in files happens in chunks.\nTo force output, use outputFile.flush() or outputFile &lt;&lt; endl;."
  }
]