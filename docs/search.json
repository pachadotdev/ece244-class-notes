[
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "ECE244 tidy notes",
    "section": "Motivation",
    "text": "Motivation\nWe will learn about a programming paradigm (style/philosophy of programming) called object-oriented programming using C++"
  },
  {
    "objectID": "index.html#why-object-oriented-programming",
    "href": "index.html#why-object-oriented-programming",
    "title": "ECE244 tidy notes",
    "section": "Why object-oriented programming?",
    "text": "Why object-oriented programming?\n\nModular code — divide code into independent pieces\nReusable code\nEasily extend code\nEasier to maintain\nEasier to collaborate with large teams\nPopular programming paradigm"
  },
  {
    "objectID": "index.html#why-c",
    "href": "index.html#why-c",
    "title": "ECE244 tidy notes",
    "section": "Why C++?",
    "text": "Why C++?\n\nGenerally C/C++ are more difficult as they are closer to the hardware\nCan manage memory\nEasier to learn other languages once you know C/C++"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ECE244 Tidy Notes",
    "section": "",
    "text": "This course provides a foundation in programming using an object-oriented programming language. Topics include classes and objects, inheritance, basic data structures (lists, tree, hash tables, etc.), Big-O complexity analysis, and testing and debugging. The laboratory assignments emphasize the use of object-oriented programming constructs in the design and implementation of reasonably large programs."
  },
  {
    "objectID": "lecture2.html#today",
    "href": "lecture2.html#today",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Today",
    "text": "Today\nIntroduction to C++"
  },
  {
    "objectID": "lecture2.html#assumption",
    "href": "lecture2.html#assumption",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Assumption",
    "text": "Assumption\nYou are familiar with basic C programming (i.e., data types, variables, if statements, loops and functions)"
  },
  {
    "objectID": "lecture2.html#structure-of-a-c-program",
    "href": "lecture2.html#structure-of-a-c-program",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Structure of a C++ program",
    "text": "Structure of a C++ program\n\nHello world printing in C++\n#include &lt;iostream&gt; // standard I/O library in C++\nusing namespace std; // container for \"names\"\nint main() {\n    // cout: output in C++\n    // &lt;&lt;: operator to output\n    // endl: end of line or new line\n    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl;\n    return 0;\n}\nRecall in C it was:\n#include &lt;studio.h&gt;\nint main() {\n    printf(\"Hello world!\\n\");\n    return 0;\n}\n\n\nUser enters a value\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    // cin: input in C++\n    // &gt;&gt;: operator to input\n    // &lt;&lt; value: output a variable\n    int value;\n    cout &lt;&lt; \"Enter an integer: \" &lt;&lt; endl;\n    cin &gt;&gt; value;\n    cout &lt;&lt; \"The integer is: \" &lt;&lt; value &lt;&lt; endl;\n    return 0;\n}\nRecall in C it was:\n#include &lt;studio.h&gt;\nint main() {\n    int value;\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &value);\n    printf(\"The integer is: %d\\n\", value);\n    return 0;\n}\n\n\nData types in C++ and C\nThese are similar between the two languages.\nIntegers: 7, 10, 0, -200 (e.g., int attendees 126;)\n\nint: 32 bits, with range -2^31 to 2^31-1\nshort: 16 bits, with range -2^15 to 2^15-1\nlong: &gt;= 32 bits\n\nReal numbers: 2.7, -101.25 (e.g. double height = 1.72;)\n\nfloat: 32 bits, with 7 digits precision\ndouble: 64 bits, with 15 digits precision\nlong double: &gt;= 64 bits, with 19 digits precision\n\nCharacters: a, b, $ (e.g. char firstInitial = 's';)\nLogic: true, false (e.g. bool isRaining = false;)\nArrays can be used to store multiple data elements of same type under one variable (e.g. int arr[7] = {1, 2, 3, 4, 5, 6, 7};).\nStrings, in C, were null-terminted character arrays (e.g. char h[6] = \"hello\";). Hello is 5 characters, but we need 6 to store the null character as in hello\\0.\nIn C, you can access the string library functions strcmp, strl;en, strcpy from # include &lt;string.h&gt; (e.g. int x = strlen(str)).\nIn C++, we have a string “class” that allows you to create a string type variable. You need to include it using #include &lt;string&gt; (e.g. string courseTitle = \"Programming Fundamentals\";).\nYou can do interesting operations on strings with\n\n+: concatenate\n==: equal to\n!=: not equal to\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n    // == compares strings\n    string courseDepart, courseNum, courseCode;\n    cout &lt;&lt; \"Enter the course department and code: \" &lt;&lt; endl;\n    cin &gt;&gt; courseDepart &gt;&gt; courseNum;\n    courseCode = courseDepart + courseNum;\n    if (courseCode == \"ECE244\") {\n        cout &lt;&lt; \"That's Programming Fundamentals\" &lt;&lt; endl;\n    }\n    return 0;\n}\n\n\nExpressions and statements\nThese are the same as C\n\nArithmetic and relational expressions: x + y, x &gt;= y\nLogical conditions: A || B, A && B, !A\nDecision-making: if and if-else statements\nRepetition: while, do-while, and for loops\n\n\n\nFunctions\nAll code must have at least one function (i.e., main function)\nFunctions allow you to\n\nDivide code into pieces\nAvoid repetition -&gt; you can reuse code\nEasier to debug\n\nExample: Write a function that gets the factorial of a number\n\\[\nn! = n \\times (n-1) \\times (n-2) \\times \\cdots 3 \\times 2 \\times 1\n\\]\n// Function definition\nint factorial(int n) {\n    int fact = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nint main() {\n    int n = 4;\n    // fact: return value stored in fact\n    // factorial(n): pass variable\n    int fact = factorial(n);\n    cout &lt;&lt; \"Factorial of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; fact &lt;&lt; endl;\n    return 0;\n}\nWe can’t call a function before it’s declaration. It’s good practice to declare functions first and then define them after the main function.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Function declaration\nint factorial(int n); // or int factorial(int);\n\n// for int factorial(int);\n// the first int is the return type\n// the second int is the parameter type\n\nint main() {\n    int n = 4;\n    // fact: return value stored in fact\n    // factorial(n): pass variable\n    int fact = factorial(n);\n    cout &lt;&lt; \"Factorial of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; fact &lt;&lt; endl;\n    return 0;\n}\n\n// Function definition\nint factorial(int n) {\n    int fact = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}"
  },
  {
    "objectID": "index.html#about-ece244---programming-fundamentals",
    "href": "index.html#about-ece244---programming-fundamentals",
    "title": "Hiram: ECE244 Tidy Notes",
    "section": "About ECE244 - Programming Fundamentals",
    "text": "About ECE244 - Programming Fundamentals\nThis course provides a foundation in programming using an object-oriented programming language. Topics include classes and objects, inheritance, basic data structures (lists, tree, hash tables, etc.), Big-O complexity analysis, and testing and debugging. The laboratory assignments emphasize the use of object-oriented programming constructs in the design and implementation of reasonably large programs."
  },
  {
    "objectID": "lecture1.html#motivation",
    "href": "lecture1.html#motivation",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Motivation",
    "text": "Motivation\nWe will learn about a programming paradigm (style/philosophy of programming) called object-oriented programming using C++"
  },
  {
    "objectID": "lecture1.html#why-object-oriented-programming",
    "href": "lecture1.html#why-object-oriented-programming",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Why object-oriented programming?",
    "text": "Why object-oriented programming?\n\nModular code — divide code into independent pieces\nReusable code\nEasily extend code\nEasier to maintain\nEasier to collaborate with large teams\nPopular programming paradigm"
  },
  {
    "objectID": "lecture1.html#why-c",
    "href": "lecture1.html#why-c",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Why C++?",
    "text": "Why C++?\n\nGenerally C/C++ are more difficult as they are closer to the hardware\nCan manage memory\nEasier to learn other languages once you know C/C++"
  },
  {
    "objectID": "lecture2.html#big-picture",
    "href": "lecture2.html#big-picture",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Big picture",
    "text": "Big picture\nBasic computer structure"
  },
  {
    "objectID": "index.html#pachas-notes",
    "href": "index.html#pachas-notes",
    "title": "Hiram: ECE244 Tidy Notes",
    "section": "Pacha’s notes",
    "text": "Pacha’s notes\n\nThe notes are 100% adjusted to the class.\nIn the snippets folder, I have included some (unofficial) code snippets with the same examples from the notes, that I use to check if the code compiles.\nSome of the examples in the notes have small additions, such as using namespace std; or #include &lt;iostream&gt;, to make them compile.\nThe diagrams are kinda ugly, my apologies! I’m not a graphic designer."
  },
  {
    "objectID": "lecture1.html#summary",
    "href": "lecture1.html#summary",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss what we will learn in this course, motivate object-oriented programming, and how is the course planned/organized/managed."
  },
  {
    "objectID": "lecture2.html#summary",
    "href": "lecture2.html#summary",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss computer hardware, input-output using cin and cout, data types and strings. if time permits, we will dig into functions."
  },
  {
    "objectID": "lecture3.html#summary",
    "href": "lecture3.html#summary",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we review functions, passing-by-value and by-pointers. We introduce passing-by-reference, and introduce multiple files programs."
  },
  {
    "objectID": "lecture3.html#last-lecture",
    "href": "lecture3.html#last-lecture",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nIntroduction to C++"
  },
  {
    "objectID": "lecture3.html#today",
    "href": "lecture3.html#today",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Today",
    "text": "Today\nFunctions and passing parameters\n\n\n\n\n\n\nExample\n\n\n\nWrite a function that gets the factorial of a number \\(n! = n \\times (n-1) \\times (n-2) \\times \\cdots 3 \\times 2 \\times 1\\)\nint factorial (int n) {\n    int fact = 1;\n    for (int i=0; i &lt;= n; i++) {\n        fact = fact * i;\n    }\n    return fact;\n}\nWe can invoke the function in main\nint main() {\n    int n = 4;\n    // fact: return value stored in fact\n    // factorial: call function that will return n!\n    // n: pass variable\n    int fact = factorial(n);\n    cout &lt;&lt; \"Factorial of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; fact &lt;&lt; endl;\n    return 0;\n}\n\n\nWe passed the variable n by value. This means we only passed a copy of n. If we change n in the factorial function, it will not be changed in main.\nThis is called pass-by-value.\nTherefore, if we swap two variables in the following functions, they will not get swapped in main.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap(int x, int y) {\n    int temp = x;\n    x = y;\n    y = temp;\n}\n\nint main() {\n    int x = 7, y = 13;\n    cout &lt;&lt; \"Before swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    swap(x, y);\n    cout &lt;&lt; \"After swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}\nIn C, we resolved this issue by passing the address of the two variables to the swap function.\nvoid swap(int* px, int* py) {\n    // *px: *(&(x)) = x in main\n    int temp = *px;\n    *px = *py;\n    *py = temp;\n}\n\nint main() {\n    int x = 7, y = 13;\n    // &x: address of x\n    // &y: address of y\n    swap(&x, &y);\n    return 0;\n}\nIn C++, there is pass-by-reference syntax that allows a function to access the original variable with no usage of pointers.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added the cout statements to the code below.\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap(int& x, int& y) {\n    // no change\n    int temp = x;\n    x = y;\n    y = temp;\n}\n\nint main() {\n    int x = 7, y = 13;\n    cout &lt;&lt; \"Before swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    swap(x, y);\n    cout &lt;&lt; \"After swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}"
  },
  {
    "objectID": "lecture3.html#program-organization",
    "href": "lecture3.html#program-organization",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Program organization",
    "text": "Program organization\nLarge programs are typically organized into multiple files. This helps when we divide tasks in a team.\nThis also can speed up compilation, and we will explain how.\n\nSingle file program\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printNum(int x);\nint userInputNum();\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\nTo compile, run the following command in the terminal\ng++ lecture3-example3.cpp -o lecture3-example3.so\nUse “.exe” instead of “.so” on Windows.\nThis command generates the executable file, which contains zeroes and ones.\n\n\nMultiple files program\nWe can divide the program into multiple files.\nThe function declarations are in the header files (i.e. .h files).\nThe function implementations are in the source files (i.e. .cpp files).\n\nmain.cpp\n// &lt;&gt;: searches in standard library locations\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// \"\": searches in current directory\n#include \"print.h\"\n#include \"input.h\"\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\n\nprint.h\nvoid printNum(int x);\n\n\ninput.h\nint userInputNum();\n\n\nprint.cpp\n#include \"print.h\"\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\n\ninput.cpp\n#include \"input.h\"\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\nTo compile this program with multiple files, there are different ways.\ng++ main.cpp print.cpp input.cpp -o lecture3-example4.so\nWhat happens under the hood?"
  },
  {
    "objectID": "lecture3.html#notes",
    "href": "lecture3.html#notes",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Notes",
    "text": "Notes\n\n#includebelongs to a class of instructions called pre-processor directives.\nPreprocessing happens before the compilation.\nPreprocessing textually replaces the #include with the content of the filename.\nYou can include .cpp files instead of .h files. It is bad practice! Why?\nLinking appends function implementations to produce the executable file.\nLinking takes much less time than compiling.\n\nWhat if I update…\n\nmain.cpp\nprint.o and input.o will not change. Only main.o will change.\ng++ main.cpp\ng++ main.o print.o input.o -o main.so\n\n\nprint.cpp\nmain.o and input.o will not change. Only print.o will change.\ng++ print.cpp\ng++ main.o print.o input.o -o main.so\n\n\nprint.h\nThis changes #include \"print.h\" in main.cpp and print.cpp.\ng++ main.cpp\ng++ print.cpp\ng++ main.o print.o input.o -o main.so\nWhat happens if I include the same .h file multiple times? Why would someone do that? Next lecture."
  },
  {
    "objectID": "lecture4.html#summary",
    "href": "lecture4.html#summary",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we review what’s a reference variable, and delve deeply into what happens when we compile a multiple file program."
  },
  {
    "objectID": "lecture4.html#last-lecture",
    "href": "lecture4.html#last-lecture",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nFunctions: pass-by-value and pass-by-reference."
  },
  {
    "objectID": "lecture4.html#today",
    "href": "lecture4.html#today",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Today",
    "text": "Today\nMultiple file programs and separate compilation."
  },
  {
    "objectID": "lecture4.html#references",
    "href": "lecture4.html#references",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "References",
    "text": "References\nA reference is an alias, an alternate name, to a variable.\n\n\n\n\n\n\nExample\n\n\n\nint a = 7, b = 12;\nint& ra = a; // ra refers to a\ncout &lt;&lt; ra &lt;&lt; endl; // prints value of a = 7\nra = b; // changes value of a to 12\n\n\n\nReference cannot be re-assigned.\nMust be initialized when declared.\nReference does not have a separate memory location.\n\n\n\n\n\n\n\nExample\n\n\n\nAfter executing the following, what are the values of x and y?\nint x = 10;\nint& y = x;\ny = 20;\nx is 20, y is 20.\n\n\n\n\n\n\n\n\nExample\n\n\n\nWhat is the value of a, ra and b after executing the following?\nint a = 7, b = 12;\nint& ra = a;\nra = b;\na is 12, ra is 12, and b is 12."
  },
  {
    "objectID": "lecture4.html#program-organization",
    "href": "lecture4.html#program-organization",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Program organization",
    "text": "Program organization\nWe want to split code accross multiple files.\n\nOrganized\nEasier to collaborate\nFaster to compile - Why? Today’s topic.\n\n\nSingle file program\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printNum(int x);\nint userInputNum();\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\nTo compile, run the following command in the terminal:\ng++ lecture4-example1.cpp -o lecture4-example1.so\nThis command generates the executable file, which contains zeroes and ones.\n\n\nMultiple file program\n\nmain.cpp\nCorrection to the example from lecture 3: We do not need #include &lt;iostream&gt; nor using namespace std because we are not using cout and cin in this file.\n// \"\": searches in current directory\n#include \"print.h\"\n#include \"input.h\"\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\n\nprint.h\nvoid printNum(int x);\n\n\ninput.h\nint userInputNum();\n\n\nprint.cpp\nWe include iostream here.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added using namespace std here to make the code compile.\n\n\n#include \"print.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\n\ninput.cpp\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added using namespace std here to make the code compile.\n\n\n#include \"input.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\n\n\n\nOrganization\n\nFunction declaration goes in header files (i.e., .h files)\nFunction implementation goes in source files (i.e., .cpp files)\n\n\n\nCompilation\nTo compile this program with multiple files, there are different ways.\n\nCase 1\nTo compile, run the following command in the terminal:\ng++ main.cpp print.cpp input.cpp -o main.so\nThis command needs some explanation.\n\nWhat happens under the hood? Remember the diagram from lecture 3.\n\n\nSource file: Has function implementations (e.g, print.cpp, main.cpp).\nHeader file: Has function declarations (e.g., print.h, input.h).\nCompiler: Converts high-level programming language to machine language.\nObject file (cannot be executed): Has machine code with references to other variables in another file (e.g., main.o)\nLinking: A linker combines object files to produce one executable.\nExecutable file: Can be run directly on a CPU.\n\nStory of compilation:\n\n#include belongs to a class of instructions called pre-processor directives.\nBefore compiler compiles to object files, pre-processing textually replaces #include \"file-name\" with contents of the file name.\nCompiler converts pre-processed C++ code to an object file.\nObject file has machine code with references to other files.\nLinking appends function implementation in object files to create an executable.\nLinking takes much less time than compilation.\n\n\n\nCase 2\nSince linking takes less time compared to compiling, we can do separate compilation into\n\ng++ -c main.cpp produces main.o\ng++ -c print.cpp produces print.o\ng++ -c input.cpp produces input.o\ng++ main.o print.o input.o -o main.so produces main.so\n\nWhat if I update…\n\n\nmain.cpp\nprint.o and input.o will not change. Only main.o will change.\ng++ -c main.cpp\ng++ main.o print.o input.o -o main.so\n\n\nprint.cpp\nmain.o and input.o will not change. Only print.o will change.\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\n\n\nprint.h\nThis changes #include \"print.h\" in main.cpp and print.cpp. This is tricky!\ng++ -c main.cpp\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\nIDEs, like VS Code, and Make files keep track of what file you changed and minimizes compile commands as they take time.\nIn short, dividing code across multiple files can save compilation time."
  },
  {
    "objectID": "lecture5.html#summary",
    "href": "lecture5.html#summary",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss #ifndef include guards for header files, and introduce C++ I/O."
  },
  {
    "objectID": "lecture5.html#last-lecture",
    "href": "lecture5.html#last-lecture",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nMultiple file programs and separate compilation."
  },
  {
    "objectID": "lecture5.html#today",
    "href": "lecture5.html#today",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Today",
    "text": "Today\nMacros and C++ I/O."
  },
  {
    "objectID": "lecture5.html#recap-from-previous-lecture",
    "href": "lecture5.html#recap-from-previous-lecture",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Recap from previous lecture",
    "text": "Recap from previous lecture\n\nmain.cpp: print.o and input.o will not change. Only main.o will change.\n\ng++ -c main.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.cpp: main.o and input.o will not change. Only print.o will change.\n\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.h: This changes #include \"print.h\" in main.cpp and print.cpp. This is tricky!\n\ng++ -c main.cpp\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\nIDEs, like VS Code, and Make files keep track of what file you changed and minimizes compile commands as they take time.\nIn short, dividing code across multiple files can save compilation time."
  },
  {
    "objectID": "lecture5.html#macros",
    "href": "lecture5.html#macros",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Macros",
    "text": "Macros\nWhat happens if I include the same header (.h file) multiple times?\nWhy would someone do that?\n\n\n\n\n\n\nExample\n\n\n\nWhat happens if we have this structure?\n\nTo solve this, a preprocessor #ifndef guards against including a header file several times.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n// a.h\n\n#ifdef A_H\n#define A_H\n\nstruct A {\n    ...\n}\n\n#endif\nThe first time “a.h” is read, it will find A_H is not defined.\nThen it will define A_H and struct A.\nThe next time it reads “a.h”, A_H will be defined and hence would skip instructions until #endif.\n\n\n\nIn general, #ifdef [MACRO]ignores the whole code until #endif if [MACRO] is defined.\n#ifndef [MACRO] ignores the whole code until #endif if [MACRO] is not defined.\nWhy do we need header files? Can we just have .cpp files and include it?\n\n\n\n\n\n\nExample\n\n\n\n// main .cpp\n\n#include \"print.cpp\"\n\nint main() {\n  ...\n}\n// print.cpp\n\n#include &lt;iostream&gt;\n\nvoid printNum(int x) {\n    ...\n}\nThis means wheter I change print.cpp, I will have to re-compile main.cpp and print.cpp.\nAlso, linking will fail as main.cpp will have printNum() implemented and print.cpp too. You will have multiple definitions of printNum in the executable main, which is not allowed.\n\n\nmain.o will have printNum() implementation\nprint.o already has printNum() implementation\nprintNum() is defined twiece, so linking will fail."
  },
  {
    "objectID": "lecture5.html#c-io",
    "href": "lecture5.html#c-io",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "C++ I/O",
    "text": "C++ I/O\nThere are many ways to take input and produce output.\n\nStandard input-output\nUsing cout and cin from iostream.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int x;\n    cout \"Hello world\" &lt;&lt; endl;\n    cin &gt;&gt; x;\n    return 0;\n}\n\n\nFile input-output\nUsing ifstream (input file) and ofstream (output file) from fstream.\n\nOutput to a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n    ofstream outFile(\"myFile.txt\");\n    string name = \"We are engineers!\";\n    outFile &lt;&lt; name;\n    outFile.close();\n}\nIf a file does not exist , it will be created. If it exists, its contents will be overwritten.\nTo append a file, use ofstream outFile(\"myFile.txt\", ios::app);.\n\n\nInput from a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n    ifstream inputFile;\n    inputFile.open(\"myFile.txt\");\n\n    // or ifstream inputFile(\"myFile.txt\");\n    // to replace the two lines above\n\n    int num1, num2, num3;\n    \n    // input from file\n    inputFile &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;\n\n    inputFile.close();\n\n    return 0;\n}\n\nWhere to find the file?\n\n```cpp\n// absolute path\ninFile.open(\"/u/prof/emarasal/ece244/lab1/myFile.txt\")\n\n// relative path\ninFile.open(\"lab1/myFile.txt\")\ninFile.open(\"../myFile.txt\")\n\n// current directory\ninFile.open(\"myFile.txt\")\n\n\nBuffering\n\nThe output is not immediately written to a file.\nIt will be written in “chunks”.\nWhy buffering? Writing in a buffer is much faster than writing in a file.\nTo optimize resources, writing in files happens in chunks.\nTo force output, use outputFile.flush() or outputFile &lt;&lt; endl;."
  },
  {
    "objectID": "lecture5.html#ungraded-homework",
    "href": "lecture5.html#ungraded-homework",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Ungraded homework",
    "text": "Ungraded homework\nSolve the exercises of Chapter 1: Programming Basics\n\n\n\n\n\n\nExercise 1\n\n\n\nQuestion 2 in Fall 2022 Midterm Exam [Easy]\nWhen you compile the following program, what happens? If there is an error, explain what the error is (one sentence max).\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  hello(1);\n  return 0;\n}\nvoid hello(int i) {\n  cout &lt;&lt; \"Hello !\" &lt;&lt; i &lt;&lt; endl;\n  return;\n}\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThere will be a compilation error because hello() is called before it is declared.\nThe correct code is:\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Forward function\nvoid hello(int i);  \n\nint main() {\n  hello(1);\n  return 0;\n}\n\n// Function definition\nvoid hello(int i) {\n    cout &lt;&lt; \"Hello !\" &lt;&lt; i &lt;&lt; endl;\n    return;\n}\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nQuestion 4 in Fall 2022 Midterm Exam [Easy]\nWhich is the output of the following program?\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid increment(int& a) {\n  a = a + 1;\n}\n\nvoid decrement(int a) {\n  a = a - 1;\n}\n\nvoid doubling(int* a) {\n  *a = (*a) * 2;\n}\n\nint main() {\n  int a = 3;\n  increment(a);\n  cout &lt;&lt; a &lt;&lt; endl;\n  decrement(a);\n  cout &lt;&lt; a &lt;&lt; endl;\n  doubling(&a);\n  cout &lt;&lt; a &lt;&lt; endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n4, 4 and 8 because increment() is called by reference, decrement() is called by value and doubling() takes a pointer and dereferences it to modify the original value.\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nQuestion 6 in Fall 2022 Midterm Exam [Easy]:\nCompared to C, passing by reference is introduced in C++. Both of the following two functions can be used to swap the value of two integers:\nvoid swap_by_p(int* a, int* b); // swap version.1\nvoid swap_by_r(int& a, int& b); // swap version.2\nPart 1. Write the implementations for these two functions (no more than 4 lines of code for each function)\nvoid swap_by_p(int* a, int* b) {\n    ...\n}\n\nvoid swap_by_r(int& a, int& b) {\n    ...\n}\nPart 2. If given two int variables x and y, write a function call that swaps the value of x and y, using swap_by_p.\nPart 3. If given two int variables x and y, write a function call that swaps the value of x and y, using swap_by_r.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid swap_by_p(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid swap_by_r(int& a, int& b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 200;\n    int y = 100;\n    swap_by_p(&x, &y);\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;\n    swap_by_r(x, y);\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nQuestion 7 in Fall 2022 Midterm Exam [Easy]\nEllie writes a program to make a simple database for ECE students who like drinking soy milk from 2T2 to 2T6. She designs two classes: student and ECE, and puts them into different files below. The main function is in the main.cpp.\nECE.h\n#ifndefine ECE\n#define ECE\n\n#include \"student.h\"\n\nclass ECE{\n    ...\n};\n\n#endif\nECE.cpp\n#include \"ECE.h\"\n\nECE::ECE() {\n    ...\n}\nstudent.h\n#include &lt;string&gt;\n\nclass Student {\n    ...\n};\nstudent.cpp\n#include \"student.h\"\n\nStudent::Student() {\n    ...\n}\nmain.cpp\n#include \"ECE.h\"\n#include \"student.h\"\n\nint main() {\n    ...\n}\nPart 1. Ellie tries to compile this program with g++. What’s the Unix (i.e., terminal) command that compiles the entire program using one command, which generates an executable called small_database?\nPart 2. However, it fails to compile. Can you point out the compile-time error and fix this error for her?\nPart 3. With your help, Ellie has fixed the compile-time error. Now, Ellie wants to use separate compilation learned from ECE244 to compile her project. Write down all the Unix commands necessary to separately compile the above files and generate an executable small_database.\nPart 4. Ellie then changes some code in ECE.cpp. Write down the Unix commands necessary to regenerate the executable by compiling the smallest number of files needed. Assume the generated executable is called small_database.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nCompile with\ng++ main.cpp ECE.cpp student.cpp -o small_database\nThe first problem is that student.h has no header guard, and it is included in both ECE.h and student.cpp. This will cause a multiple definition error.\nThe solution is to add a header guard to student.h.\n#ifndef STUDENT\n#define STUDENT\n\n#include &lt;string&gt;\n\nclass Student {\n    ...\n};\nThe second problem is that ECE.h says #ifndefine ECE, but it should be #ifndef ECE.\nTo compile separately, use\ng++ -c student.cpp -o student.o\ng++ -c ECE.cpp -o ECE.o\ng++ -c main.cpp -o main.o\ng++ student.o ECE.o main.o -o small_database\nAfter changing ECE.cpp, use\ng++ -c ECE.cpp -o ECE.o\ng++ student.o ECE.o main.o -o small_database\n\n\n\n\n\n\n\n\n\nExercise 5\n\n\n\n\n\nQuestion 2 Fall 2018 Midterm Exam\nYou are given a program that has a main function and 3 classes: First, Second and Third. For each of these classes, you have a definition file and an implementation file. Thus, you have seven files in total: First.h, First.cpp, Second.h, Second.cpp, Third.h, Third.cpp and main.cpp. All the files exist in the same directory.\nThe first few lines of each file are shown below. The rest of the contents of each file is irrelevant to the question and is shown as …. You may assume the definition/implementation files are error-free.\nFirst.h\n#ifndef FIRST_H\n#define FIRST_H\n\nclass First {\n    ...\n};\n#endif\nFirst.cpp\n#include “First.h”\n\nFirst::First() {\n    ...\n}\nSecond.h\n#ifndef SECOND_H\n#define SECOND_H\n\nclass Second {\n  ...\n};\n\n#endif\nSecond.cpp\n#include \"First.h\"\n#include \"Second.h\"\n\nSecond::Second() {\n  ...\n}\nThird.h\n#ifndef THIRD_H\n#define THIRD_H\n\nclass Third {\n  ...\n};\n\n#endif\nThird.cpp\n#include \"Second.h\"\n\nThird::Third() {\n  ...\n}\nmain.cpp\n#include \"First.h\"\n#include \"Second.h\"\n#include \"Third.h\"\n\nint main() {\n  ...\n}\nThe files are to be separately compiled and then linked into a single executable called main.\nPart 1. Write down the Unix commands necessary to separately compile the above files and generate the executable.\nPart 2. You modify the file Second.cpp. Write down the Unix commands necessary to regenerate the executable by compiling the smallest number of files possible.\nPart 3. You modify the file First.h. Write down the Unix commands necessary to regenerate the executable by compiling the smallest number of files possible.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPart 1\ng++ -c First.cpp -o First.o\ng++ -c Second.cpp -o Second.o\ng++ -c Third.cpp -o Third.o\ng++ -c main.cpp -o main.o\ng++ First.o Second.o Third.o main.o -o main\nPart 2\ng++ -c Second.cpp -o Second.o\ng++ First.o Second.o Third.o main.o -o main\nPart 3\ng++ -c First.cpp -o First.o\ng++ -c Second.cpp -o Second.o\ng++ First.o Second.o Third.o main.o -o main"
  },
  {
    "objectID": "lecture6.html#summary",
    "href": "lecture6.html#summary",
    "title": "Lecture 6 - Sept 19, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we introduce file input/output and what happens when the input is unexpected."
  },
  {
    "objectID": "lecture6.html#last-lecture",
    "href": "lecture6.html#last-lecture",
    "title": "Lecture 6 - Sept 19, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nSeparate compilation and header guards."
  },
  {
    "objectID": "lecture6.html#today",
    "href": "lecture6.html#today",
    "title": "Lecture 6 - Sept 19, 2023",
    "section": "Today",
    "text": "Today\nC++ file I/O and handling errors.\nThere are many ways to take input and produce output.\n\nStandard input-output\nUsing cout and cin from iostream.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  int x;\n  cout &lt;&lt; \"Hello world\" &lt;&lt; endl;\n  cin &gt;&gt; x;\n  return 0;\n}\n\n\nFile input-output\nUsing ifstream and ofstream from fstream.\n\nOutput to a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n  ofstream outFile(\"output.txt\");\n  string name = \"We are engineers!\";\n  outFile &lt;&lt; name;\n  outFile.close();\n}\nIf a file does not exist, it will be created. If it exists, its contents will be overwritten.\nTo append to a file, use outFile.open(\"output.txt\", ios::app).\n\n\nInput from a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n  ifstream inputFile;\n  inputFile.open(\"myFile.txt\");\n\n  // or ifstream inputFile(\"myFile.txt\");\n  // to replace the two lines above\n\n  int num1, num2, num3;\n\n  // input from file\n  inputFile &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;\n\n  inputFile.close();\n\n  return 0;\n}\nWhere to find the file?\n// absolute path\ninFile.open(\"/u/prof/emarasal/ece244/lab1/myFile.txt\")\n\n// relative path\ninFile.open(\"lab1/myFile.txt\")\ninFile.open(\"../myFile.txt\")\n\n// current directory\ninFile.open(\"myFile.txt\")\nBuffering\n\nThe output is not immediately written to a file.\nIt will be written in “chunks”.\nWhy buffering? Writing in a buffer is much faster than writing in a file.\nTo optimize resources, writing in files happens in chunks.\nTo force output, use outputFile.flush() or outputFile &lt;&lt; endl;.\n\nRemember the diagram from lecture 5."
  },
  {
    "objectID": "lecture6.html#handling-io-errors",
    "href": "lecture6.html#handling-io-errors",
    "title": "Lecture 6 - Sept 19, 2023",
    "section": "Handling I/O errors",
    "text": "Handling I/O errors\n\nInput stream is stored in a buffer.\nThis buffer is only available when \\n is entered.\ncin ignores/skips delimiters or whitespaces\nDelimiters are , \\t, \\n.\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\nReading still happens until a delimiter is seen or when something wrong happens!\n\n\n\n\n\n\nExample\n\n\n\n\n\ncin will read 13 into x, but it will not read ● as it is not part of an integer.\ncin will look for an int for y, but will find ●.\ncin will fail silently , y is unaffected, and the buffer is unaffected.\nA fail flag is raised, and all other cin in the program will fail.\n\nWhat should you do?\n\nCheck if the fail flag is raised.\nIf yes, handle the error.\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n// file input\n\n#include &lt;fstream&gt;\n\nint main() {\n  ifstream inputFile(\"myFile.txt\"); // error 1\n  int a,b;\n  inputFile &gt;&gt; a &gt;&gt; b; // error 2 and 3\n  return 0;\n}\n// standard input\n\n#include &lt;iostream&gt;\n\nint main() {\n  int a;\n  cin &gt;&gt; a; // error 2 and 3\n  return 0;\n}\nWhat can go wrong?\nError 1. The file to be opened for input does not exist.\nError 2. The variable cannot be read.\nError 3. Reached the end of a file.\n\n\n\nHow do we know a failure ocurred?\n\nTo detect tat a file does not exist, inputFile.fail() will be set to true.\nTO detect an issue with reading a variable, cin.fail() or inputFile.fail() will be set to true.\nTo detect we reached the end of a file, cin.eof() and inputFile.eof() will be set to true. However, inputFile.eof() will not set the failure flag to true.\n\ncin.eof() is CTRL+D on PC and CMD+D on Mac.\n\n\n\n\n\n\nExample\n\n\n\nDetecting a failure\n// after ifstream inputFile(\"myFile.txt\"); ...\n\nif (inputFile.fail()) {\n  cerr &lt;&lt; \"Cannot open file\" &lt;&lt; endl;\n  return 1;\n}\n\n\nWhat is cerr? It is an output stream like cout. It is unbuffered unlike cout. This means that the output appears immediately on the console/terminal.\nWhy return 1? Any non-zero number signals an error.\n\n\nWhat to do when a failure with input occurs?\ncin.clear() will clear the failure condition so cin.fail() and cin.eof() are back to false.\ncin.ignore(int n, char ch) will discard n characters or up to character ch, whichever comes first."
  },
  {
    "objectID": "lecture7.html#summary",
    "href": "lecture7.html#summary",
    "title": "Lecture 7 - Sept 22, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss detecting and handling errors in the input from a file or user."
  },
  {
    "objectID": "lecture7.html#last-lecture",
    "href": "lecture7.html#last-lecture",
    "title": "Lecture 7 - Sept 22, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nFile I/O."
  },
  {
    "objectID": "lecture7.html#today",
    "href": "lecture7.html#today",
    "title": "Lecture 7 - Sept 22, 2023",
    "section": "Today",
    "text": "Today\nHandling I/O errors.\n\nHandling I/O errors\n\nInput stream if stored in a buffer.\nThis buffer is only available when \\n is entered.\ncin ignores/skips delimiters or whitespaces.\nDelimiters are , \\t, \\n.\n\n\n\n\n\n\n\nExample\n\n\n\nRemember the diagram from lecture 6.\n\n\n\nReading happens until a delimiter is seen or when something wrong happens! :::\n\n\n\n\n\n\nExample\n\n\n\n\n\ncin will read 13 into x, but it will not read ● as it is not part of an integer.\ncin will look for an int for y, but will find ●.\ncin will fail silently , y is unaffected, and the buffer is unaffected.\nA fail flag is raised, and all other cin in the program will fail.\n\nWhat should you do?\n\nCheck if the fail flag is raised.\nIf yes, handle the error.\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n// file input\n\n#include &lt;fstream&gt;\n\nint main() {\n    inputFile(\"myFile.txt\"); // error 1\n    int a,b;\n    inputFile &gt;&gt; a &gt;&gt; b; // error 2 and 3\n    return 0;\n}\n// standard input\n\n#include &lt;iostream&gt;\n\nint main() {\n    int a;\n    cin &gt;&gt; a; // error 2 and 3\n    return 0;\n}\nWhat can go wrong?\nError 1. The file to be opened for input does not exist.\nError 2. The variable cannot be read.\nError 3. Reached the end of a file.\n\n\n\n\n\n\n\n\nExample\n\n\n\nDetecting a failure\n// after ifstream inputFile(\"myFile.txt\"); ...\n\nif (inputFile.fail()) {\n    cerr &lt;&lt; \"Cannot open file\" &lt;&lt; endl;\n    return 1;\n}\n\n\nWhat is cerr? It is an output stream like cout. It is unbuffered unlike cout. This means that the output appears immediately on the console/terminal.\nWhy return 1? Any non-zero number signals an error.\n\n\nWhat to do when a failure with input occurs?\ncin.clear() will clear the failure condition so cin.fail() and cin.eof() are back to false.\ncin.ignore(int n, char ch) will discard n characters or up to character ch, whichever comes first.\n\n\n\n\n\n\nExample\n\n\n\nFor the following input, I want to ignore numbers before the space and read only the name.\n1010 Asmita\ncin.ignore(1000, ' ');\ncin &gt;&gt; name;\n\n\nWrite a program that reads a number from the user. It is not a number, prompt the user again.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added #include &lt;iostream&gt; and using namespace std here to make the code compile.\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int num = 0;\n    cout &lt;&lt; \"Enter a number:\" &lt;&lt; endl;\n    cin &gt;&gt; num;\n\n    // if cin.fail() is true,\n    // cin.ignore() will fail too\n    while(cin.fail()) {\n        // do not swtich the order\n        // we must clear first\n        cin.clear();\n        cin.ignore(1000, '\\n');\n        cout &lt;&lt; \"Try again!\" &lt;&lt; endl;\n        cin &gt;&gt; num;\n    }\n\n    cout &lt;&lt; \"The number entered is \" &lt;&lt; num;\n    \n    return 0;\n}\nWrite a program that reads numbers from a file and prints their sum. If it reads a non-integer number, ignore it. Numbers are written on separate lines.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added #include &lt;iostream&gt;, #include &lt;fstream&gt; and using namespace std here to make the code compile.\n\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n    ifstream inputFile(\"myFile.txt\");\n\n    int num = 0, sum = 0;\n\n    while(!inFile.eof()) {\n        inFile &gt;&gt; num;\n        if (inFile.fail()) {\n            inFile.clear();\n            inFile.ignore(1000, '\\n');\n        } else {\n            sum += num;\n        }\n    }\n\n    cout &lt;&lt; \"Reached end of file\" &lt;&lt; endl;\n    cout &lt;&lt; \"The sum is \" &lt;&lt; sum &lt;&lt; endl;\n    return 0;\n}"
  },
  {
    "objectID": "lecture8.html#summary",
    "href": "lecture8.html#summary",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss string streams. Then we start introducing classes."
  },
  {
    "objectID": "lecture8.html#last-lecture",
    "href": "lecture8.html#last-lecture",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nHandling I/O errors."
  },
  {
    "objectID": "lecture8.html#today",
    "href": "lecture8.html#today",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Today",
    "text": "Today\nString streams and introduce classes."
  },
  {
    "objectID": "lecture8.html#recap-on-flags",
    "href": "lecture8.html#recap-on-flags",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Recap on flags",
    "text": "Recap on flags\nRemember .eof() and .fail() flags.\nWrite a program that reads numbers from a file and prints their sum. If it reads a non-integer number, ignore it. Numbers are written on separate lines.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added #include &lt;iostream&gt;, #include &lt;fstream&gt; and using namespace std here to make the code compile. I also added an &lt;&lt; endl after cerr &lt;&lt; to avoid this in the terminal\nlecture8 (main) $ ./example1.so \nCan't open filelecture8 (main) $ \nbut to see this instead\nlecture8 (main) $ ./example1.so \nCan't open file\nlecture8 (main) $ \n\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n        ifstream inputFile(\"myFile.txt\");\n\n        if (inFile.fail()) {\n                cerr &lt;&lt; \"Can't open file\" &lt;&lt; endl;\n                return 1;\n        }\n\n        int num = 0, sum = 0;\n\n        while (!inFile.eof()) {\n                inFile &gt;&gt; num;\n\n                if (inFile.fail()) {\n                        inFile.clear();\n                        inFile.ignore(1000, '\\n');\n                } else {\n                        sum += num;\n                }\n\n        }\n\n        cout &lt;&lt; \"Reached end of file\" &lt;&lt; endl;\n        cout &lt;&lt; \"The sum is \" &lt;&lt; sum &lt;&lt; endl;\n        return 0;\n}"
  },
  {
    "objectID": "lecture8.html#string-streams",
    "href": "lecture8.html#string-streams",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "String streams",
    "text": "String streams\nString streams are helpful when inputs are line-oriented (i.e., user will enter a line and program has to check if inputs on that line are correct).\nString streams can be used to extract inputs in the line.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added #include &lt;iostream&gt; and using namespace std here to make the code compile.\n\n\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n        int ID;\n        \n        string name;\n        string inputLine = \"1001 Joe\";\n        \n        // create a string stream initialized with input line\n        stringstream myStringStream(inputLine);\n\n        myStringStream &gt;&gt; ID; // takes input into ID\n        myStringStream &gt;&gt; name; // takes input into name\n\n        cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; endl &lt;&lt; \"ID: \" &lt;&lt; ID &lt;&lt; endl;\n\n        myStringStream &lt;&lt; name &lt;&lt; ID; \n\n        // converts a string stream to a string to print it\n        cout &lt;&lt; myStringStream.str() &lt;&lt; endl;\n\n        return 0;\n}\nWhat happens if I read more out of myStringStream than there is? myStringStream.eof() will be true."
  },
  {
    "objectID": "lecture8.html#getline-function",
    "href": "lecture8.html#getline-function",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Getline function",
    "text": "Getline function\ngetline is part of iostream and it can be used to grab an entire line.\n...\n\nstring inputLine;\n\n// entire line entered by user gets stored in inputLine\ngetline(cin, inputLine);\n\nstringstream myStringStream(inputLine);\n\nmyStream &gt;&gt; ID;\nmyStream &gt;&gt; name;\n\n...\nLab 3 will use string streams."
  },
  {
    "objectID": "lecture8.html#introduction-to-classes",
    "href": "lecture8.html#introduction-to-classes",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Introduction to classes",
    "text": "Introduction to classes\nA class is a user defined data type.\nA variable of that user-defined data type is called an object.\nDeclaring an object is called creating an instance or instantiation.\n\n\n\n\n\n\n\nExample\n\n\n\nRecall structs in C.\nThis is a data structure that stores data of different types using one variable name.\nstruct Student {\n        string name;\n        int ID;\n}\n\nstruct Student x;\n\n// access name of x using . operator\nx.name = \"Cindy\";\n\n\nThe definition of a class goes to a header file (e.g. Student.h)\n\nStudent.h\nclass Student {\n        private:\n                int ID;\n                string name;\n\n        public:\n                void setName(string name);\n                void getName();\n                void print();\n};\nThis needs a diagram to explain the different parts.\n\nprivate members can only be accessed within the class.\npublic members can be accessed outside the class.\nWhy? This is called encapsulation\n\nHide information related to the class (e.g., student ID).\nIt is not available outside the class.\nIt brings related data and functions together.\nIt organizes the code."
  },
  {
    "objectID": "lecture8.html#class-implementation",
    "href": "lecture8.html#class-implementation",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Class implementation",
    "text": "Class implementation\nThe class implementation goes in a source file and it has function definitions.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added endl after the cout statements for the same reason as above.\nI also think that Student.cpp starts with #include \"Student.h\" instead of #include \"Student.cpp\" - EMAIL SENT, WAITING FOR CONFIRMATION\n\n\n\nStudent.cpp\n#include \"Student.h\"\n#include &lt;iostream&gt;\n\n// Setter or mutator function\n\n// class name: Student\n// scope operator: ::\n// function name: setName\nvoid Student::setName(string n) {\n        // private member of Student class can be accessed\n        // inside the class implementation\n        name = n;\n}\n\n// Getter or accessor function\n\nstring Student::getName() {\n        return name;\n}\n\nvoid Student::print() {\n        cout &lt;&lt; \"Student name: \" &lt;&lt; name &lt;&lt; endl;\n        cout &lt;&lt; \"Student ID: \" &lt;&lt; ID &lt;&lt; endl;\n}\n\n\nmain.cpp\nInstatiating and using objects here.\n#include \"Student.h\"\n\nint main() {\n        // declare 2 objects and allocate memory for them\n        Student x,y;\n\n        x.setName(\"Kenya\");\n        y.setName(\"Christina\");\n\n        // x.ID = 2730; gives an error because we cannot access a private member\n\n        // y.name = \"Salma\" same error\n\n        y.print(); // wait! what is the value of ID in Student y?\n\n        return 0;\n}\nID in x and y are not initialized. The solution is defining constructors in the next lecture."
  },
  {
    "objectID": "index.html#why-hiram",
    "href": "index.html#why-hiram",
    "title": "Hiram: ECE244 Tidy Notes",
    "section": "Why Hiram?",
    "text": "Why Hiram?\nHiram was an arquitect from Tyre (Lebanon), one of the finest back in the day, and who learned how to work the stone from a long tradition of stonecutters’ unions created by skilled workers and led by craftmasters from Egypt.\nBecause Professor Emara titled her notes Snefru and Khufu (C and C++, respectively), I am not the same height to have used Solomon (Hiram’s boss) as the name of these notes. Also, I am like Hiram, and in this class I am learning from a craftmaster from Egypt."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Hiram: ECE244 Tidy Notes",
    "section": "Introduction",
    "text": "Introduction\n\nWhy Hiram?\nHiram was an arquitect from Tyre (Lebanon), one of the finest back in the day, and who learned how to work the stone from a long tradition of stonecutters’ unions created by skilled workers and led by craftmasters from Egypt.\nBecause Professor Emara titled her notes Snefru and Khufu (C and C++, respectively), I am not at the same height to have used Solomon (Hiram’s boss) as the name of these notes. Also, I am like Hiram, and in this class I am learning from a craftmaster from Egypt.\n\n\nAbout ECE244 - Programming Fundamentals\nThis course provides a foundation in programming using an object-oriented programming language. Topics include classes and objects, inheritance, basic data structures (lists, tree, hash tables, etc.), Big-O complexity analysis, and testing and debugging. The laboratory assignments emphasize the use of object-oriented programming constructs in the design and implementation of reasonably large programs.\n\n\nPacha’s notes\n\nThe notes are 100% adjusted to the class.\nIn the snippets folder, I have included some (unofficial) code snippets with the same examples from the notes, that I use to check if the code compiles.\nSome of the examples in the notes have small additions, such as using namespace std; or #include &lt;iostream&gt;, to make them compile.\nThe diagrams are kinda ugly, my apologies! I’m not a graphic designer."
  },
  {
    "objectID": "lecture9.html#summary",
    "href": "lecture9.html#summary",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we introduce classes, access controls: private and public, and initializing data members problem."
  },
  {
    "objectID": "lecture9.html#last-lecture",
    "href": "lecture9.html#last-lecture",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nUsing .fail() and .eof() flags."
  },
  {
    "objectID": "lecture9.html#today",
    "href": "lecture9.html#today",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Today",
    "text": "Today\nIntroduction to classes."
  },
  {
    "objectID": "lecture9.html#demo-of-stringstreams",
    "href": "lecture9.html#demo-of-stringstreams",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Demo of stringstreams",
    "text": "Demo of stringstreams\nAvoid using stream for reading and writing interchangeably. You can write and then read, but it gets confusing when you write again.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added include&lt;iostream&gt; to make cin work. I also changed cout &lt;&lt; ss str(); from the notes to cout &lt;&lt; ss.str();, or it will not compile.\nI also added endl after cout for the same reason as in lecture 8.\n\n\n\n\n\n\n\n\nExample\n\n\n\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int ID;\n    string name, inputLine;\n    getline (cin, inputLine);\n\n    stringstream ss;\n    // write into ss\n    ss &lt;&lt; inputLine;\n\n    // or stringstream ss(inputLine);\n\n    // read from ss\n    ss &gt;&gt; ID; // ID reads 1001\n    ss &gt;&gt; name; // name reads Joe\n\n    cout &lt;&lt; ss.str() &lt;&lt; endl; // ss still has content written to it \"1001 Joe\"\n\n    return 0;\n}\nWhen the user enters “1001 Joe”, what is in ss remains there. Only the reading cursor moves."
  },
  {
    "objectID": "lecture9.html#introduction-to-clases",
    "href": "lecture9.html#introduction-to-clases",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Introduction to clases",
    "text": "Introduction to clases\nRecall structs in C\n\n\n\n\n\n\nExample\n\n\n\nRecall structs in C.\nThis is a data structure that stores data of different types using one variable name.\nstruct Student {\n    string name;\n    int ID;\n}\n\nstruct Student x;\n\n// access name of x using . operator\nx.name = \"Cindy\";\n\n\nA class is an expansion to structs by bringing together data and functions/operations.\nConsider that:\n\nData is similar to structs.\nFunctions/operations are different from structs.\n\nA class is a user-defined data type. A variable of that user-defined data type is called an object.\nDeclaring an object is called creating an instance or instantiation.\nRemember the diagram from lecture 8.\n\nThe definition of a class goes to a header file (e.g. Student.h).\n\nStudent.h\nclass Student {\n    private:\n        int ID;\n        string name;\n\n    public:\n        void setName(string name);\n        void getName();\n        void print();\n};\nRemember the diagram from lecture 8.\n\nprivate members can only be accessed within the class.\npublic members can be accessed outside the class.\nWhy? This is called encapsulation\n\nHide information related to the class (e.g., student ID).\nIt is not available outside the class.\nIt brings related data and functions together.\nIt organizes the code."
  },
  {
    "objectID": "lecture9.html#class-implementation",
    "href": "lecture9.html#class-implementation",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Class implementation",
    "text": "Class implementation\nThe class implementation goes in a source file and it has function definitions.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added endl after the cout statements for the same reason as above.\nI also think that Student.cpp starts with #include \"Student.h\" instead of #include \"Student.cpp\" - EMAIL SENT, WAITING FOR CONFIRMATION\n\n\n\nStudent.cpp\n#include \"Student.h\"\n#include &lt;iostream&gt;\n\n// Setter or mutator function\n\n// class name: Student\n// scope operator: ::\n// function name: setName\nvoid Student::setName(string n) {\n    // private member of Student class can be accessed\n    // inside the class implementation\n    name = n;\n}\n\n// Getter or accessor function\n\nstring Student::getName() {\n    return name;\n}\n\nvoid Student::print() {\n    cout &lt;&lt; \"Student name: \" &lt;&lt; name &lt;&lt; endl;\n    cout &lt;&lt; \"Student ID: \" &lt;&lt; ID &lt;&lt; endl;\n}\n\n\nmain.cpp\nInstatiating and using objects here.\n#include \"Student.h\"\n\nint main() {\n    // declare 2 objects and allocate memory for them\n    Student x,y;\n\n    x.setName(\"Kenya\");\n    y.setName(\"Christina\");\n\n    // x.ID = 2730; gives an error because we cannot access a private member\n\n    // y.name = \"Salma\" same error\n\n    y.print(); // wait! what is the value of ID in Student y?\n\n    return 0;\n}\nIn the line that reads Student x,y, ID in x and y are not initialized.\nThe solution is to define a constructor.\n\n\nStudent.h\nclass Student {\n    private:\n        int ID;\n        string name;\n    \n    public:\n        Student(); // constructor\n        void setName(string name);\n        ...\n}"
  },
  {
    "objectID": "lecture10.html#summary",
    "href": "lecture10.html#summary",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss how can we initialize data members at the time of instantiating an object using constructors. We also introduce, if we have a dynamically allocated memory, how do we free it when an object goes out of scope."
  },
  {
    "objectID": "lecture10.html#last-lecture",
    "href": "lecture10.html#last-lecture",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nIntroduction to classes."
  },
  {
    "objectID": "lecture10.html#today",
    "href": "lecture10.html#today",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Today",
    "text": "Today\nConstructors and destructors."
  },
  {
    "objectID": "lecture10.html#constructors",
    "href": "lecture10.html#constructors",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Constructors",
    "text": "Constructors\n\nConstructors are called by default when an object is instantiated.\nIf you do not implement them, they are empty functions.\nYou cannot call a constructor explicitly. It is only called when you instatiate an object.\nIt’s name is the same as the class name.\nIt has no return or even return type (not void).\n\n\n\n\n\n\n\nExample\n\n\n\n\nStudent.h\nclass Student {\n    private:\n        int ID;\n        string name;\n    public:\n        Student(); // constructor\n        void setName(string n); // setter / mutator\n        string getName(); // getter  accessor\n        void print();\n}\n\n\nStudent.cpp\nStudent::Student() {\n    /// typically used to initialize data members of a class\n    ID = 0;\n    name = \"\";\n}\n\n\nmain.cpp\nint main() {\n    Student x; // calls the constructor\n    Student y[10]; // calls the constructor 10 times\n    Student* z; // no constructor called, no object is instatiated\n}\n\n\n\nWhat if I want to initialize ID with a specific value? We can have multiple constructors/\n\n\n\n\n\n\nExample\n\n\n\n\nStudent.h\nclass Student {\n    private:\n        int ID;\n        string name;\n    public:\n        // multiple constructors\n        // same function name\n        // different arguments\n        // this is called function overloading\n        Student(); // constructor\n        Student(int id);\n        Student(int id, string name);\n        ...\n}\n\n\nStudent.cpp\nStudent::Student() {\n    ID = 0; name = \"\";\n}\n\nStudent::Student(int id) {\n    ID = id; name = \"\";\n}\n\nStudent::Student(int id, string n) {\n    ID = id; name = n;\n}\n\n\nmain.cpp\nStudent x; // default constructor\nStudent y(2307); // second constructor\nStudent z(8731, \"Osiris\"); // third constructor\n\n\n\nThe respective constructors are called depending on the arguments.\nVery important: If the default constructor Student() is not implemented, but Student(int) is implemented, then Student x; will cause an error, as it will call Student() that is not defined.\nWhat if I dynamically allocate memory in an object?\n\nMemory allocated on the heap dynamically has to be explicitly freed. It does not get freed when a variable goes out of scope.\n\n\n\n\n\n\nExample\n\n\n\nfor (int i=0; i &lt; 3; i++) {\n    cout &lt;&lt; i;\n}\nOutside the loop, i does not exist.\n\n\nRecall that in C, for every malloc there has to be a free.\nIn C++, we have new and delete.\n\n\n\n\n\n\nExample\n\n\n\n\nInteger\n// return address of an int variable created at run-time\nint* pNum = new int;\n\n// de-allocate memory at pNum\ndelete pNum;\n\n\nArray\nint* arr = new int[10];\ndelete[] arr;\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nclass Student {\n    private:\n        int* grades;\n    public:\n        Student();\n        Student(int);\n};\n\nStudent::Student() {\n    grades = nullptr;\n}\n\nStudent::Student(int numLabs) {\n    grades = new int[numLabs];\n}\n\nint main() {\n    // dynamically allocates 7 integers\n    // if we do not de-allocate, this creates a memory leak\n    Student x(7);\n}"
  },
  {
    "objectID": "lecture10.html#destructors",
    "href": "lecture10.html#destructors",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Destructors",
    "text": "Destructors\nTo solve memory leaks as in the previous example, we can use destructors.\n\n\n\n\n\n\nExample\n\n\n\nclass Student {\n    private:\n        int* grades;\n    public:\n        Student();\n        Student(int);\n        // destructors must be public\n        // a destructor has no return, like constructors\n        // also it has no parameters\n        ~Student();\n};\n\n...\n\nStudent::~Student() {\n    if (grades != nullptr) {\n        delete[] grades;\n    }\n}\n\n\nThe default destructor exists by default, and is called when the object goes out of scope.\nIf you dynamically allocate memory in your class, you will need a destructor to free up this memory space."
  },
  {
    "objectID": "lecture11.html#summary",
    "href": "lecture11.html#summary",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss pointers and introduce if we have a dynamically allocated memory in an object, how do we free it when an object goes out of scope."
  },
  {
    "objectID": "lecture11.html#last-lecture",
    "href": "lecture11.html#last-lecture",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nConstructors."
  },
  {
    "objectID": "lecture11.html#today",
    "href": "lecture11.html#today",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Today",
    "text": "Today\nDestructors, pointers and objects with pointers."
  },
  {
    "objectID": "lecture11.html#memory",
    "href": "lecture11.html#memory",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Memory",
    "text": "Memory\nMemory is divided into cells. Each cell can store a byte of data (8 bits) and has an address.\nA program’s memory space.\n\nA pointer is a variable that stores and address to a byte.\nMemory on stack gets freed when a function returns. All local variables in a function dissappear when the function returns or when they go out of scope.\nBut memory allocated on the heap dynamically has to be explicitly freed. It does not get freed when a variable goes outo f scope. It creates a memory leak if we do not free it.\n\n\n\n\n\n\nExample\n\n\n\nint x;\nint *p;\nx = 7;\np = NULL;\np = &x // address of x\n\ncout &lt;&lt; *p;; // print 7\n\n// dereference p / value at address in p\ncout &lt;&lt; p; // prints 0x124\n\n*p = 5; // change the value of p to 5\n\np = new int; // change address stored in p to a newely allocated memory space\n\n*p = 3; // change value at address 0x560\n\n...\n\n// before exiting our program, we need to return dynamically allocated memory\n// to the operating system\n\ndelete p; // p now has address of expired data\n\np = nullptr; // good practice\n\n\n\nRecall that in C, for every malloc there has to be a free. In C++, we have new add and delete.\n\n\n\n\n\n\nExample\n\n\n\n\nInteger\n// return address of an int variable created at run-time\nint* pNum = new int;\n\n// de-allocate memory at pNum\ndelete pNum;\n\n\nArray\nint* arr = new int[10];\ndelete[] arr;\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nWith a class\nclass Student {\n    private:\n        int *grades; string name;\n    public:\n        Student();\n        Student(int);\n};\n\nStudent::Student() {\n    grades = nullptr;\n}\n\nStudent::Student(int numLabs) {\n    grades = new int[numLabs];\n}\n\nint main() {\n    // dynamically allocates 3 integers\n    Student x(3);\n    return 0;\n\n    // we did not deallocate them\n    // this will create a memory leak!\n}\n\n\n\nThe solution is to define destructors.\nclass Student {\n    private:\n        int *grades; string name;\n    public:\n        Student();\n        Student(int);\n        // the destructor must be public\n        ~Student(); // no return, like constructors\n                    // no parameters\n};\n\n...\n\nStudent::~Student() {\n    if (grades != nullptr) {\n        delete[] grades;\n    }\n}\nThe default destructor exists by default, and is called when the object goes out of scope.\nIf you dynamically allocate memory in your class, you will need a destructor to free up this memory space.\n\nmain.cpp\nint main() {\n    Student x(3); // dynamically allocates 3 integers\n\n    return 0; // destructor of x will be called if grades is !nullptr\n              // we will free dynamically allocated space \n}"
  },
  {
    "objectID": "lecture11.html#exercise-on-double-pointers",
    "href": "lecture11.html#exercise-on-double-pointers",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Exercise on double pointers",
    "text": "Exercise on double pointers\nDouble pointers (i.e., pointers to pointers) are variables that store an address too. That address is an address of a pointer.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added the header and put the original example inside main() with an added return 0; at the end, otherwise it would not compile.\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  int** p2p;\n  int *p, *q;\n\n  p = new int;\n  *p = 5;\n\n  p2p = &p;\n  q = *p2p;  // *(&p) = p\n\n  *q = 8;  // the new int\n\n  cout &lt;&lt; **&p2p;  // **(&p) = *p = the new int, prints 8\n\n  return 0;\n}"
  },
  {
    "objectID": "lecture12.html#summary",
    "href": "lecture12.html#summary",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss pointers in objects, destructors and when we need them."
  },
  {
    "objectID": "lecture12.html#last-lecture",
    "href": "lecture12.html#last-lecture",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nMemory organization: stack and heap, pointers, and dynamic memory allocation."
  },
  {
    "objectID": "lecture12.html#today",
    "href": "lecture12.html#today",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Today",
    "text": "Today\nDestructors and pointers in objects."
  },
  {
    "objectID": "lecture12.html#dynamically-allocated-memory",
    "href": "lecture12.html#dynamically-allocated-memory",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Dynamically allocated memory",
    "text": "Dynamically allocated memory\nThe problem when if we dynamically allocate memory in a class is to have a memory leak.\n\n\n\n\n\n\nExample\n\n\n\nclass Student {\n    private:\n        int *grades; string name;\n    public:\n        Student();\n        Student(int);\n};\n\nStudent::Student() {\n    grades = nullptr;\n}\n\nStudent::Student(int numLabs) {\n    grades = new int[numLabs];\n}\n\nint main() {\n    // dynamically allocates 3 integers\n    Student x(3);\n    return 0;\n\n    // we did not deallocate them\n    // this will create a memory leak!\n}\n\n\n\nThe solution is in defining destructors.\n\n\n\n\n\n\nExample\n\n\n\nclass Student {\n    :\n        int *grades; string name;\n    public:\n        Student();\n        Student(iprivatent);\n        // the destructor must be public\n        ~Student(); // no return, like constructors\n                    // no parameters\n};\n\n...\n\nStudent::~Student() {\n    if (grades != nullptr) {\n        delete[] grades;\n    }\n}\n\n\nThe default destructor exists by default, and is called when the object goes out of scope.\nIf you dynamically allocate memory in your class, you will need a destructor to free up this memory space.\n\n\n\n\n\n\nExample\n\n\n\n// main.cpp\n\nint main() {\n    Student x(3);\n    return 0;\n}\nThe destructor of x will be called by default at the end of main. If grades is !nullptr, we will free dynamically allocated space."
  },
  {
    "objectID": "lecture12.html#pointers-to-objects",
    "href": "lecture12.html#pointers-to-objects",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Pointers to objects",
    "text": "Pointers to objects\nCan pointers point to objects? Yes!\n\n\n\n\n\n\nExample\n\n\n\nUse case to dynamically allocate memory for an object on the heap.\nclass ComplexNum {\n    double real;\n    double img;\n    ComplexNum(double r, double i) { real = r; img = i; }\n};\n\nint main() {\n    ComplexNum, x(3,4);\n    x.real = 2;\n    ComplexNum *p;\n    p = &x;\n\n    // -&gt;: access member at address stored in p\n    p-&gt;real = 7;\n\n    // or  de-reference p then use .\n    // (*p).real = 7;\n}"
  },
  {
    "objectID": "lecture12.html#pointers-to-objects-in-objects",
    "href": "lecture12.html#pointers-to-objects-in-objects",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Pointers to objects in objects",
    "text": "Pointers to objects in objects\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added return 0; to the main function, otherwise it would not compile.\n\n\nclass ComplexNum {\n public:\n  double real;\n  double img;\n  ComplexNum* next;\n\n  ComplexNum() {\n    real = 0;\n    img = 0;\n    next = nullptr;\n  }\n\n  ~ComplexNum() {\n    if (next != nullptr) delete next;\n  }\n};\n\nint main() {\n    ComplexNum* px = new ComplexNum; // 1\n  px-&gt;next = new ComplexNum; // 2\n  px-&gt;next-&gt;real = 8; // 3\n  delete px; // calls the destructor\n             // frees up memory that p is pointing to\n  return 0;\n}\n\nWhat about next in p?\n\ndelete px calls destructor on A.\nThen delete next of A, which is B.\nThen calls destructor on B , next is null."
  },
  {
    "objectID": "lecture8.html#ungraded-homework",
    "href": "lecture8.html#ungraded-homework",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Ungraded homework",
    "text": "Ungraded homework\nSolve the exercises of Chapter 2: C++ I/O\n\n\n\n\n\n\nExercise 1\n\n\n\nQuestion 5 in Fall 2022 Midterm Exam [Easy]\nConsider the following program.\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a;\n    ifstream inFile;\n    inFile.open(\"input.txt\");\n    if (inFile.fail()) {\n        return 1;\n    }\n    while (1) {\n        inFile &gt;&gt; a;\n        if (inFile.fail()) {\n            cout &lt;&lt; \"failed..\" &lt;&lt; endl;\n            inFile.clear();\n            inFile.ignore(100, '\\n');\n            continue;\n        }\n        cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n        break;\n    }\n    return 0;\n}\nGiven the following contents of “input.txt”, write the output.\nCase 1:\n1\n2\n3\nCase 2:\na32\nb86\n3\nCase 3:\na32\nb86 3\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nCase 1\na = 1\nExplanation:\n\nThe while (1) loop is an infinite loop that will continue until it’s explicitly broken.\nIf the file reading operation is successful, the program outputs the value of a to the console and then breaks out of the loop with break;.\n\nCase 2\nfailed..\nfailed..\na = 3\nExplanation:\n\nThe while(1) loop will continue until it’s explicitly broken.\nThe first two cases fail, because the program read a non-integer value.\n\nCase 3\nfailed..\nfailed..\n...\ninfinite output\nExplanation:\n\nThe while(1) loop will continue until it’s explicitly broken.\nIt fails for the first two lines and then the loop continues.\n\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nNow you remove the infile.clear() from the code, so the program becomes:\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a;\n    ifstream inFile;\n    inFile.open(\"input.txt\");\n    if (inFile.fail()) {\n        return 1;\n    }\n    while (1) {\n        inFile &gt;&gt; a;\n        if (inFile.fail()) {\n            cout &lt;&lt; \"failed..\" &lt;&lt; endl;\n            // inFile.clear(); // COMMENTED OUT\n            inFile.ignore(100, '\\n');\n            continue;\n        }\n        cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n        break;\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nCase 1\na = 1\nCase 2\nfailed..\nfailed..\n...\ninfinite output\nExplanation:\n\nThe input stream is not cleared, so the program will continue to read the same non-integer value.\n\nCase 3\nfailed..\nfailed..\n...\ninfinite output\nExplanation:\n\nSame as case 2.\n\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nQuestion 2 in Fall 2021 Final Exam [Intermediate]\nWrite a C++ function void readInts() that repeatedly reads integers from the standard input (using cin) and then immediately outputs the input integer (using cout), one integer per line. When a '.' character is encountered, the function prints the message Done on a line by itself and returns. If the user enters any characters other than integer digits or the '.', the function prints the message Error on a line by itself and returns. You may assume the user will never enter eof.\nThus, for example, if the user enters 51 16 700 ., the function prints:\n51\n16\n700\nDone\nHowever, if the user enters 101 21 13 abc 444, the function prints:\n101\n21\n13\nError\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nvoid readInts() {\n        int num;\n        cin &gt;&gt; num;\n\n        while (!cin.fail()) {\n                cout &lt;&lt; num &lt;&lt; endl;\n                cin &gt;&gt; num;\n        }\n\n        cin.clear();\n\n        string chr;\n        cin &gt;&gt; chr;\n\n        if (chr == \".\") {\n                cout &lt;&lt; \"Done\" &lt;&lt; endl;\n        } else {\n            cout &lt;&lt; \"Error\" &lt;&lt; endl;\n        }\n}\n\nint main() {\n        readInts();\n        return 0;\n}\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nQuestion 3 in Fall 2018 Midterm Exam [Intermediate]\nConsider the following program that uses stringstreams to read a command. The command has the following format:\ncount intArg\nThe command word is count and intArg is an integer argument. The command must have only one integer argument, e.g count 3.\nThe function handle_count performs the reading of the integer value. If the integer is valid, it returns true and updates the value of intArg. Otherwise, it returns false.\n#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n// function prototype\nbool handle_count( &lt;fill in the blank&gt; );\n\nint main() {\n    string line;\n    string command;\n    int intArg;\n    getline(cin, line);\n    stringstream lineStream(line);\n    lineStream &gt;&gt; command;\n    if (command == \"count\") {\n        if (handle_count( &lt;fill in the blank&gt; )) {\n            cout &lt;&lt; \"Integer argument is \" &lt;&lt; intArg &lt;&lt; endl;\n            return (0);\n        } else {\n            cout &lt;&lt; \"Invalid arguments\" &lt;&lt; endl;\n            return (-1);\n        }\n    } else {\n        cout &lt;&lt; \"Invalid command\" &lt;&lt; endl;\n        return (-1);\n    }\n}\n\nDetermine the number of arguments and the type of each argument and indicate them in the code above in the prototype of the function, handle_count. Further, indicate what parameters are passed to the function when it is invoked. Write your answers where indicated in the code above. You may not modify main by adding or removing line, other than by indicating the formal arguments in the function prototype and actual arguments of the function invocation.\nWrite the header and body of the handle_count function below so it performs as indicated above.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPart 1\nWe need two arguments, a stringstream (lineStream) and an int (intArg).\n#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n// function prototype\nbool handle_count(stringstream& lineStream, int& intArg);\n\nint main() {\n    string line;\n    string command;\n    int intArg;\n    getline(cin, line);\n    stringstream lineStream(line);\n    lineStream &gt;&gt; command;\n    if (command == \"count\") {\n        if (handle_count(lineStream, intArg)) {\n            cout &lt;&lt; \"Integer argument is \" &lt;&lt; intArg &lt;&lt; endl;\n            return (0);\n        } else {\n            cout &lt;&lt; \"Invalid arguments\" &lt;&lt; endl;\n            return (-1);\n        }\n    } else {\n        cout &lt;&lt; \"Invalid command\" &lt;&lt; endl;\n        return (-1);\n    }\n}\nPart 2\n#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n// function prototype\nbool handle_count(stringstream& lineStream, int& intArg);\n\nint main() {\n    string line;\n    string command;\n    int intArg;\n    getline(cin, line);\n    stringstream lineStream(line);\n    lineStream &gt;&gt; command;\n    if (command == \"count\") {\n        if (handle_count(lineStream, intArg)) {\n            cout &lt;&lt; \"Integer argument is \" &lt;&lt; intArg &lt;&lt; endl;\n            return (0);\n        } else {\n            cout &lt;&lt; \"Invalid arguments\" &lt;&lt; endl;\n            return (-1);\n        }\n    } else {\n        cout &lt;&lt; \"Invalid command\" &lt;&lt; endl;\n        return (-1);\n    }\n}\n\nbool handle_count(stringstream& line, int& intArg) {\n    line &gt;&gt; intArg;\n\n    if (line.fail()) {\n        return false;\n    }\n\n    string dummy;\n    line &gt;&gt; dummy;\n\n    if (line.fail()) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n\n\n\n\n\n\n\nExercise 5\n\n\n\nQuestion 6 in Fall 2019 Midterm Exam [Intermediate]\nFor each of the following main functions, indicate the output produced in response to the user entering 1 2 3 4 five on the keyboard followed by the Enter key. Choose only one answer.\nPart 1\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int num = 0;\n    int sum = 0;\n    while (!cin.fail()) {\n        cin &gt;&gt; num;\n        sum = sum + num;\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n    return (0);\n}\n\n6\n10\n14\nNone; the program runs in an infinite loop\n\nPart 2\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int num = 0;\n    int sum = 0;\n    bool more = true;\n    while (more) {\n        cin &gt;&gt; num;\n        if (cin.fail())\n            more = false;\n        else\n            sum = sum + num;\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n    return (0);\n}\n\n6\n10\n14\nNone; the program runs in an infinite loop\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPart 1\nResult: 10 or 14. In some compilers num will be unchanged and will be added to the sum again.\nPart 2\nResult: 10. more will be set to false after the first non-integer input.\n\n\n\n\n\n\n\n\n\nExercise 6\n\n\n\nQuestion 7 in Fall 2019 Midterm Exam [Intermediate]\nWrite a C++ function void readInts() that repeatedly reads integers from the standard input (using cin) and then immediately outputs the input integer (using cout), one integer per line.\nWhen the end-of-file is reached, the function prints the message “End of File Reached” on a line by itself before returning. If a non-integer is input the function should print the message “Invalid Input” on a line by itself, should discard the rest of the stream and should continue reading integers again until the end-of-file is reached.\n\n\n::: {.callout-note icon=false collapse=“true”} ## Solution\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid readInts() {\n    // pass number from cin\n    int num;\n    cin &gt;&gt; num;\n\n    // print until end of file\n    while (!cin.eof()) {\n        if (cin.fail()) {\n            cin.clear();\n            cin.ignore(1000, '\\n');\n            cout &lt;&lt; \"Invalid Input\" &lt;&lt; endl;\n            cin &gt;&gt; num;\n        } else {\n            cout &lt;&lt; num &lt;&lt; endl;\n            cin &gt;&gt; num;\n        }\n    }\n    cout &lt;&lt; \"End of File Reached\" &lt;&lt; endl;\n}\n\nint main() {\n    readInts();\n    return 0;\n}"
  },
  {
    "objectID": "lecture13.html#summary",
    "href": "lecture13.html#summary",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss dynamic memory allocation of arrays (of objects and of pointers to objects)."
  },
  {
    "objectID": "lecture13.html#last-lecture",
    "href": "lecture13.html#last-lecture",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nDestructors."
  },
  {
    "objectID": "lecture13.html#today",
    "href": "lecture13.html#today",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Today",
    "text": "Today\nDynamic memory allocation of arrays of objects and pointers to objects."
  },
  {
    "objectID": "lecture13.html#double-pointers",
    "href": "lecture13.html#double-pointers",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Double pointers",
    "text": "Double pointers\nDouble pointers are variables that store an address to a pointer.\n\n\n\n\n\n\nExample\n\n\n\nint** p2p;\nint *p, *q;\n\np = new int;\n*p = 5;\np2p = &p;\nq = *p2p; // *(&p) = p\n*q = 8; // the new int\n\ncout &lt;&lt; **p2p &lt;&lt; endl; // **(&p) = *p = the new int = 8\n\ndelete p; // frees up space pointed to by p\ndelete q; // double free\ndelete *p2p; // triple free\nRemember the diagram from lecture 11."
  },
  {
    "objectID": "lecture13.html#dynamic-memory-allocation-of-arrays",
    "href": "lecture13.html#dynamic-memory-allocation-of-arrays",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Dynamic memory allocation of arrays",
    "text": "Dynamic memory allocation of arrays\n\nint a[4] = {1,2,3,4}\na is an alias/nickname that has address to the first element in the array.\na      &lt;-&gt; &a[0]\n*a     &lt;-&gt; a[0\n*(a+1) &lt;-&gt; a[1]\nThere are different ways to have an array that stores data.\n\nFixed-size array\nint arr[4]; // fixed number\nThis will be allocated on the stack.\n\n\nVariable-size array\nint size;\ncin &gt;&gt; size;\nint arr[size]; // variable number\nThis will be allocated on the stack too.\n\n\nDynamically allocate memory for the array\nint size = 7;\nint* arr = new int[size]; // dynamically allocate memory\nThis array will be allocated on the heap.\nAdvice: The programmer can “control” the lifetime of the array in the memory by freeing the memory anytime with delete.\n\n\n\n\n\n\nExample\n\n\n\ndelete [] arr;\narr = NULL;\n\n\nCan we dynamically allocate an array of pointers to integers? Yes.\n\nint** arr2p = new int*[4];\n\nfor (int i = 0; i &lt; 4; i++) {\n    arr2p[i] = new int;\n}\n\nfor (int i = 0; i &lt; 4; i++) {\n    *arr2p[i] = i + 1;\n}\n\nfor (int i = 0; i &lt; 4; i++) {\n    delete arr2p[i];\n    arr2p[i] = NULL;\n}\n\ndelete [] arr2p;\narr2p = NULL; // arr2p -&gt; NULL\nCan we dynamically allocate an array of objects? Yes.\nclass Student {\n    public:\n        string name;\n        int ID;\n        Student() { ID = 0; name = \"\"; }\n        ~Student() { cout &lt;&lt; \"Destructor\" &lt;&lt; endl; }\n}\n\nint main() {\n    // Default constructor called 3 times\n    Student* arr = new Student[3];\n    \n    // Destructor called 3 times\n    // no destructor will be called without delete\n    delete [] arr;\n    arr = NULL;\n\n    return 0;\n}\nCan I have an array of pointers to objects? Yes\n\nint main() {\n    // no constructors called\n    Student** arr2p = new Student*[3];\n\n...\n\n...\n\n    for (int i = 0; i &lt; 3; i++) {\n        arr2p[i] = new Student;\n    }\n\n...\n\n...\n\n    for (int i = 0; i &lt; 3; i++) { \n        arr2p[i]-&gt;ID = i + 1;\n    }\n...\n\n...\n\n    for (int i = 0; i &lt; 3; i++) { \n        delete arr2p[i];\n    }\n\n...\n\n...\n\n    delete [] arr2p;\n    arr2p = NULL;\n}"
  },
  {
    "objectID": "lecture13.html#recap-on-memory-management-issues",
    "href": "lecture13.html#recap-on-memory-management-issues",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Recap on Memory Management Issues",
    "text": "Recap on Memory Management Issues\n\nLosing access to a dynamically allocated space\nint *p = new int;\n*p = 100;\np = new int; // memory leak\n\nSolution: Have a delete before making p point to a new memory space.\nint *p = new int;\n*p = 100;\ndelete p;\np = new int;\n\n\nAccess a freed memory space\nint *p = new int;\n*p = 100;\ndelete p;\n*p = 3; // challenging to debug\nSolution: It is a good practice to set the pointer to NULL or nullptr after delete.\n\n\nDereference an undefined pointer\nint *p;\nint y;\ny = *p; // p has garbage address\n                // defeferencing will access a garbage address\n\n\nDouble free\nint *p = new int;\ndelete p;\n...\ndelete p; // double free\n\n\nDelete a variable stored on the stack\nint x = 4;\nint *p;\np = &x;\ndelete p; // x is on stack, you can't delete it\n\n\nType mismatch assignment\nint** &lt;- int*,\nint* &lt;- int**,\nint** &lt;- int,\nint* &lt;- int\nint *p, *q;\nint **pp;\n\n// pp: int**\n// p: int*\npp = p; // type mismatch int** &lt;- int*\n\n// *p: p\npp = *p; // type mismatch int** &lt;- int\n\np = pp; // type mismatch int* &lt;- int**"
  },
  {
    "objectID": "lecture13.html#read-at-home-recap-on-memory-management-issues",
    "href": "lecture13.html#read-at-home-recap-on-memory-management-issues",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Read at home: Recap on Memory Management Issues",
    "text": "Read at home: Recap on Memory Management Issues\n\nLosing access to a dynamically allocated space\nint *p = new int;\n*p = 100;\np = new int; // memory leak\n\nSolution: Have a delete before making p point to a new memory space.\nint *p = new int;\n*p = 100;\ndelete p;\np = new int;\n\n\nAccess a freed memory space\nint *p = new int;\n*p = 100;\ndelete p;\n*p = 3; // challenging to debug\nSolution: It is a good practice to set the pointer to NULL or nullptr after delete.\n\n\nDereference an undefined pointer\nint *p;\nint y;\ny = *p; // p has garbage address\n                // defeferencing will access a garbage address\n\n\nDouble free\nint *p = new int;\ndelete p;\n...\ndelete p; // double free\n\n\nDelete a variable stored on the stack\nint x = 4;\nint *p;\np = &x;\ndelete p; // x is on stack, you can't delete it\n\n\nType mismatch assignment\nint** &lt;- int*,\nint* &lt;- int**,\nint** &lt;- int,\nint* &lt;- int\nint *p, *q;\nint **pp;\n\n// pp: int**\n// p: int*\npp = p; // type mismatch int** &lt;- int*\n\n// *p: p\npp = *p; // type mismatch int** &lt;- int\n\np = pp; // type mismatch int* &lt;- int**"
  },
  {
    "objectID": "lecture14.html#summary",
    "href": "lecture14.html#summary",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we continue on our discussion of dynamic memory allocation of arrays of objects. We also introduce the concept of operator overloading."
  },
  {
    "objectID": "lecture14.html#last-lecture",
    "href": "lecture14.html#last-lecture",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nDynamic memory allocation of arrays."
  },
  {
    "objectID": "lecture14.html#today",
    "href": "lecture14.html#today",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Today",
    "text": "Today\nContinue dynamic memory allocation of objects and operator overloading."
  },
  {
    "objectID": "lecture14.html#dynamic-allocation",
    "href": "lecture14.html#dynamic-allocation",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Dynamic allocation",
    "text": "Dynamic allocation\nCan we dynamically allocate an array of objects? Yes\nclass Student {\n    public:\n        string name;\n        int ID;\n        Student() { ID = 0; name = \"\"; }\n        ~Student() { cout &lt;&lt; \"Destructor\" &lt;&lt; endl; }\n};\n\nint main() {\n    Student *arr = new Student[3]; // default constructor called 3 times\n    delete [] arr; // destructor called 3 times\n    return 0; // no destructor will be called without delete\n}\nCan I have an array of pointers to objects? Yes\n\nint main() {\n    // no constructors called\n    Student** arr2p = new Student* [3];\n\n...\n\n...\n\nfor (int i = 0, i &lt; 3; i++) {\n    arr2p[i] = new Student;\n}\n\n...\n\n...\n\nfor (int i = 0, i &lt; 3; i++) {\n    arr2p[i]-&gt;ID = i + 1;\n}\n\n...\n\n...\n\nfor (int i = 0, i &lt; 3; i++) {\n    delete arr2p[i];\n}\n\n...\n\n...\n\ndelete [] arr2p;\narr2p = NULL;"
  },
  {
    "objectID": "lecture14.html#overloading-operators--",
    "href": "lecture14.html#overloading-operators--",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Overloading operators (+, -, *, /)",
    "text": "Overloading operators (+, -, *, /)\nConsider this class\nclass Complex {\n    private:\n        double real;\n        double img;\n    public:\n        Complex() { real = 0.0; img = 0.0; }\n        Complex(double r, double i) { real = r; img = i; }\n};\n\nint main() {\n    Complex x(3,4);\n    Complex y(5,6);\n    Complex z;\n    z = x + y; // I can't do this now\n    return 0;\n}\nOperator overloading allows for z = x + y.\nThere are two operators: = and +.\nLet’s implement a function that does an addition.\nx + y is also equivalent to x.operator+(y).\n// return type: Complex\n// function name: operator+\nComplex Complex::operator+(Complex &rhs) {\n    return Complex(real + rhs.real, img + rhs.img);\n}\n\nclass Complex P{\n    private:\n        double real;\n        double img;\n    public:\n        Complex() { real = 0.0; img = 0.0; }\n        Complex(double r, double i) { real = r; img = i; }\n        // pass by reference: Complex&\n        Complex operator+(Complex& rhs);\n}\nPassing by value will create a copy of the rhs.\nThis is memory inefficient if the object has many data members.\nPass by value will not create a copy, so it is memory efficient.\n\nGood practices for safety\n\nPass the object as a constant object\nComplex Complex::operator+(const Complex& rhs) {\n    rhs.real = 0; // compile-time error!\n    return Complex(real + rhs.real, img + rhs.img);\n}\n\n\nOperator+ does not change members of the object\nUse const modifier to prevent changes to members of the object.\nComplex Complex::operator+(const Complex& rhs) const {\n    real = 0; // compile-time error!\n    return Complex(real + rhs.real, img + rhs.img);\n}"
  },
  {
    "objectID": "lecture14.html#ungraded-homework",
    "href": "lecture14.html#ungraded-homework",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Ungraded homework",
    "text": "Ungraded homework\nSolve the exercises of Chapter 4: Pointers and Chapter 5: Dynamic Memory Allocation.\n\nChapter 4\n\n\n\n\n\n\nExercise 1\n\n\n\nQuestion 9 in Fall 2022 Midterm Exam [Intermediate]\nWrite down the standard output of the following program. Remember to write two “Check Point”, since partial marks are given based on these “stop points”. You might find it helpful to write down the memory layout.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint i[5] = {0, 2, 4, 6, 8};\nint* p;\n\nvoid foo() {\n  cout &lt;&lt; *p &lt;&lt; endl;\n  ++(*p);\n  ++p;\n}\n\nvoid bar() {\n  for (int i = 0; i &lt; 3; ++i) {\n    foo();\n  }\n}\n\nint main() {\n  p = i;\n  bar();\n  cout &lt;&lt; \"Check Point 1\" &lt;&lt; endl;\n  p = i;\n  foo();\n  cout &lt;&lt; \"Check Point 2\" &lt;&lt; endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn main(), bar() calls foo().\nIn foo():\n\ncout &lt;&lt; *p &lt;&lt; endl is used to output the value pointed to by p. The * operator is used to dereference the pointer, i.e., to get the value that p is pointing to.\nNext, ++(*p) is executed. This line increments the value pointed to by p. The parentheses are necessary because the ++ operator has a higher priority than the * operator. Without the parentheses, p would be incremented before its value is retrieved.\nFinally, ++p increments the pointer p itself, not the value it points to, and p now points to the next memory location.\nThis will print 0 2 4 before the first checkpoint.\n\nIn main(), foo() will print i[0], which was incremented to 1, before the second checkpoint.\nThe output is:\n0\n2\n4\nCheck Point 1\n1\nCheck Point 2\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nQuestion 3 in Fall 2021 Final Exam [Intermediate]\nConsider the following code snippet that manipulates pointers in a main function of a C++ program.\nint* p = nullptr;\nint* q = nullptr;\nint* r = nullptr;\nint** t = &p;\nint** s = &q;\nr = p;\np = new int;\nq = new int;\n*p = 5;\n*q = 2;\n**s = *p + **t;\nWhich of the following statements (that come after the above snippets executes) prints 5 to the standard output? You may assume iostream is included and the std namespace is used. Choose all correct answers.\ncout &lt;&lt; r;\ncout &lt;&lt; *t;\ncout &lt;&lt; *q;\ncout &lt;&lt; *p;\ncout &lt;&lt; **t;\ncout &lt;&lt; *r;\ncout &lt;&lt; *s;\ncout &lt;&lt; (**s) / 2;\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nt and s are pointers to pointers.\nr is a nullptr.\np and q point to memory for integers on the heap, these values are set to 5 and 2.\n**s is equal to 10, it adds the values pointed by p and t (t is equal to p).\n**s points to the memory location pointed by q.\nWe can pass the snippet to a function:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  int* p = nullptr;\n  int* q = nullptr;\n  int* r = nullptr;\n  int** t = &p;\n  int** s = &q;\n  r = p;\n  p = new int;\n  q = new int;\n  *p = 5;\n  *q = 2;\n  **s = *p + **t;\n\n  cout &lt;&lt; \"r \" &lt;&lt; r &lt;&lt; endl;\n  cout &lt;&lt; \"*t \" &lt;&lt; *t &lt;&lt; endl;\n  cout &lt;&lt; \"*q \" &lt;&lt; *q &lt;&lt; endl;\n  cout &lt;&lt; \"*p \" &lt;&lt; *p &lt;&lt; endl;\n  cout &lt;&lt; \"**t \" &lt;&lt; **t &lt;&lt; endl;\n  // cout &lt;&lt; \"*r \" &lt;&lt; *r &lt;&lt; endl; // segmentation fault\n  cout &lt;&lt; \"*s \" &lt;&lt; *s &lt;&lt; endl;\n  cout &lt;&lt; \"(**s) / 2 \" &lt;&lt; (**s) / 2 &lt;&lt; endl;\n\n  return 0;\n}\nThe output is:\nr 0\n*t 0x55e631f6ceb0\n*q 10\n*p 5\n**t 5\n*s 0x55e631f6ced0\nThe statements that print 5 are:\ncout &lt;&lt; *p;\ncout &lt;&lt; **t;\ncout &lt;&lt; (**s) / 2;\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nQuestion 4 in Fall 2018 Midterm Exam [Intermediate]\nConsider the following main function. The line numbers to the left are for reference and are not part of the code.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  int* first_ptr;\n  int* second_ptr;\n  int** p_ptr;\n  first_ptr = new int;\n  second_ptr = new int;\n  p_ptr = &first_ptr;\n  *first_ptr = 4;\n  *second_ptr = 8;\n  second_ptr = *p_ptr;\n  cout &lt;&lt; *first_ptr &lt;&lt; \" \" &lt;&lt; *second_ptr &lt;&lt; endl;\n  delete first_ptr;\n  delete second_ptr;\n  delete *p_ptr;\n  return (0);\n}\n\nWhat is the output produced by cout on line 14 of the code.\nThe program may have a problem with it. What is the problem, if any? Circle only one answer.\nThe program has no problem with it. 2. The program has a memory leak. 3. The delete on line 17 should not dereference p_ptr, but use it directly. 4. The program deletes the same region of memory more than once. 5. 2 and 3. 6. 2 and 4. 7. 2, 3 and 4.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe output is 4 4.\nThere is a memory leak, second_ptr = *p_ptr was called without freeing the memory it was pointing to. first_ptr and second_ptr point to the same memory location, so delete first_ptr and delete second_ptr are equivalent. delete *p_ptr is equivalent to delete first_ptr and delete second_ptr. Therefore, 2, 3 and 4 are correct.\n\nThe correct code would be:\nint main() {\n  ...\n  delete first_ptr;\n  first_ptr = nullptr;\n    second_ptr = nullptr;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nQuestion 2 in Fall 2017 Midterm Exam [Intermediate]\nConsider the following program.\nclass Point {\n  int x;\n  int y;\n\n public:\n  Point(int i, int j);\n  Point increment_x();\n  Point increment_y();\n  void print() const;\n};\n\nPoint::Point(int i, int j) {\n  x = i;\n  y = j;\n}\n\nPoint Point::increment_x() {\n  ++x;\n  return *this;\n}\n\nPoint Point::increment_y() {\n  ++y;\n  return *this;\n}\n\nvoid Point::print() const {\n  cout &lt;&lt; \"(\" &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; endl;\n}\n\nint main() {\n  Point a(2, 3);\n  // Evaluation is done left to right\n  a.increment_x().increment_y().print();\n  a.print();\n  return 0;\n}\nAssuming the C++ compiler does not optimize away copying of objects. Write the output produced by the program.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nthis is a pointer to the object itself.\nincrement_x() would increase the value of x by 1 and return a copy of the original object.\nincrement_y() would increase the value of y by 1 on the copy of the object returned by increment_x().\na.increment_x().increment_y().print() returns (3, 4) and only the change to x was permanent.\na.print() returns (3, 3).\n\n\n\n\n\nChapter 5\n\n\n\n\n\n\nExercise 1\n\n\n\nQuestion 3 in Fall 2022 Midterm Exam [Easy]\nConsider the following C++ function:\nvoid AvadaKedavra(int n) {\n  int size = n + 1;\n  int* q = NULL;\n  for (int i = 0; i &lt; 3; ++i) {\n    q = new int[size];\n  }\n}\nIf somewhere in your main function you call AvadaKedavra(1). Based on the memory layout discussed during the lecture, answer this question: from the time this function starts to execute to the time right before it returns, how many bytes are newly allocated on the stack and the heap, respectively?\nYou may assume:\n\nAll variables are put in the main memory.\nAn int takes 4 bytes.\nWe have a 32-bit machine.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nStack 4 bytes for n, 4 bytes for size, 4 bytes for q, 4 bytes for i. Total: 16 bytes.\nHeap 4 bytes for each q, 3 times, and each q consists in 2 integers. Total: 24 bytes.\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nQuestion 9 in Fall 2021 Midterm Exam [Intermediate]\nConsider the code shown below. You can assume it compiles with no errors and runs.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint a = 0;\nint* b = &a;\nint** c = &b;\n\nint* foo(int** d) {\n  (**d)++;\n  b = *d;\n  int* e = new int;\n  *e = 10;\n  return e;\n}\n\nint main() {\n  int* g = nullptr;\n  int* f = new int;\n  *f = 5;\n  a++;\n\n  // Point 1\n\n  g = foo(&f);\n  a++;\n  (*g)++;\n\n  // Point 2\n\n  return 0;\n}\nIn the table below, give the values of the variables indicated in the table columns when program execution reaches each of the two points, Point 1 and Point 2. If a value cannot be obtained due to dereferencing a nullptr pointer, write nullptr (but assume the program does not stop).\n\n|         | a | *b | **c | *g | *f |\n|---------|---|----|-----|----|----|\n| Point 1 |   |    |     |    |    |\n| Point 2 |   |    |     |    |    |\n:::\n\n::: {.callout-note icon=false collapse=\"true\"}\n## Solution\n\n|         | a | *b | **c | *g      | *f |\n|---------|---|----|-----|---------|----|\n| Point 1 | 1 | 1  | 1   | nullptr | 5  |\n| Point 2 | 2 | 6  | 6   | 11      | 6  |\n:::\n\n::: {.callout-note icon=false}\n## Exercise 3\n\nQuestion 10 in Fall 2022 Midterm Exam [Challenging]\n\nA Vtuber is an online entertainer who posts videos on Vtube. A Vtuber will have\nfollowers on Vtube. As a programmer from Vtube, you are asked to implement a\nclass for Vtuber. The class definition and description are described below.\n\n```cpp\n#include &lt;string&gt;\nusing namespace std;\n\nclass Follower {\n private:\n  string name;\n  int age;\n\n public:\n  Follower(const string& _name, int _age) {\n    name = name_;\n    age = age_;\n  }\n  string get_name() const { return name; }\n  int get_age() const { return age; }\n};\n\nclass Vtuber {\n private:\n  // Vtuber Name\n  string name;\n  // Follower array with a variable size, each element should be a dynamically\n  // allocated object of class Follower.\n  Follower** followers;\n  // The size of follower array.\n  int follower_max;\n  // Number of followers\n  int follower_num;\n\n public:\n  Vtuber(const string& _name);\n  ~Vtuber();\n  void insert_follower(const string& follower_name, int follower_age);\n  void remove_follower(const string& follower_name);\n};\nSpecifically, Vtuber’s followers member variable is an array of pointers, each pointer pointing to a Follower object. The following graph illustrates it.\n\nPart 1\nImplement the constructor for Vtuber. Vtuber name should be initialized by _name, and follower_max should be initialized to 2. In addition, you should allocate an array called followers using new, with an initial size of 2 (the value of follower_max). Every element in this array should be a pointer to an object of class Follower and initialize all these pointers to NULL.\nPart 2\nEvery Vtuber in Vtube can get new followers or lose their current followers. This is implemented by two methods: insert_follower and remove_follower. Now you are asked to implement these two methods:\n\nFor remove_follower, a follower name is given. If there is any follower in the array matching the name, you should remove it and free its memory using delete. You can assume the follower names are all unique.\nFor remove_follower, a follower name is given. If there is any follower in the array matching the name, you should remove it and free its memory using delete. You can assume the follower names are all unique.\n\nPart 3\nImplement the destructor for the Vtuber class. You should free all the dynamically allocated objects using delete. Remember to be consistent with your previous implementation, as the entire program should not trigger any segmentation fault.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPart 1\nVtuber::Vtuber (const string& _name) {\n  name = _name;\n  follower_max = 2;\n  followers = new Follower* [follower_max];\n  for (int i = 0; i &lt; follower_max; ++i) {\n    followers[i] = NULL;\n  }\n}\nPart 2\nvoid Vtuber::insert_follower(const string& follower_name,\nint follower_age) {\n  ++follower_num;\n  for (int i = 0; i &lt; follower_max; ++i) {\n    if (followers[i] == NULL) {\n      followers[i] = new Follower(follower_name, follower_age);\n      return;\n    }\n  }\n  Follower** new_followers = new Follower* [follower_max * 2];\n  for (int i = 0; i &lt; follower_max; ++i) {\n    new_followers[i] = followers[i];\n    new_followers[i + follower_max] = NULL;\n  }\n  new_followers[follower_max] = new Follower(follower_name, follower_age);\n  delete [] followers;\n  followers = new_followers;\n  follower_max *= 2;\n  return;\n}\nvoid Vtuber::remove_follower(const string& follower_name) {\n for (int i = 0; i &lt; follower_max; ++i) {\n   if (followers[i] == NULL) {\n      continue;\n   }\n   if (followers[i]-&gt;get_name() == follower_name) {\n     delete followers[i];\n     followers[i] = NULL;\n     --follower_num;\n     break;\n   }\n  }\n  return;  \n}\nPart 3\nVtuber::~Vtuber() {\n  for (int i = 0; i &lt; follower_max; ++i) {\n    if (followers[i] != NULL) {\n      delete followers[i];\n      followers[i] = nullptr;\n    }\n  }\n  delete [] followers;\n  followers = nullptr;\n}"
  }
]