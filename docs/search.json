[
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "ECE244 tidy notes",
    "section": "Motivation",
    "text": "Motivation\nWe will learn about a programming paradigm (style/philosophy of programming) called object-oriented programming using C++"
  },
  {
    "objectID": "index.html#why-object-oriented-programming",
    "href": "index.html#why-object-oriented-programming",
    "title": "ECE244 tidy notes",
    "section": "Why object-oriented programming?",
    "text": "Why object-oriented programming?\n\nModular code — divide code into independent pieces\nReusable code\nEasily extend code\nEasier to maintain\nEasier to collaborate with large teams\nPopular programming paradigm"
  },
  {
    "objectID": "index.html#why-c",
    "href": "index.html#why-c",
    "title": "ECE244 tidy notes",
    "section": "Why C++?",
    "text": "Why C++?\n\nGenerally C/C++ are more difficult as they are closer to the hardware\nCan manage memory\nEasier to learn other languages once you know C/C++"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ECE244 Tidy Notes",
    "section": "",
    "text": "This course provides a foundation in programming using an object-oriented programming language. Topics include classes and objects, inheritance, basic data structures (lists, tree, hash tables, etc.), Big-O complexity analysis, and testing and debugging. The laboratory assignments emphasize the use of object-oriented programming constructs in the design and implementation of reasonably large programs."
  },
  {
    "objectID": "lecture2.html#today",
    "href": "lecture2.html#today",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Today",
    "text": "Today\nIntroduction to C++"
  },
  {
    "objectID": "lecture2.html#assumption",
    "href": "lecture2.html#assumption",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Assumption",
    "text": "Assumption\nYou are familiar with basic C programming (i.e., data types, variables, if statements, loops and functions)"
  },
  {
    "objectID": "lecture2.html#structure-of-a-c-program",
    "href": "lecture2.html#structure-of-a-c-program",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Structure of a C++ program",
    "text": "Structure of a C++ program\n\nHello world printing in C++\n#include &lt;iostream&gt; // standard I/O library in C++\nusing namespace std; // container for \"names\"\nint main() {\n    // cout: output in C++\n    // &lt;&lt;: operator to output\n    // endl: end of line or new line\n    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl;\n    return 0;\n}\nRecall in C it was:\n#include &lt;studio.h&gt;\nint main() {\n    printf(\"Hello world!\\n\");\n    return 0;\n}\n\n\nUser enters a value\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    // cin: input in C++\n    // &gt;&gt;: operator to input\n    // &lt;&lt; value: output a variable\n    int value;\n    cout &lt;&lt; \"Enter an integer: \" &lt;&lt; endl;\n    cin &gt;&gt; value;\n    cout &lt;&lt; \"The integer is: \" &lt;&lt; value &lt;&lt; endl;\n    return 0;\n}\nRecall in C it was:\n#include &lt;studio.h&gt;\nint main() {\n    int value;\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &value);\n    printf(\"The integer is: %d\\n\", value);\n    return 0;\n}\n\n\nData types in C++ and C\nThese are similar between the two languages.\nIntegers: 7, 10, 0, -200 (e.g., int attendees 126;)\n\nint: 32 bits, with range -2^31 to 2^31-1\nshort: 16 bits, with range -2^15 to 2^15-1\nlong: &gt;= 32 bits\n\nReal numbers: 2.7, -101.25 (e.g. double height = 1.72;)\n\nfloat: 32 bits, with 7 digits precision\ndouble: 64 bits, with 15 digits precision\nlong double: &gt;= 64 bits, with 19 digits precision\n\nCharacters: a, b, $ (e.g. char firstInitial = 's';)\nLogic: true, false (e.g. bool isRaining = false;)\nArrays can be used to store multiple data elements of same type under one variable (e.g. int arr[7] = {1, 2, 3, 4, 5, 6, 7};).\nStrings, in C, were null-terminted character arrays (e.g. char h[6] = \"hello\";). Hello is 5 characters, but we need 6 to store the null character as in hello\\0.\nIn C, you can access the string library functions strcmp, strl;en, strcpy from # include &lt;string.h&gt; (e.g. int x = strlen(str)).\nIn C++, we have a string “class” that allows you to create a string type variable. You need to include it using #include &lt;string&gt; (e.g. string courseTitle = \"Programming Fundamentals\";).\nYou can do interesting operations on strings with\n\n+: concatenate\n==: equal to\n!=: not equal to\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n    // == compares strings\n    string courseDepart, courseNum, courseCode;\n    cout &lt;&lt; \"Enter the course department and code: \" &lt;&lt; endl;\n    cin &gt;&gt; courseDepart &gt;&gt; courseNum;\n    courseCode = courseDepart + courseNum;\n    if (courseCode == \"ECE244\") {\n        cout &lt;&lt; \"That's Programming Fundamentals\" &lt;&lt; endl;\n    }\n    return 0;\n}\n\n\nExpressions and statements\nThese are the same as C\n\nArithmetic and relational expressions: x + y, x &gt;= y\nLogical conditions: A || B, A && B, !A\nDecision-making: if and if-else statements\nRepetition: while, do-while, and for loops\n\n\n\nFunctions\nAll code must have at least one function (i.e., main function)\nFunctions allow you to\n\nDivide code into pieces\nAvoid repetition -&gt; you can reuse code\nEasier to debug\n\nExample: Write a function that gets the factorial of a number\n\\[\nn! = n \\times (n-1) \\times (n-2) \\times \\cdots 3 \\times 2 \\times 1\n\\]\n// Function definition\nint factorial(int n) {\n    int fact = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\nint main() {\n    int n = 4;\n    // fact: return value stored in fact\n    // factorial(n): pass variable\n    int fact = factorial(n);\n    cout &lt;&lt; \"Factorial of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; fact &lt;&lt; endl;\n    return 0;\n}\nWe can’t call a function before it’s declaration. It’s good practice to declare functions first and then define them after the main function.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Function declaration\nint factorial(int n); // or int factorial(int);\n\n// for int factorial(int);\n// the first int is the return type\n// the second int is the parameter type\n\nint main() {\n    int n = 4;\n    // fact: return value stored in fact\n    // factorial(n): pass variable\n    int fact = factorial(n);\n    cout &lt;&lt; \"Factorial of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; fact &lt;&lt; endl;\n    return 0;\n}\n\n// Function definition\nint factorial(int n) {\n    int fact = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        fact *= i;\n    }\n    return fact;\n}"
  },
  {
    "objectID": "index.html#about-ece244---programming-fundamentals",
    "href": "index.html#about-ece244---programming-fundamentals",
    "title": "Hiram: ECE244 Tidy Notes",
    "section": "About ECE244 - Programming Fundamentals",
    "text": "About ECE244 - Programming Fundamentals\nThis course provides a foundation in programming using an object-oriented programming language. Topics include classes and objects, inheritance, basic data structures (lists, tree, hash tables, etc.), Big-O complexity analysis, and testing and debugging. The laboratory assignments emphasize the use of object-oriented programming constructs in the design and implementation of reasonably large programs."
  },
  {
    "objectID": "lecture1.html#motivation",
    "href": "lecture1.html#motivation",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Motivation",
    "text": "Motivation\nWe will learn about a programming paradigm (style/philosophy of programming) called object-oriented programming using C++"
  },
  {
    "objectID": "lecture1.html#why-object-oriented-programming",
    "href": "lecture1.html#why-object-oriented-programming",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Why object-oriented programming?",
    "text": "Why object-oriented programming?\n\nModular code — divide code into independent pieces\nReusable code\nEasily extend code\nEasier to maintain\nEasier to collaborate with large teams\nPopular programming paradigm"
  },
  {
    "objectID": "lecture1.html#why-c",
    "href": "lecture1.html#why-c",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Why C++?",
    "text": "Why C++?\n\nGenerally C/C++ are more difficult as they are closer to the hardware\nCan manage memory\nEasier to learn other languages once you know C/C++"
  },
  {
    "objectID": "lecture2.html#big-picture",
    "href": "lecture2.html#big-picture",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Big picture",
    "text": "Big picture\nBasic computer structure"
  },
  {
    "objectID": "index.html#pachas-notes",
    "href": "index.html#pachas-notes",
    "title": "Hiram: ECE244 Tidy Notes",
    "section": "Pacha’s notes",
    "text": "Pacha’s notes\n\nThe notes are 100% adjusted to the class.\nIn the snippets folder, I have included some (unofficial) code snippets with the same examples from the notes, that I use to check if the code compiles.\nSome of the examples in the notes have small additions, such as using namespace std; or #include &lt;iostream&gt;, to make them compile.\nThe diagrams are kinda ugly, my apologies! I’m not a graphic designer."
  },
  {
    "objectID": "lecture1.html#summary",
    "href": "lecture1.html#summary",
    "title": "Lecture 1 - Sept 7, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss what we will learn in this course, motivate object-oriented programming, and how is the course planned/organized/managed."
  },
  {
    "objectID": "lecture2.html#summary",
    "href": "lecture2.html#summary",
    "title": "Lecture 2 - Sept 8, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss computer hardware, input-output using cin and cout, data types and strings. if time permits, we will dig into functions."
  },
  {
    "objectID": "lecture3.html#summary",
    "href": "lecture3.html#summary",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we review functions, passing-by-value and by-pointers. We introduce passing-by-reference, and introduce multiple files programs."
  },
  {
    "objectID": "lecture3.html#last-lecture",
    "href": "lecture3.html#last-lecture",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nIntroduction to C++"
  },
  {
    "objectID": "lecture3.html#today",
    "href": "lecture3.html#today",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Today",
    "text": "Today\nFunctions and passing parameters\n\n\n\n\n\n\nExample\n\n\n\nWrite a function that gets the factorial of a number \\(n! = n \\times (n-1) \\times (n-2) \\times \\cdots 3 \\times 2 \\times 1\\)\nint factorial (int n) {\n    int fact = 1;\n    for (int i=0; i &lt;= n; i++) {\n        fact = fact * i;\n    }\n    return fact;\n}\nWe can invoke the function in main\nint main() {\n    int n = 4;\n    // fact: return value stored in fact\n    // factorial: call function that will return n!\n    // n: pass variable\n    int fact = factorial(n);\n    cout &lt;&lt; \"Factorial of \" &lt;&lt; n &lt;&lt; \" is \" &lt;&lt; fact &lt;&lt; endl;\n    return 0;\n}\n\n\nWe passed the variable n by value. This means we only passed a copy of n. If we change n in the factorial function, it will not be changed in main.\nThis is called pass-by-value.\nTherefore, if we swap two variables in the following functions, they will not get swapped in main.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap(int x, int y) {\n    int temp = x;\n    x = y;\n    y = temp;\n}\n\nint main() {\n    int x = 7, y = 13;\n    cout &lt;&lt; \"Before swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    swap(x, y);\n    cout &lt;&lt; \"After swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}\nIn C, we resolved this issue by passing the address of the two variables to the swap function.\nvoid swap(int* px, int* py) {\n    // *px: *(&(x)) = x in main\n    int temp = *px;\n    *px = *py;\n    *py = temp;\n}\n\nint main() {\n    int x = 7, y = 13;\n    // &x: address of x\n    // &y: address of y\n    swap(&x, &y);\n    return 0;\n}\nIn C++, there is pass-by-reference syntax that allows a function to access the original variable with no usage of pointers.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added the cout statements to the code below.\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid swap(int& x, int& y) {\n    // no change\n    int temp = x;\n    x = y;\n    y = temp;\n}\n\nint main() {\n    int x = 7, y = 13;\n    cout &lt;&lt; \"Before swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    swap(x, y);\n    cout &lt;&lt; \"After swap: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}"
  },
  {
    "objectID": "lecture3.html#program-organization",
    "href": "lecture3.html#program-organization",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Program organization",
    "text": "Program organization\nLarge programs are typically organized into multiple files. This helps when we divide tasks in a team.\nThis also can speed up compilation, and we will explain how.\n\nSingle file program\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printNum(int x);\nint userInputNum();\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\nTo compile, run the following command in the terminal\ng++ lecture3-example3.cpp -o lecture3-example3.so\nUse “.exe” instead of “.so” on Windows.\nThis command generates the executable file, which contains zeroes and ones.\n\n\nMultiple files program\nWe can divide the program into multiple files.\nThe function declarations are in the header files (i.e. .h files).\nThe function implementations are in the source files (i.e. .cpp files).\n\nmain.cpp\n// &lt;&gt;: searches in standard library locations\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// \"\": searches in current directory\n#include \"print.h\"\n#include \"input.h\"\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\n\nprint.h\nvoid printNum(int x);\n\n\ninput.h\nint userInputNum();\n\n\nprint.cpp\n#include \"print.h\"\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\n\ninput.cpp\n#include \"input.h\"\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\nTo compile this program with multiple files, there are different ways.\ng++ main.cpp print.cpp input.cpp -o lecture3-example4.so\nWhat happens under the hood?"
  },
  {
    "objectID": "lecture3.html#notes",
    "href": "lecture3.html#notes",
    "title": "Lecture 3 - Sept 12, 2023",
    "section": "Notes",
    "text": "Notes\n\n#includebelongs to a class of instructions called pre-processor directives.\nPreprocessing happens before the compilation.\nPreprocessing textually replaces the #include with the content of the filename.\nYou can include .cpp files instead of .h files. It is bad practice! Why?\nLinking appends function implementations to produce the executable file.\nLinking takes much less time than compiling.\n\nWhat if I update…\n\nmain.cpp\nprint.o and input.o will not change. Only main.o will change.\ng++ main.cpp\ng++ main.o print.o input.o -o main.so\n\n\nprint.cpp\nmain.o and input.o will not change. Only print.o will change.\ng++ print.cpp\ng++ main.o print.o input.o -o main.so\n\n\nprint.h\nThis changes #include \"print.h\" in main.cpp and print.cpp.\ng++ main.cpp\ng++ print.cpp\ng++ main.o print.o input.o -o main.so\nWhat happens if I include the same .h file multiple times? Why would someone do that? Next lecture."
  },
  {
    "objectID": "lecture4.html#summary",
    "href": "lecture4.html#summary",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we review what’s a reference variable, and delve deeply into what happens when we compile a multiple file program."
  },
  {
    "objectID": "lecture4.html#last-lecture",
    "href": "lecture4.html#last-lecture",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nFunctions: pass-by-value and pass-by-reference."
  },
  {
    "objectID": "lecture4.html#today",
    "href": "lecture4.html#today",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Today",
    "text": "Today\nMultiple file programs and separate compilation."
  },
  {
    "objectID": "lecture4.html#references",
    "href": "lecture4.html#references",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "References",
    "text": "References\nA reference is an alias, an alternate name, to a variable.\n\n\n\n\n\n\nExample\n\n\n\nint a = 7, b = 12;\nint& ra = a; // ra refers to a\ncout &lt;&lt; ra &lt;&lt; endl; // prints value of a = 7\nra = b; // changes value of a to 12\n\n\n\nReference cannot be re-assigned.\nMust be initialized when declared.\nReference does not have a separate memory location.\n\n\n\n\n\n\n\nExample\n\n\n\nAfter executing the following, what are the values of x and y?\nint x = 10;\nint& y = x;\ny = 20;\nx is 20, y is 20.\n\n\n\n\n\n\n\n\nExample\n\n\n\nWhat is the value of a, ra and b after executing the following?\nint a = 7, b = 12;\nint& ra = a;\nra = b;\na is 12, ra is 12, and b is 12."
  },
  {
    "objectID": "lecture4.html#program-organization",
    "href": "lecture4.html#program-organization",
    "title": "Lecture 4 - Sept 14, 2023",
    "section": "Program organization",
    "text": "Program organization\nWe want to split code accross multiple files.\n\nOrganized\nEasier to collaborate\nFaster to compile - Why? Today’s topic.\n\n\nSingle file program\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printNum(int x);\nint userInputNum();\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\nTo compile, run the following command in the terminal:\ng++ lecture4-example1.cpp -o lecture4-example1.so\nThis command generates the executable file, which contains zeroes and ones.\n\n\nMultiple file program\n\nmain.cpp\nCorrection to the example from lecture 3: We do not need #include &lt;iostream&gt; nor using namespace std because we are not using cout and cin in this file.\n// \"\": searches in current directory\n#include \"print.h\"\n#include \"input.h\"\n\nint main() {\n    int num;\n    num = userInputNum();\n    printNum(num);\n    return 0;\n}\n\n\nprint.h\nvoid printNum(int x);\n\n\ninput.h\nint userInputNum();\n\n\nprint.cpp\nWe include iostream here.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added using namespace std here to make the code compile.\n\n\n#include \"print.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid printNum(int x) {\n    cout &lt;&lt; \"The number is \" &lt;&lt; x &lt;&lt; endl;\n}\n\n\ninput.cpp\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added using namespace std here to make the code compile.\n\n\n#include \"input.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint userInputNum() {\n    int x;\n    cout &lt;&lt; \"Enter integer: \";\n    cin &gt;&gt; x;\n    return x;\n}\n\n\n\nOrganization\n\nFunction declaration goes in header files (i.e., .h files)\nFunction implementation goes in source files (i.e., .cpp files)\n\n\n\nCompilation\nTo compile this program with multiple files, there are different ways.\n\nCase 1\nTo compile, run the following command in the terminal:\ng++ main.cpp print.cpp input.cpp -o main.so\nThis command needs some explanation.\n\nWhat happens under the hood? Remember the diagram from lecture 3.\n\n\nSource file: Has function implementations (e.g, print.cpp, main.cpp).\nHeader file: Has function declarations (e.g., print.h, input.h).\nCompiler: Converts high-level programming language to machine language.\nObject file (cannot be executed): Has machine code with references to other variables in another file (e.g., main.o)\nLinking: A linker combines object files to produce one executable.\nExecutable file: Can be run directly on a CPU.\n\nStory of compilation:\n\n#include belongs to a class of instructions called pre-processor directives.\nBefore compiler compiles to object files, pre-processing textually replaces #include \"file-name\" with contents of the file name.\nCompiler converts pre-processed C++ code to an object file.\nObject file has machine code with references to other files.\nLinking appends function implementation in object files to create an executable.\nLinking takes much less time than compilation.\n\n\n\nCase 2\nSince linking takes less time compared to compiling, we can do separate compilation into\n\ng++ -c main.cpp produces main.o\ng++ -c print.cpp produces print.o\ng++ -c input.cpp produces input.o\ng++ main.o print.o input.o -o main.so produces main.so\n\nWhat if I update…\n\n\nmain.cpp\nprint.o and input.o will not change. Only main.o will change.\ng++ -c main.cpp\ng++ main.o print.o input.o -o main.so\n\n\nprint.cpp\nmain.o and input.o will not change. Only print.o will change.\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\n\n\nprint.h\nThis changes #include \"print.h\" in main.cpp and print.cpp. This is tricky!\ng++ -c main.cpp\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\nIDEs, like VS Code, and Make files keep track of what file you changed and minimizes compile commands as they take time.\nIn short, dividing code across multiple files can save compilation time."
  },
  {
    "objectID": "lecture5.html#summary",
    "href": "lecture5.html#summary",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss #ifndef include guards for header files, and introduce C++ I/O."
  },
  {
    "objectID": "lecture5.html#last-lecture",
    "href": "lecture5.html#last-lecture",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nMultiple file programs and separate compilation."
  },
  {
    "objectID": "lecture5.html#today",
    "href": "lecture5.html#today",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Today",
    "text": "Today\nMacros and C++ I/O."
  },
  {
    "objectID": "lecture5.html#recap-from-previous-lecture",
    "href": "lecture5.html#recap-from-previous-lecture",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Recap from previous lecture",
    "text": "Recap from previous lecture\n\nmain.cpp: print.o and input.o will not change. Only main.o will change.\n\ng++ -c main.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.cpp: main.o and input.o will not change. Only print.o will change.\n\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\n\nprint.h: This changes #include \"print.h\" in main.cpp and print.cpp. This is tricky!\n\ng++ -c main.cpp\ng++ -c print.cpp\ng++ main.o print.o input.o -o main.so\nIDEs, like VS Code, and Make files keep track of what file you changed and minimizes compile commands as they take time.\nIn short, dividing code across multiple files can save compilation time."
  },
  {
    "objectID": "lecture5.html#macros",
    "href": "lecture5.html#macros",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Macros",
    "text": "Macros\nWhat happens if I include the same header (.h file) multiple times?\nWhy would someone do that?\n\n\n\n\n\n\nExample\n\n\n\nWhat happens if we have this structure?\n\nTo solve this, a preprocessor #ifndef guards against including a header file several times.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n// a.h\n\n#ifdef A_H\n#define A_H\n\nstruct A {\n    ...\n}\n\n#endif\nThe first time “a.h” is read, it will find A_H is not defined.\nThen it will define A_H and struct A.\nThe next time it reads “a.h”, A_H will be defined and hence would skip instructions until #endif.\n\n\n\nIn general, #ifdef [MACRO]ignores the whole code until #endif if [MACRO] is defined.\n#ifndef [MACRO] ignores the whole code until #endif if [MACRO] is not defined.\nWhy do we need header files? Can we just have .cpp files and include it?\n\n\n\n\n\n\nExample\n\n\n\n// main .cpp\n\n#include \"print.cpp\"\n\nint main() {\n  ...\n}\n// print.cpp\n\n#include &lt;iostream&gt;\n\nvoid printNum(int x) {\n    ...\n}\nThis means wheter I change print.cpp, I will have to re-compile main.cpp and print.cpp.\nAlso, linking will fail as main.cpp will have printNum() implemented and print.cpp too. You will have multiple definitions of printNum in the executable main, which is not allowed.\n\n\nmain.o will have printNum() implementation\nprint.o already has printNum() implementation\nprintNum() is defined twiece, so linking will fail."
  },
  {
    "objectID": "lecture5.html#c-io",
    "href": "lecture5.html#c-io",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "C++ I/O",
    "text": "C++ I/O\nThere are many ways to take input and produce output.\n\nStandard input-output\nUsing cout and cin from iostream.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int x;\n    cout \"Hello world\" &lt;&lt; endl;\n    cin &gt;&gt; x;\n    return 0;\n}\n\n\nFile input-output\nUsing ifstream (input file) and ofstream (output file) from fstream.\n\nOutput to a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n    ofstream outFile(\"myFile.txt\");\n    string name = \"We are engineers!\";\n    outFile &lt;&lt; name;\n    outFile.close();\n}\nIf a file does not exist , it will be created. If it exists, its contents will be overwritten.\nTo append a file, use ofstream outFile(\"myFile.txt\", ios::app);.\n\n\nInput from a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n    ifstream inputFile;\n    inputFile.open(\"myFile.txt\");\n\n    // or ifstream inputFile(\"myFile.txt\");\n    // to replace the two lines above\n\n    int num1, num2, num3;\n    \n    // input from file\n    inputFile &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;\n\n    inputFile.close();\n\n    return 0;\n}\n\nWhere to find the file?\n\n```cpp\n// absolute path\ninFile.open(\"/u/prof/emarasal/ece244/lab1/myFile.txt\")\n\n// relative path\ninFile.open(\"lab1/myFile.txt\")\ninFile.open(\"../myFile.txt\")\n\n// current directory\ninFile.open(\"myFile.txt\")\n\n\nBuffering\n\nThe output is not immediately written to a file.\nIt will be written in “chunks”.\nWhy buffering? Writing in a buffer is much faster than writing in a file.\nTo optimize resources, writing in files happens in chunks.\nTo force output, use outputFile.flush() or outputFile &lt;&lt; endl;."
  },
  {
    "objectID": "lecture5.html#ungraded-homework",
    "href": "lecture5.html#ungraded-homework",
    "title": "Lecture 5 - Sept 15, 2023",
    "section": "Ungraded homework",
    "text": "Ungraded homework\nSolve the exercises of Chapter 1: Programming Basics\n\n\n\n\n\n\nExercise 1\n\n\n\nQuestion 2 in Fall 2022 Midterm Exam [Easy]\nWhen you compile the following program, what happens? If there is an error, explain what the error is (one sentence max).\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  hello(1);\n  return 0;\n}\nvoid hello(int i) {\n  cout &lt;&lt; \"Hello !\" &lt;&lt; i &lt;&lt; endl;\n  return;\n}\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThere will be a compilation error because hello() is called before it is declared.\nThe correct code is:\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Forward function\nvoid hello(int i);  \n\nint main() {\n  hello(1);\n  return 0;\n}\n\n// Function definition\nvoid hello(int i) {\n    cout &lt;&lt; \"Hello !\" &lt;&lt; i &lt;&lt; endl;\n    return;\n}\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nQuestion 4 in Fall 2022 Midterm Exam [Easy]\nWhich is the output of the following program?\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid increment(int& a) {\n  a = a + 1;\n}\n\nvoid decrement(int a) {\n  a = a - 1;\n}\n\nvoid doubling(int* a) {\n  *a = (*a) * 2;\n}\n\nint main() {\n  int a = 3;\n  increment(a);\n  cout &lt;&lt; a &lt;&lt; endl;\n  decrement(a);\n  cout &lt;&lt; a &lt;&lt; endl;\n  doubling(&a);\n  cout &lt;&lt; a &lt;&lt; endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n4, 4 and 8 because increment() is called by reference, decrement() is called by value and doubling() takes a pointer and dereferences it to modify the original value.\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nQuestion 6 in Fall 2022 Midterm Exam [Easy]:\nCompared to C, passing by reference is introduced in C++. Both of the following two functions can be used to swap the value of two integers:\nvoid swap_by_p(int* a, int* b); // swap version.1\nvoid swap_by_r(int& a, int& b); // swap version.2\nPart 1. Write the implementations for these two functions (no more than 4 lines of code for each function)\nvoid swap_by_p(int* a, int* b) {\n    ...\n}\n\nvoid swap_by_r(int& a, int& b) {\n    ...\n}\nPart 2. If given two int variables x and y, write a function call that swaps the value of x and y, using swap_by_p.\nPart 3. If given two int variables x and y, write a function call that swaps the value of x and y, using swap_by_r.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid swap_by_p(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid swap_by_r(int& a, int& b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 200;\n    int y = 100;\n    swap_by_p(&x, &y);\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;\n    swap_by_r(x, y);\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nQuestion 7 in Fall 2022 Midterm Exam [Easy]\nEllie writes a program to make a simple database for ECE students who like drinking soy milk from 2T2 to 2T6. She designs two classes: student and ECE, and puts them into different files below. The main function is in the main.cpp.\nECE.h\n#ifndefine ECE\n#define ECE\n\n#include \"student.h\"\n\nclass ECE{\n    ...\n};\n\n#endif\nECE.cpp\n#include \"ECE.h\"\n\nECE::ECE() {\n    ...\n}\nstudent.h\n#include &lt;string&gt;\n\nclass Student {\n    ...\n};\nstudent.cpp\n#include \"student.h\"\n\nStudent::Student() {\n    ...\n}\nmain.cpp\n#include \"ECE.h\"\n#include \"student.h\"\n\nint main() {\n    ...\n}\nPart 1. Ellie tries to compile this program with g++. What’s the Unix (i.e., terminal) command that compiles the entire program using one command, which generates an executable called small_database?\nPart 2. However, it fails to compile. Can you point out the compile-time error and fix this error for her?\nPart 3. With your help, Ellie has fixed the compile-time error. Now, Ellie wants to use separate compilation learned from ECE244 to compile her project. Write down all the Unix commands necessary to separately compile the above files and generate an executable small_database.\nPart 4. Ellie then changes some code in ECE.cpp. Write down the Unix commands necessary to regenerate the executable by compiling the smallest number of files needed. Assume the generated executable is called small_database.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nCompile with\ng++ main.cpp ECE.cpp student.cpp -o small_database\nThe first problem is that student.h has no header guard, and it is included in both ECE.h and student.cpp. This will cause a multiple definition error.\nThe solution is to add a header guard to student.h.\n#ifndef STUDENT\n#define STUDENT\n\n#include &lt;string&gt;\n\nclass Student {\n    ...\n};\nThe second problem is that ECE.h says #ifndefine ECE, but it should be #ifndef ECE.\nTo compile separately, use\ng++ -c student.cpp -o student.o\ng++ -c ECE.cpp -o ECE.o\ng++ -c main.cpp -o main.o\ng++ student.o ECE.o main.o -o small_database\nAfter changing ECE.cpp, use\ng++ -c ECE.cpp -o ECE.o\ng++ student.o ECE.o main.o -o small_database\n\n\n\n\n\n\n\n\n\nExercise 5\n\n\n\n\n\nQuestion 2 Fall 2018 Midterm Exam\nYou are given a program that has a main function and 3 classes: First, Second and Third. For each of these classes, you have a definition file and an implementation file. Thus, you have seven files in total: First.h, First.cpp, Second.h, Second.cpp, Third.h, Third.cpp and main.cpp. All the files exist in the same directory.\nThe first few lines of each file are shown below. The rest of the contents of each file is irrelevant to the question and is shown as …. You may assume the definition/implementation files are error-free.\nFirst.h\n#ifndef FIRST_H\n#define FIRST_H\n\nclass First {\n    ...\n};\n#endif\nFirst.cpp\n#include “First.h”\n\nFirst::First() {\n    ...\n}\nSecond.h\n#ifndef SECOND_H\n#define SECOND_H\n\nclass Second {\n  ...\n};\n\n#endif\nSecond.cpp\n#include \"First.h\"\n#include \"Second.h\"\n\nSecond::Second() {\n  ...\n}\nThird.h\n#ifndef THIRD_H\n#define THIRD_H\n\nclass Third {\n  ...\n};\n\n#endif\nThird.cpp\n#include \"Second.h\"\n\nThird::Third() {\n  ...\n}\nmain.cpp\n#include \"First.h\"\n#include \"Second.h\"\n#include \"Third.h\"\n\nint main() {\n  ...\n}\nThe files are to be separately compiled and then linked into a single executable called main.\nPart 1. Write down the Unix commands necessary to separately compile the above files and generate the executable.\nPart 2. You modify the file Second.cpp. Write down the Unix commands necessary to regenerate the executable by compiling the smallest number of files possible.\nPart 3. You modify the file First.h. Write down the Unix commands necessary to regenerate the executable by compiling the smallest number of files possible.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPart 1\ng++ -c First.cpp -o First.o\ng++ -c Second.cpp -o Second.o\ng++ -c Third.cpp -o Third.o\ng++ -c main.cpp -o main.o\ng++ First.o Second.o Third.o main.o -o main\nPart 2\ng++ -c Second.cpp -o Second.o\ng++ First.o Second.o Third.o main.o -o main\nPart 3\ng++ -c First.cpp -o First.o\ng++ -c Second.cpp -o Second.o\ng++ First.o Second.o Third.o main.o -o main"
  },
  {
    "objectID": "lecture6.html#summary",
    "href": "lecture6.html#summary",
    "title": "Lecture 6 - Sept 19, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we introduce file input/output and what happens when the input is unexpected."
  },
  {
    "objectID": "lecture6.html#last-lecture",
    "href": "lecture6.html#last-lecture",
    "title": "Lecture 6 - Sept 19, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nSeparate compilation and header guards."
  },
  {
    "objectID": "lecture6.html#today",
    "href": "lecture6.html#today",
    "title": "Lecture 6 - Sept 19, 2023",
    "section": "Today",
    "text": "Today\nC++ file I/O and handling errors.\nThere are many ways to take input and produce output.\n\nStandard input-output\nUsing cout and cin from iostream.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  int x;\n  cout &lt;&lt; \"Hello world\" &lt;&lt; endl;\n  cin &gt;&gt; x;\n  return 0;\n}\n\n\nFile input-output\nUsing ifstream and ofstream from fstream.\n\nOutput to a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n  ofstream outFile(\"output.txt\");\n  string name = \"We are engineers!\";\n  outFile &lt;&lt; name;\n  outFile.close();\n}\nIf a file does not exist, it will be created. If it exists, its contents will be overwritten.\nTo append to a file, use outFile.open(\"output.txt\", ios::app).\n\n\nInput from a file\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n  ifstream inputFile;\n  inputFile.open(\"myFile.txt\");\n\n  // or ifstream inputFile(\"myFile.txt\");\n  // to replace the two lines above\n\n  int num1, num2, num3;\n\n  // input from file\n  inputFile &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;\n\n  inputFile.close();\n\n  return 0;\n}\nWhere to find the file?\n// absolute path\ninFile.open(\"/u/prof/emarasal/ece244/lab1/myFile.txt\")\n\n// relative path\ninFile.open(\"lab1/myFile.txt\")\ninFile.open(\"../myFile.txt\")\n\n// current directory\ninFile.open(\"myFile.txt\")\nBuffering\n\nThe output is not immediately written to a file.\nIt will be written in “chunks”.\nWhy buffering? Writing in a buffer is much faster than writing in a file.\nTo optimize resources, writing in files happens in chunks.\nTo force output, use outputFile.flush() or outputFile &lt;&lt; endl;.\n\nRemember the diagram from lecture 5."
  },
  {
    "objectID": "lecture6.html#handling-io-errors",
    "href": "lecture6.html#handling-io-errors",
    "title": "Lecture 6 - Sept 19, 2023",
    "section": "Handling I/O errors",
    "text": "Handling I/O errors\n\nInput stream is stored in a buffer.\nThis buffer is only available when \\n is entered.\ncin ignores/skips delimiters or whitespaces\nDelimiters are , \\t, \\n.\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\nReading still happens until a delimiter is seen or when something wrong happens!\n\n\n\n\n\n\nExample\n\n\n\n\n\ncin will read 13 into x, but it will not read ● as it is not part of an integer.\ncin will look for an int for y, but will find ●.\ncin will fail silently , y is unaffected, and the buffer is unaffected.\nA fail flag is raised, and all other cin in the program will fail.\n\nWhat should you do?\n\nCheck if the fail flag is raised.\nIf yes, handle the error.\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n// file input\n\n#include &lt;fstream&gt;\n\nint main() {\n  ifstream inputFile(\"myFile.txt\"); // error 1\n  int a,b;\n  inputFile &gt;&gt; a &gt;&gt; b; // error 2 and 3\n  return 0;\n}\n// standard input\n\n#include &lt;iostream&gt;\n\nint main() {\n  int a;\n  cin &gt;&gt; a; // error 2 and 3\n  return 0;\n}\nWhat can go wrong?\nError 1. The file to be opened for input does not exist.\nError 2. The variable cannot be read.\nError 3. Reached the end of a file.\n\n\n\nHow do we know a failure ocurred?\n\nTo detect tat a file does not exist, inputFile.fail() will be set to true.\nTO detect an issue with reading a variable, cin.fail() or inputFile.fail() will be set to true.\nTo detect we reached the end of a file, cin.eof() and inputFile.eof() will be set to true. However, inputFile.eof() will not set the failure flag to true.\n\ncin.eof() is CTRL+D on PC and CMD+D on Mac.\n\n\n\n\n\n\nExample\n\n\n\nDetecting a failure\n// after ifstream inputFile(\"myFile.txt\"); ...\n\nif (inputFile.fail()) {\n  cerr &lt;&lt; \"Cannot open file\" &lt;&lt; endl;\n  return 1;\n}\n\n\nWhat is cerr? It is an output stream like cout. It is unbuffered unlike cout. This means that the output appears immediately on the console/terminal.\nWhy return 1? Any non-zero number signals an error.\n\n\nWhat to do when a failure with input occurs?\ncin.clear() will clear the failure condition so cin.fail() and cin.eof() are back to false.\ncin.ignore(int n, char ch) will discard n characters or up to character ch, whichever comes first."
  },
  {
    "objectID": "lecture7.html#summary",
    "href": "lecture7.html#summary",
    "title": "Lecture 7 - Sept 22, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss detecting and handling errors in the input from a file or user."
  },
  {
    "objectID": "lecture7.html#last-lecture",
    "href": "lecture7.html#last-lecture",
    "title": "Lecture 7 - Sept 22, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nFile I/O."
  },
  {
    "objectID": "lecture7.html#today",
    "href": "lecture7.html#today",
    "title": "Lecture 7 - Sept 22, 2023",
    "section": "Today",
    "text": "Today\nHandling I/O errors.\n\nHandling I/O errors\n\nInput stream if stored in a buffer.\nThis buffer is only available when \\n is entered.\ncin ignores/skips delimiters or whitespaces.\nDelimiters are , \\t, \\n.\n\n\n\n\n\n\n\nExample\n\n\n\nRemember the diagram from lecture 6.\n\n\n\nReading happens until a delimiter is seen or when something wrong happens! :::\n\n\n\n\n\n\nExample\n\n\n\n\n\ncin will read 13 into x, but it will not read ● as it is not part of an integer.\ncin will look for an int for y, but will find ●.\ncin will fail silently , y is unaffected, and the buffer is unaffected.\nA fail flag is raised, and all other cin in the program will fail.\n\nWhat should you do?\n\nCheck if the fail flag is raised.\nIf yes, handle the error.\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n// file input\n\n#include &lt;fstream&gt;\n\nint main() {\n    inputFile(\"myFile.txt\"); // error 1\n    int a,b;\n    inputFile &gt;&gt; a &gt;&gt; b; // error 2 and 3\n    return 0;\n}\n// standard input\n\n#include &lt;iostream&gt;\n\nint main() {\n    int a;\n    cin &gt;&gt; a; // error 2 and 3\n    return 0;\n}\nWhat can go wrong?\nError 1. The file to be opened for input does not exist.\nError 2. The variable cannot be read.\nError 3. Reached the end of a file.\n\n\n\n\n\n\n\n\nExample\n\n\n\nDetecting a failure\n// after ifstream inputFile(\"myFile.txt\"); ...\n\nif (inputFile.fail()) {\n    cerr &lt;&lt; \"Cannot open file\" &lt;&lt; endl;\n    return 1;\n}\n\n\nWhat is cerr? It is an output stream like cout. It is unbuffered unlike cout. This means that the output appears immediately on the console/terminal.\nWhy return 1? Any non-zero number signals an error.\n\n\nWhat to do when a failure with input occurs?\ncin.clear() will clear the failure condition so cin.fail() and cin.eof() are back to false.\ncin.ignore(int n, char ch) will discard n characters or up to character ch, whichever comes first.\n\n\n\n\n\n\nExample\n\n\n\nFor the following input, I want to ignore numbers before the space and read only the name.\n1010 Asmita\ncin.ignore(1000, ' ');\ncin &gt;&gt; name;\n\n\nWrite a program that reads a number from the user. It is not a number, prompt the user again.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added #include &lt;iostream&gt; and using namespace std here to make the code compile.\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int num = 0;\n    cout &lt;&lt; \"Enter a number:\" &lt;&lt; endl;\n    cin &gt;&gt; num;\n\n    // if cin.fail() is true,\n    // cin.ignore() will fail too\n    while(cin.fail()) {\n        // do not swtich the order\n        // we must clear first\n        cin.clear();\n        cin.ignore(1000, '\\n');\n        cout &lt;&lt; \"Try again!\" &lt;&lt; endl;\n        cin &gt;&gt; num;\n    }\n\n    cout &lt;&lt; \"The number entered is \" &lt;&lt; num;\n    \n    return 0;\n}\nWrite a program that reads numbers from a file and prints their sum. If it reads a non-integer number, ignore it. Numbers are written on separate lines.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added #include &lt;iostream&gt;, #include &lt;fstream&gt; and using namespace std here to make the code compile.\n\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n    ifstream inputFile(\"myFile.txt\");\n\n    int num = 0, sum = 0;\n\n    while(!inFile.eof()) {\n        inFile &gt;&gt; num;\n        if (inFile.fail()) {\n            inFile.clear();\n            inFile.ignore(1000, '\\n');\n        } else {\n            sum += num;\n        }\n    }\n\n    cout &lt;&lt; \"Reached end of file\" &lt;&lt; endl;\n    cout &lt;&lt; \"The sum is \" &lt;&lt; sum &lt;&lt; endl;\n    return 0;\n}"
  },
  {
    "objectID": "lecture8.html#summary",
    "href": "lecture8.html#summary",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss string streams. Then we start introducing classes."
  },
  {
    "objectID": "lecture8.html#last-lecture",
    "href": "lecture8.html#last-lecture",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nHandling I/O errors."
  },
  {
    "objectID": "lecture8.html#today",
    "href": "lecture8.html#today",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Today",
    "text": "Today\nString streams and introduce classes."
  },
  {
    "objectID": "lecture8.html#recap-on-flags",
    "href": "lecture8.html#recap-on-flags",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Recap on flags",
    "text": "Recap on flags\nRemember .eof() and .fail() flags.\nWrite a program that reads numbers from a file and prints their sum. If it reads a non-integer number, ignore it. Numbers are written on separate lines.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added #include &lt;iostream&gt;, #include &lt;fstream&gt; and using namespace std here to make the code compile. I also added an &lt;&lt; endl after cerr &lt;&lt; to avoid this in the terminal\nlecture8 (main) $ ./example1.so \nCan't open filelecture8 (main) $ \nbut to see this instead\nlecture8 (main) $ ./example1.so \nCan't open file\nlecture8 (main) $ \n\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint main() {\n        ifstream inputFile(\"myFile.txt\");\n\n        if (inFile.fail()) {\n                cerr &lt;&lt; \"Can't open file\" &lt;&lt; endl;\n                return 1;\n        }\n\n        int num = 0, sum = 0;\n\n        while (!inFile.eof()) {\n                inFile &gt;&gt; num;\n\n                if (inFile.fail()) {\n                        inFile.clear();\n                        inFile.ignore(1000, '\\n');\n                } else {\n                        sum += num;\n                }\n\n        }\n\n        cout &lt;&lt; \"Reached end of file\" &lt;&lt; endl;\n        cout &lt;&lt; \"The sum is \" &lt;&lt; sum &lt;&lt; endl;\n        return 0;\n}"
  },
  {
    "objectID": "lecture8.html#string-streams",
    "href": "lecture8.html#string-streams",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "String streams",
    "text": "String streams\nString streams are helpful when inputs are line-oriented (i.e., user will enter a line and program has to check if inputs on that line are correct).\nString streams can be used to extract inputs in the line.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added #include &lt;iostream&gt; and using namespace std here to make the code compile.\n\n\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n        int ID;\n        \n        string name;\n        string inputLine = \"1001 Joe\";\n        \n        // create a string stream initialized with input line\n        stringstream myStringStream(inputLine);\n\n        myStringStream &gt;&gt; ID; // takes input into ID\n        myStringStream &gt;&gt; name; // takes input into name\n\n        cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; endl &lt;&lt; \"ID: \" &lt;&lt; ID &lt;&lt; endl;\n\n        myStringStream &lt;&lt; name &lt;&lt; ID; \n\n        // converts a string stream to a string to print it\n        cout &lt;&lt; myStringStream.str() &lt;&lt; endl;\n\n        return 0;\n}\nWhat happens if I read more out of myStringStream than there is? myStringStream.eof() will be true."
  },
  {
    "objectID": "lecture8.html#getline-function",
    "href": "lecture8.html#getline-function",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Getline function",
    "text": "Getline function\ngetline is part of iostream and it can be used to grab an entire line.\n...\n\nstring inputLine;\n\n// entire line entered by user gets stored in inputLine\ngetline(cin, inputLine);\n\nstringstream myStringStream(inputLine);\n\nmyStream &gt;&gt; ID;\nmyStream &gt;&gt; name;\n\n...\nLab 3 will use string streams."
  },
  {
    "objectID": "lecture8.html#introduction-to-classes",
    "href": "lecture8.html#introduction-to-classes",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Introduction to classes",
    "text": "Introduction to classes\nA class is a user defined data type.\nA variable of that user-defined data type is called an object.\nDeclaring an object is called creating an instance or instantiation.\n\n\n\n\n\n\n\nExample\n\n\n\nRecall structs in C.\nThis is a data structure that stores data of different types using one variable name.\nstruct Student {\n        string name;\n        int ID;\n}\n\nstruct Student x;\n\n// access name of x using . operator\nx.name = \"Cindy\";\n\n\nThe definition of a class goes to a header file (e.g. Student.h)\n\nStudent.h\nclass Student {\n        private:\n                int ID;\n                string name;\n\n        public:\n                void setName(string name);\n                void getName();\n                void print();\n};\nThis needs a diagram to explain the different parts.\n\nprivate members can only be accessed within the class.\npublic members can be accessed outside the class.\nWhy? This is called encapsulation\n\nHide information related to the class (e.g., student ID).\nIt is not available outside the class.\nIt brings related data and functions together.\nIt organizes the code."
  },
  {
    "objectID": "lecture8.html#class-implementation",
    "href": "lecture8.html#class-implementation",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Class implementation",
    "text": "Class implementation\nThe class implementation goes in a source file and it has function definitions.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added endl after the cout statements for the same reason as above.\n\n\n\nStudent.cpp\n#include \"Student.h\"\n#include &lt;iostream&gt;\n\n// Setter or mutator function\n\n// class name: Student\n// scope operator: ::\n// function name: setName\nvoid Student::setName(string n) {\n        // private member of Student class can be accessed\n        // inside the class implementation\n        name = n;\n}\n\n// Getter or accessor function\n\nstring Student::getName() {\n        return name;\n}\n\nvoid Student::print() {\n        cout &lt;&lt; \"Student name: \" &lt;&lt; name &lt;&lt; endl;\n        cout &lt;&lt; \"Student ID: \" &lt;&lt; ID &lt;&lt; endl;\n}\n\n\nmain.cpp\nInstatiating and using objects here.\n#include \"Student.h\"\n\nint main() {\n        // declare 2 objects and allocate memory for them\n        Student x,y;\n\n        x.setName(\"Kenya\");\n        y.setName(\"Christina\");\n\n        // x.ID = 2730; gives an error because we cannot access a private member\n\n        // y.name = \"Salma\" same error\n\n        y.print(); // wait! what is the value of ID in Student y?\n\n        return 0;\n}\nID in x and y are not initialized. The solution is defining constructors in the next lecture."
  },
  {
    "objectID": "index.html#why-hiram",
    "href": "index.html#why-hiram",
    "title": "Hiram: ECE244 Tidy Notes",
    "section": "Why Hiram?",
    "text": "Why Hiram?\nHiram was an arquitect from Tyre (Lebanon), one of the finest back in the day, and who learned how to work the stone from a long tradition of stonecutters’ unions created by skilled workers and led by craftmasters from Egypt.\nBecause Professor Emara titled her notes Snefru and Khufu (C and C++, respectively), I am not the same height to have used Solomon (Hiram’s boss) as the name of these notes. Also, I am like Hiram, and in this class I am learning from a craftmaster from Egypt."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Hiram: ECE244 Tidy Notes",
    "section": "Introduction",
    "text": "Introduction\n\nWhy Hiram?\nProfessor Emara is from Egypt and she is also a master programmer. She titled her notes Snefru and Khufu (C and C++, respectively).\nBecause I am learning from her and I come from Political Science, I am like Hiram, a blacksmith from Tyre (today’s Lebanon) who learned stone masonry from master craftsmen from Egypt.\n\n\nAbout ECE244 - Programming Fundamentals\nThis course provides a foundation in programming using an object-oriented programming language. Topics include classes and objects, inheritance, basic data structures (lists, tree, hash tables, etc.), Big-O complexity analysis, and testing and debugging. The laboratory assignments emphasize the use of object-oriented programming constructs in the design and implementation of reasonably large programs.\n\n\nIn memoriam\nWhile tidying these notes, it was impossible not to go back to the many talks about mathematics with Prof. Luis Armando Dissett Vélez (1963-2021), who always answered my questions about convex separation properties, and I always ended up knowing more than I wanted to know about different theorems of the alternative and connections from calculus to statistics to graph theory. I will always remember him as a great teacher and a great person that truly represented the values of the Pontificia Universidad Católica de Chile.\n\n\nPacha’s notes\n\nThe notes are 100% adjusted to the class.\nIn the snippets folder, I have included some (unofficial) code snippets with the same examples from the notes, that I use to check if the code compiles.\nSome of the examples in the notes have small additions, such as using namespace std; or #include &lt;iostream&gt;, to make them compile.\nThe diagrams are kinda ugly, my apologies! I’m not a graphic designer."
  },
  {
    "objectID": "lecture9.html#summary",
    "href": "lecture9.html#summary",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we introduce classes, access controls: private and public, and initializing data members problem."
  },
  {
    "objectID": "lecture9.html#last-lecture",
    "href": "lecture9.html#last-lecture",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nUsing .fail() and .eof() flags."
  },
  {
    "objectID": "lecture9.html#today",
    "href": "lecture9.html#today",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Today",
    "text": "Today\nIntroduction to classes."
  },
  {
    "objectID": "lecture9.html#demo-of-stringstreams",
    "href": "lecture9.html#demo-of-stringstreams",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Demo of stringstreams",
    "text": "Demo of stringstreams\nAvoid using stream for reading and writing interchangeably. You can write and then read, but it gets confusing when you write again.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added include&lt;iostream&gt; to make cin work. I also changed cout &lt;&lt; ss str(); from the notes to cout &lt;&lt; ss.str();, or it will not compile.\nI also added endl after cout for the same reason as in lecture 8.\n\n\n\n\n\n\n\n\nExample\n\n\n\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int ID;\n    string name, inputLine;\n    getline (cin, inputLine);\n\n    stringstream ss;\n    // write into ss\n    ss &lt;&lt; inputLine;\n\n    // or stringstream ss(inputLine);\n\n    // read from ss\n    ss &gt;&gt; ID; // ID reads 1001\n    ss &gt;&gt; name; // name reads Joe\n\n    cout &lt;&lt; ss.str() &lt;&lt; endl; // ss still has content written to it \"1001 Joe\"\n\n    return 0;\n}\nWhen the user enters “1001 Joe”, what is in ss remains there. Only the reading cursor moves."
  },
  {
    "objectID": "lecture9.html#introduction-to-clases",
    "href": "lecture9.html#introduction-to-clases",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Introduction to clases",
    "text": "Introduction to clases\nRecall structs in C\n\n\n\n\n\n\nExample\n\n\n\nRecall structs in C.\nThis is a data structure that stores data of different types using one variable name.\nstruct Student {\n    string name;\n    int ID;\n}\n\nstruct Student x;\n\n// access name of x using . operator\nx.name = \"Cindy\";\n\n\nA class is an expansion to structs by bringing together data and functions/operations.\nConsider that:\n\nData is similar to structs.\nFunctions/operations are different from structs.\n\nA class is a user-defined data type. A variable of that user-defined data type is called an object.\nDeclaring an object is called creating an instance or instantiation.\nRemember the diagram from lecture 8.\n\nThe definition of a class goes to a header file (e.g. Student.h).\n\nStudent.h\nclass Student {\n    private:\n        int ID;\n        string name;\n\n    public:\n        void setName(string name);\n        void getName();\n        void print();\n};\nRemember the diagram from lecture 8.\n\nprivate members can only be accessed within the class.\npublic members can be accessed outside the class.\nWhy? This is called encapsulation\n\nHide information related to the class (e.g., student ID).\nIt is not available outside the class.\nIt brings related data and functions together.\nIt organizes the code."
  },
  {
    "objectID": "lecture9.html#class-implementation",
    "href": "lecture9.html#class-implementation",
    "title": "Lecture 9 - Sept 26, 2023",
    "section": "Class implementation",
    "text": "Class implementation\nThe class implementation goes in a source file and it has function definitions.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added endl after the cout statements for the same reason as above.\n\n\n\nStudent.cpp\n#include \"Student.h\"\n#include &lt;iostream&gt;\n\n// Setter or mutator function\n\n// class name: Student\n// scope operator: ::\n// function name: setName\nvoid Student::setName(string n) {\n    // private member of Student class can be accessed\n    // inside the class implementation\n    name = n;\n}\n\n// Getter or accessor function\n\nstring Student::getName() {\n    return name;\n}\n\nvoid Student::print() {\n    cout &lt;&lt; \"Student name: \" &lt;&lt; name &lt;&lt; endl;\n    cout &lt;&lt; \"Student ID: \" &lt;&lt; ID &lt;&lt; endl;\n}\n\n\nmain.cpp\nInstatiating and using objects here.\n#include \"Student.h\"\n\nint main() {\n    // declare 2 objects and allocate memory for them\n    Student x,y;\n\n    x.setName(\"Kenya\");\n    y.setName(\"Christina\");\n\n    // x.ID = 2730; gives an error because we cannot access a private member\n\n    // y.name = \"Salma\" same error\n\n    y.print(); // wait! what is the value of ID in Student y?\n\n    return 0;\n}\nIn the line that reads Student x,y, ID in x and y are not initialized.\nThe solution is to define a constructor.\n\n\nStudent.h\nclass Student {\n    private:\n        int ID;\n        string name;\n    \n    public:\n        Student(); // constructor\n        void setName(string name);\n        ...\n}"
  },
  {
    "objectID": "lecture10.html#summary",
    "href": "lecture10.html#summary",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss how can we initialize data members at the time of instantiating an object using constructors. We also introduce, if we have a dynamically allocated memory, how do we free it when an object goes out of scope."
  },
  {
    "objectID": "lecture10.html#last-lecture",
    "href": "lecture10.html#last-lecture",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nIntroduction to classes."
  },
  {
    "objectID": "lecture10.html#today",
    "href": "lecture10.html#today",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Today",
    "text": "Today\nConstructors and destructors."
  },
  {
    "objectID": "lecture10.html#constructors",
    "href": "lecture10.html#constructors",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Constructors",
    "text": "Constructors\n\nConstructors are called by default when an object is instantiated.\nIf you do not implement them, they are empty functions.\nYou cannot call a constructor explicitly. It is only called when you instatiate an object.\nIt’s name is the same as the class name.\nIt has no return or even return type (not void).\n\n\n\n\n\n\n\nExample\n\n\n\n\nStudent.h\nclass Student {\n    private:\n        int ID;\n        string name;\n    public:\n        Student(); // constructor\n        void setName(string n); // setter / mutator\n        string getName(); // getter  accessor\n        void print();\n}\n\n\nStudent.cpp\nStudent::Student() {\n    /// typically used to initialize data members of a class\n    ID = 0;\n    name = \"\";\n}\n\n\nmain.cpp\nint main() {\n    Student x; // calls the constructor\n    Student y[10]; // calls the constructor 10 times\n    Student* z; // no constructor called, no object is instatiated\n}\n\n\n\nWhat if I want to initialize ID with a specific value? We can have multiple constructors/\n\n\n\n\n\n\nExample\n\n\n\n\nStudent.h\nclass Student {\n    private:\n        int ID;\n        string name;\n    public:\n        // multiple constructors\n        // same function name\n        // different arguments\n        // this is called function overloading\n        Student(); // constructor\n        Student(int id);\n        Student(int id, string name);\n        ...\n}\n\n\nStudent.cpp\nStudent::Student() {\n    ID = 0; name = \"\";\n}\n\nStudent::Student(int id) {\n    ID = id; name = \"\";\n}\n\nStudent::Student(int id, string n) {\n    ID = id; name = n;\n}\n\n\nmain.cpp\nStudent x; // default constructor\nStudent y(2307); // second constructor\nStudent z(8731, \"Osiris\"); // third constructor\n\n\n\nThe respective constructors are called depending on the arguments.\nVery important: If the default constructor Student() is not implemented, but Student(int) is implemented, then Student x; will cause an error, as it will call Student() that is not defined.\nWhat if I dynamically allocate memory in an object?\n\nMemory allocated on the heap dynamically has to be explicitly freed. It does not get freed when a variable goes out of scope.\n\n\n\n\n\n\nExample\n\n\n\nfor (int i=0; i &lt; 3; i++) {\n    cout &lt;&lt; i;\n}\nOutside the loop, i does not exist.\n\n\nRecall that in C, for every malloc there has to be a free.\nIn C++, we have new and delete.\n\n\n\n\n\n\nExample\n\n\n\n\nInteger\n// return address of an int variable created at run-time\nint* pNum = new int;\n\n// de-allocate memory at pNum\ndelete pNum;\n\n\nArray\nint* arr = new int[10];\ndelete[] arr;\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nclass Student {\n    private:\n        int* grades;\n    public:\n        Student();\n        Student(int);\n};\n\nStudent::Student() {\n    grades = nullptr;\n}\n\nStudent::Student(int numLabs) {\n    grades = new int[numLabs];\n}\n\nint main() {\n    // dynamically allocates 7 integers\n    // if we do not de-allocate, this creates a memory leak\n    Student x(7);\n}"
  },
  {
    "objectID": "lecture10.html#destructors",
    "href": "lecture10.html#destructors",
    "title": "Lecture 10 - Sept 28, 2023",
    "section": "Destructors",
    "text": "Destructors\nTo solve memory leaks as in the previous example, we can use destructors.\n\n\n\n\n\n\nExample\n\n\n\nclass Student {\n    private:\n        int* grades;\n    public:\n        Student();\n        Student(int);\n        // destructors must be public\n        // a destructor has no return, like constructors\n        // also it has no parameters\n        ~Student();\n};\n\n...\n\nStudent::~Student() {\n    if (grades != nullptr) {\n        delete[] grades;\n    }\n}\n\n\nThe default destructor exists by default, and is called when the object goes out of scope.\nIf you dynamically allocate memory in your class, you will need a destructor to free up this memory space."
  },
  {
    "objectID": "lecture11.html#summary",
    "href": "lecture11.html#summary",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss pointers and introduce if we have a dynamically allocated memory in an object, how do we free it when an object goes out of scope."
  },
  {
    "objectID": "lecture11.html#last-lecture",
    "href": "lecture11.html#last-lecture",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nConstructors."
  },
  {
    "objectID": "lecture11.html#today",
    "href": "lecture11.html#today",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Today",
    "text": "Today\nDestructors, pointers and objects with pointers."
  },
  {
    "objectID": "lecture11.html#memory",
    "href": "lecture11.html#memory",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Memory",
    "text": "Memory\nMemory is divided into cells. Each cell can store a byte of data (8 bits) and has an address.\nA program’s memory space.\n\nA pointer is a variable that stores and address to a byte.\nMemory on stack gets freed when a function returns. All local variables in a function dissappear when the function returns or when they go out of scope.\nBut memory allocated on the heap dynamically has to be explicitly freed. It does not get freed when a variable goes outo f scope. It creates a memory leak if we do not free it.\n\n\n\n\n\n\nExample\n\n\n\nint x;\nint *p;\nx = 7;\np = NULL;\np = &x // address of x\n\ncout &lt;&lt; *p;; // print 7\n\n// dereference p / value at address in p\ncout &lt;&lt; p; // prints 0x124\n\n*p = 5; // change the value of x to 5\n\np = new int; // change address stored in p to a newely allocated memory space\n\n*p = 3; // change value at address 0x560\n\n...\n\n// before exiting our program, we need to return dynamically allocated memory\n// to the operating system\n\ndelete p; // p now has address of expired data\n\np = nullptr; // good practice\n\n\n\nRecall that in C, for every malloc there has to be a free. In C++, we have new add and delete.\n\n\n\n\n\n\nExample\n\n\n\n\nInteger\n// return address of an int variable created at run-time\nint* pNum = new int;\n\n// de-allocate memory at pNum\ndelete pNum;\n\n\nArray\nint* arr = new int[10];\ndelete[] arr;\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nWith a class\nclass Student {\n    private:\n    int *grades; string name;\n    public:\n        Student();\n        Student(int);\n};\n\nStudent::Student() {\n    grades = nullptr;\n}\n\nStudent::Student(int numLabs) {\n    grades = new int[numLabs];\n}\n\nint main() {\n    // dynamically allocates 3 integers\n    Student x(3);\n    return 0;\n\n    // we did not deallocate them\n    // this will create a memory leak!\n}\n\n\n\nThe solution is to define destructors.\nclass Student {\n    private:\n        int *grades; string name;\n    public:\n        Student();\n        Student(int);\n        // the destructor must be public\n        ~Student(); // no return, like constructors\n                    // no parameters\n};\n\n...\n\nStudent::~Student() {\n    if (grades != nullptr) {\n        delete[] grades;\n    }\n}\nThe default destructor exists by default, and is called when the object goes out of scope.\nIf you dynamically allocate memory in your class, you will need a destructor to free up this memory space.\n\nmain.cpp\nint main() {\n    Student x(3); // dynamically allocates 3 integers\n\n    return 0; // destructor of x will be called if grades is !nullptr\n              // we will free dynamically allocated space \n}"
  },
  {
    "objectID": "lecture11.html#exercise-on-double-pointers",
    "href": "lecture11.html#exercise-on-double-pointers",
    "title": "Lecture 11 - Sept 29, 2023",
    "section": "Exercise on double pointers",
    "text": "Exercise on double pointers\nDouble pointers (i.e., pointers to pointers) are variables that store an address too. That address is an address of a pointer.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added the header and put the original example inside main() with an added return 0; at the end, otherwise it would not compile.\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  int** p2p;\n  int *p, *q;\n\n  p = new int;\n  *p = 5;\n\n  p2p = &p;\n  q = *p2p;  // *(&p) = p\n\n  *q = 8;  // the new int\n\n  cout &lt;&lt; **&p2p;  // **(&p) = *p = the new int, prints 8\n\n  return 0;\n}"
  },
  {
    "objectID": "lecture12.html#summary",
    "href": "lecture12.html#summary",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss pointers in objects, destructors and when we need them."
  },
  {
    "objectID": "lecture12.html#last-lecture",
    "href": "lecture12.html#last-lecture",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nMemory organization: stack and heap, pointers, and dynamic memory allocation."
  },
  {
    "objectID": "lecture12.html#today",
    "href": "lecture12.html#today",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Today",
    "text": "Today\nDestructors and pointers in objects."
  },
  {
    "objectID": "lecture12.html#dynamically-allocated-memory",
    "href": "lecture12.html#dynamically-allocated-memory",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Dynamically allocated memory",
    "text": "Dynamically allocated memory\nThe problem when if we dynamically allocate memory in a class is to have a memory leak.\n\n\n\n\n\n\nExample\n\n\n\nclass Student {\n    private:\n        int *grades; string name;\n    public:\n        Student();\n        Student(int);\n};\n\nStudent::Student() {\n    grades = nullptr;\n}\n\nStudent::Student(int numLabs) {\n    grades = new int[numLabs];\n}\n\nint main() {\n    // dynamically allocates 3 integers\n    Student x(3);\n    return 0;\n\n    // we did not deallocate them\n    // this will create a memory leak!\n}\n\n\n\nThe solution is in defining destructors.\n\n\n\n\n\n\nExample\n\n\n\nclass Student {\n    :\n        int *grades; string name;\n    public:\n        Student();\n        Student(iprivatent);\n        // the destructor must be public\n        ~Student(); // no return, like constructors\n                    // no parameters\n};\n\n...\n\nStudent::~Student() {\n    if (grades != nullptr) {\n        delete[] grades;\n    }\n}\n\n\nThe default destructor exists by default, and is called when the object goes out of scope.\nIf you dynamically allocate memory in your class, you will need a destructor to free up this memory space.\n\n\n\n\n\n\nExample\n\n\n\n// main.cpp\n\nint main() {\n    Student x(3);\n    return 0;\n}\nThe destructor of x will be called by default at the end of main. If grades is !nullptr, we will free dynamically allocated space."
  },
  {
    "objectID": "lecture12.html#pointers-to-objects",
    "href": "lecture12.html#pointers-to-objects",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Pointers to objects",
    "text": "Pointers to objects\nCan pointers point to objects? Yes!\n\n\n\n\n\n\nExample\n\n\n\nUse case to dynamically allocate memory for an object on the heap.\nclass ComplexNum {\n    double real;\n    double img;\n    ComplexNum(double r, double i) { real = r; img = i; }\n};\n\nint main() {\n    ComplexNum, x(3,4);\n    x.real = 2;\n    ComplexNum *p;\n    p = &x;\n\n    // -&gt;: access member at address stored in p\n    p-&gt;real = 7;\n\n    // or  de-reference p then use .\n    // (*p).real = 7;\n}"
  },
  {
    "objectID": "lecture12.html#pointers-to-objects-in-objects",
    "href": "lecture12.html#pointers-to-objects-in-objects",
    "title": "Lecture 12 - Oct 3, 2023",
    "section": "Pointers to objects in objects",
    "text": "Pointers to objects in objects\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added return 0; to the main function, otherwise it would not compile.\n\n\nclass ComplexNum {\n public:\n  double real;\n  double img;\n  ComplexNum* next;\n\n  ComplexNum() {\n    real = 0;\n    img = 0;\n    next = nullptr;\n  }\n\n  ~ComplexNum() {\n    if (next != nullptr) delete next;\n  }\n};\n\nint main() {\n    ComplexNum* px = new ComplexNum; // 1\n  px-&gt;next = new ComplexNum; // 2\n  px-&gt;next-&gt;real = 8; // 3\n  delete px; // calls the destructor\n             // frees up memory that p is pointing to\n  return 0;\n}\n\nWhat about next in p?\n\ndelete px calls destructor on A.\nThen delete next of A, which is B.\nThen calls destructor on B , next is null."
  },
  {
    "objectID": "lecture8.html#ungraded-homework",
    "href": "lecture8.html#ungraded-homework",
    "title": "Lecture 8 - Sept 22, 2023",
    "section": "Ungraded homework",
    "text": "Ungraded homework\nSolve the exercises of Chapter 2: C++ I/O\n\n\n\n\n\n\nExercise 1\n\n\n\nQuestion 5 in Fall 2022 Midterm Exam [Easy]\nConsider the following program.\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a;\n    ifstream inFile;\n    inFile.open(\"input.txt\");\n    if (inFile.fail()) {\n        return 1;\n    }\n    while (1) {\n        inFile &gt;&gt; a;\n        if (inFile.fail()) {\n            cout &lt;&lt; \"failed..\" &lt;&lt; endl;\n            inFile.clear();\n            inFile.ignore(100, '\\n');\n            continue;\n        }\n        cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n        break;\n    }\n    return 0;\n}\nGiven the following contents of “input.txt”, write the output.\nCase 1:\n1\n2\n3\nCase 2:\na32\nb86\n3\nCase 3:\na32\nb86 3\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nCase 1\na = 1\nExplanation:\n\nThe while (1) loop is an infinite loop that will continue until it’s explicitly broken.\nIf the file reading operation is successful, the program outputs the value of a to the console and then breaks out of the loop with break;.\n\nCase 2\nfailed..\nfailed..\na = 3\nExplanation:\n\nThe while(1) loop will continue until it’s explicitly broken.\nThe first two cases fail, because the program read a non-integer value.\n\nCase 3\nfailed..\nfailed..\n...\ninfinite output\nExplanation:\n\nThe while(1) loop will continue until it’s explicitly broken.\nIt fails for the first two lines and then the loop continues.\n\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nNow you remove the infile.clear() from the code, so the program becomes:\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a;\n    ifstream inFile;\n    inFile.open(\"input.txt\");\n    if (inFile.fail()) {\n        return 1;\n    }\n    while (1) {\n        inFile &gt;&gt; a;\n        if (inFile.fail()) {\n            cout &lt;&lt; \"failed..\" &lt;&lt; endl;\n            // inFile.clear(); // COMMENTED OUT\n            inFile.ignore(100, '\\n');\n            continue;\n        }\n        cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n        break;\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nCase 1\na = 1\nCase 2\nfailed..\nfailed..\n...\ninfinite output\nExplanation:\n\nThe input stream is not cleared, so the program will continue to read the same non-integer value.\n\nCase 3\nfailed..\nfailed..\n...\ninfinite output\nExplanation:\n\nSame as case 2.\n\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nQuestion 2 in Fall 2021 Final Exam [Intermediate]\nWrite a C++ function void readInts() that repeatedly reads integers from the standard input (using cin) and then immediately outputs the input integer (using cout), one integer per line. When a '.' character is encountered, the function prints the message Done on a line by itself and returns. If the user enters any characters other than integer digits or the '.', the function prints the message Error on a line by itself and returns. You may assume the user will never enter eof.\nThus, for example, if the user enters 51 16 700 ., the function prints:\n51\n16\n700\nDone\nHowever, if the user enters 101 21 13 abc 444, the function prints:\n101\n21\n13\nError\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nvoid readInts() {\n        int num;\n        cin &gt;&gt; num;\n\n        while (!cin.fail()) {\n                cout &lt;&lt; num &lt;&lt; endl;\n                cin &gt;&gt; num;\n        }\n\n        cin.clear();\n\n        string chr;\n        cin &gt;&gt; chr;\n\n        if (chr == \".\") {\n                cout &lt;&lt; \"Done\" &lt;&lt; endl;\n        } else {\n            cout &lt;&lt; \"Error\" &lt;&lt; endl;\n        }\n}\n\nint main() {\n        readInts();\n        return 0;\n}\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nQuestion 3 in Fall 2018 Midterm Exam [Intermediate]\nConsider the following program that uses stringstreams to read a command. The command has the following format:\ncount intArg\nThe command word is count and intArg is an integer argument. The command must have only one integer argument, e.g count 3.\nThe function handle_count performs the reading of the integer value. If the integer is valid, it returns true and updates the value of intArg. Otherwise, it returns false.\n#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n// function prototype\nbool handle_count( &lt;fill in the blank&gt; );\n\nint main() {\n    string line;\n    string command;\n    int intArg;\n    getline(cin, line);\n    stringstream lineStream(line);\n    lineStream &gt;&gt; command;\n    if (command == \"count\") {\n        if (handle_count( &lt;fill in the blank&gt; )) {\n            cout &lt;&lt; \"Integer argument is \" &lt;&lt; intArg &lt;&lt; endl;\n            return (0);\n        } else {\n            cout &lt;&lt; \"Invalid arguments\" &lt;&lt; endl;\n            return (-1);\n        }\n    } else {\n        cout &lt;&lt; \"Invalid command\" &lt;&lt; endl;\n        return (-1);\n    }\n}\n\nDetermine the number of arguments and the type of each argument and indicate them in the code above in the prototype of the function, handle_count. Further, indicate what parameters are passed to the function when it is invoked. Write your answers where indicated in the code above. You may not modify main by adding or removing line, other than by indicating the formal arguments in the function prototype and actual arguments of the function invocation.\nWrite the header and body of the handle_count function below so it performs as indicated above.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPart 1\nWe need two arguments, a stringstream (lineStream) and an int (intArg).\n#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n// function prototype\nbool handle_count(stringstream& lineStream, int& intArg);\n\nint main() {\n    string line;\n    string command;\n    int intArg;\n    getline(cin, line);\n    stringstream lineStream(line);\n    lineStream &gt;&gt; command;\n    if (command == \"count\") {\n        if (handle_count(lineStream, intArg)) {\n            cout &lt;&lt; \"Integer argument is \" &lt;&lt; intArg &lt;&lt; endl;\n            return (0);\n        } else {\n            cout &lt;&lt; \"Invalid arguments\" &lt;&lt; endl;\n            return (-1);\n        }\n    } else {\n        cout &lt;&lt; \"Invalid command\" &lt;&lt; endl;\n        return (-1);\n    }\n}\nPart 2\n#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n// function prototype\nbool handle_count(stringstream& lineStream, int& intArg);\n\nint main() {\n    string line;\n    string command;\n    int intArg;\n    getline(cin, line);\n    stringstream lineStream(line);\n    lineStream &gt;&gt; command;\n    if (command == \"count\") {\n        if (handle_count(lineStream, intArg)) {\n            cout &lt;&lt; \"Integer argument is \" &lt;&lt; intArg &lt;&lt; endl;\n            return (0);\n        } else {\n            cout &lt;&lt; \"Invalid arguments\" &lt;&lt; endl;\n            return (-1);\n        }\n    } else {\n        cout &lt;&lt; \"Invalid command\" &lt;&lt; endl;\n        return (-1);\n    }\n}\n\nbool handle_count(stringstream& line, int& intArg) {\n    line &gt;&gt; intArg;\n\n    if (line.fail()) {\n        return false;\n    }\n\n    string dummy;\n    line &gt;&gt; dummy;\n\n    if (line.fail()) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n\n\n\n\n\n\n\nExercise 5\n\n\n\nQuestion 6 in Fall 2019 Midterm Exam [Intermediate]\nFor each of the following main functions, indicate the output produced in response to the user entering 1 2 3 4 five on the keyboard followed by the Enter key. Choose only one answer.\nPart 1\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int num = 0;\n    int sum = 0;\n    while (!cin.fail()) {\n        cin &gt;&gt; num;\n        sum = sum + num;\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n    return (0);\n}\n\n6\n10\n14\nNone; the program runs in an infinite loop\n\nPart 2\n#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int num = 0;\n    int sum = 0;\n    bool more = true;\n    while (more) {\n        cin &gt;&gt; num;\n        if (cin.fail())\n            more = false;\n        else\n            sum = sum + num;\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n    return (0);\n}\n\n6\n10\n14\nNone; the program runs in an infinite loop\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPart 1\nResult: 10 or 14. In some compilers num will be unchanged and will be added to the sum again.\nPart 2\nResult: 10. more will be set to false after the first non-integer input.\n\n\n\n\n\n\n\n\n\nExercise 6\n\n\n\nQuestion 7 in Fall 2019 Midterm Exam [Intermediate]\nWrite a C++ function void readInts() that repeatedly reads integers from the standard input (using cin) and then immediately outputs the input integer (using cout), one integer per line.\nWhen the end-of-file is reached, the function prints the message “End of File Reached” on a line by itself before returning. If a non-integer is input the function should print the message “Invalid Input” on a line by itself, should discard the rest of the stream and should continue reading integers again until the end-of-file is reached.\n\n\n::: {.callout-note icon=false collapse=“true”} ## Solution\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid readInts() {\n    // pass number from cin\n    int num;\n    cin &gt;&gt; num;\n\n    // print until end of file\n    while (!cin.eof()) {\n        if (cin.fail()) {\n            cin.clear();\n            cin.ignore(1000, '\\n');\n            cout &lt;&lt; \"Invalid Input\" &lt;&lt; endl;\n            cin &gt;&gt; num;\n        } else {\n            cout &lt;&lt; num &lt;&lt; endl;\n            cin &gt;&gt; num;\n        }\n    }\n    cout &lt;&lt; \"End of File Reached\" &lt;&lt; endl;\n}\n\nint main() {\n    readInts();\n    return 0;\n}"
  },
  {
    "objectID": "lecture13.html#summary",
    "href": "lecture13.html#summary",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss dynamic memory allocation of arrays (of objects and of pointers to objects)."
  },
  {
    "objectID": "lecture13.html#last-lecture",
    "href": "lecture13.html#last-lecture",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nDestructors."
  },
  {
    "objectID": "lecture13.html#today",
    "href": "lecture13.html#today",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Today",
    "text": "Today\nDynamic memory allocation of arrays of objects and pointers to objects."
  },
  {
    "objectID": "lecture13.html#double-pointers",
    "href": "lecture13.html#double-pointers",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Double pointers",
    "text": "Double pointers\nDouble pointers are variables that store an address to a pointer.\n\n\n\n\n\n\nExample\n\n\n\nint** p2p;\nint *p, *q;\n\np = new int;\n*p = 5;\np2p = &p;\nq = *p2p; // *(&p) = p\n*q = 8; // the new int\n\ncout &lt;&lt; **p2p &lt;&lt; endl; // **(&p) = *p = the new int = 8\n\ndelete p; // frees up space pointed to by p\ndelete q; // double free\ndelete *p2p; // triple free\nRemember the diagram from lecture 11."
  },
  {
    "objectID": "lecture13.html#dynamic-memory-allocation-of-arrays",
    "href": "lecture13.html#dynamic-memory-allocation-of-arrays",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Dynamic memory allocation of arrays",
    "text": "Dynamic memory allocation of arrays\n\nint a[4] = {1,2,3,4}\na is an alias/nickname that has address to the first element in the array.\na      &lt;-&gt; &a[0]\n*a     &lt;-&gt; a[0\n*(a+1) &lt;-&gt; a[1]\nThere are different ways to have an array that stores data.\n\nFixed-size array\nint arr[4]; // fixed number\nThis will be allocated on the stack.\n\n\nVariable-size array\nint size;\ncin &gt;&gt; size;\nint arr[size]; // variable number\nThis will be allocated on the stack too.\n\n\nDynamically allocate memory for the array\nint size = 7;\nint* arr = new int[size]; // dynamically allocate memory\nThis array will be allocated on the heap.\nAdvice: The programmer can “control” the lifetime of the array in the memory by freeing the memory anytime with delete.\n\n\n\n\n\n\nExample\n\n\n\ndelete [] arr;\narr = NULL;\n\n\nCan we dynamically allocate an array of pointers to integers? Yes.\n\nint** arr2p = new int*[4];\n\nfor (int i = 0; i &lt; 4; i++) {\n    arr2p[i] = new int;\n}\n\nfor (int i = 0; i &lt; 4; i++) {\n    *arr2p[i] = i + 1;\n}\n\nfor (int i = 0; i &lt; 4; i++) {\n    delete arr2p[i];\n    arr2p[i] = NULL;\n}\n\ndelete [] arr2p;\narr2p = NULL; // arr2p -&gt; NULL\nCan we dynamically allocate an array of objects? Yes.\nclass Student {\n    public:\n        string name;\n        int ID;\n        Student() { ID = 0; name = \"\"; }\n        ~Student() { cout &lt;&lt; \"Destructor\" &lt;&lt; endl; }\n}\n\nint main() {\n    // Default constructor called 3 times\n    Student* arr = new Student[3];\n    \n    // Destructor called 3 times\n    // no destructor will be called without delete\n    delete [] arr;\n    arr = NULL;\n\n    return 0;\n}\nCan I have an array of pointers to objects? Yes\n\nint main() {\n    // no constructors called\n    Student** arr2p = new Student*[3];\n\n...\n\n...\n\n    for (int i = 0; i &lt; 3; i++) {\n        arr2p[i] = new Student;\n    }\n\n...\n\n...\n\n    for (int i = 0; i &lt; 3; i++) { \n        arr2p[i]-&gt;ID = i + 1;\n    }\n...\n\n...\n\n    for (int i = 0; i &lt; 3; i++) { \n        delete arr2p[i];\n    }\n\n...\n\n...\n\n    delete [] arr2p;\n    arr2p = NULL;\n}"
  },
  {
    "objectID": "lecture13.html#recap-on-memory-management-issues",
    "href": "lecture13.html#recap-on-memory-management-issues",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Recap on Memory Management Issues",
    "text": "Recap on Memory Management Issues\n\nLosing access to a dynamically allocated space\nint *p = new int;\n*p = 100;\np = new int; // memory leak\n\nSolution: Have a delete before making p point to a new memory space.\nint *p = new int;\n*p = 100;\ndelete p;\np = new int;\n\n\nAccess a freed memory space\nint *p = new int;\n*p = 100;\ndelete p;\n*p = 3; // challenging to debug\nSolution: It is a good practice to set the pointer to NULL or nullptr after delete.\n\n\nDereference an undefined pointer\nint *p;\nint y;\ny = *p; // p has garbage address\n                // defeferencing will access a garbage address\n\n\nDouble free\nint *p = new int;\ndelete p;\n...\ndelete p; // double free\n\n\nDelete a variable stored on the stack\nint x = 4;\nint *p;\np = &x;\ndelete p; // x is on stack, you can't delete it\n\n\nType mismatch assignment\nint** &lt;- int*,\nint* &lt;- int**,\nint** &lt;- int,\nint* &lt;- int\nint *p, *q;\nint **pp;\n\n// pp: int**\n// p: int*\npp = p; // type mismatch int** &lt;- int*\n\n// *p: p\npp = *p; // type mismatch int** &lt;- int\n\np = pp; // type mismatch int* &lt;- int**"
  },
  {
    "objectID": "lecture13.html#read-at-home-recap-on-memory-management-issues",
    "href": "lecture13.html#read-at-home-recap-on-memory-management-issues",
    "title": "Lecture 13 - Oct 5, 2023",
    "section": "Read at home: Recap on Memory Management Issues",
    "text": "Read at home: Recap on Memory Management Issues\n\nLosing access to a dynamically allocated space\nint *p = new int;\n*p = 100;\np = new int; // memory leak\n\nSolution: Have a delete before making p point to a new memory space.\nint *p = new int;\n*p = 100;\ndelete p;\np = new int;\n\n\nAccess a freed memory space\nint *p = new int;\n*p = 100;\ndelete p;\n*p = 3; // challenging to debug\nSolution: It is a good practice to set the pointer to NULL or nullptr after delete.\n\n\nDereference an undefined pointer\nint *p;\nint y;\ny = *p; // p has garbage address\n                // defeferencing will access a garbage address\n\n\nDouble free\nint *p = new int;\ndelete p;\n...\ndelete p; // double free\n\n\nDelete a variable stored on the stack\nint x = 4;\nint *p;\np = &x;\ndelete p; // x is on stack, you can't delete it\n\n\nType mismatch assignment\nint** &lt;- int*,\nint* &lt;- int**,\nint** &lt;- int,\nint* &lt;- int\nint *p, *q;\nint **pp;\n\n// pp: int**\n// p: int*\npp = p; // type mismatch int** &lt;- int*\n\n// *p: p\npp = *p; // type mismatch int** &lt;- int\n\np = pp; // type mismatch int* &lt;- int**"
  },
  {
    "objectID": "lecture14.html#summary",
    "href": "lecture14.html#summary",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we continue on our discussion of dynamic memory allocation of arrays of objects. We also introduce the concept of operator overloading."
  },
  {
    "objectID": "lecture14.html#last-lecture",
    "href": "lecture14.html#last-lecture",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nDynamic memory allocation of arrays."
  },
  {
    "objectID": "lecture14.html#today",
    "href": "lecture14.html#today",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Today",
    "text": "Today\nContinue dynamic memory allocation of objects and operator overloading."
  },
  {
    "objectID": "lecture14.html#dynamic-allocation",
    "href": "lecture14.html#dynamic-allocation",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Dynamic allocation",
    "text": "Dynamic allocation\nCan we dynamically allocate an array of objects? Yes\nclass Student {\n    public:\n        string name;\n        int ID;\n        Student() { ID = 0; name = \"\"; }\n        ~Student() { cout &lt;&lt; \"Destructor\" &lt;&lt; endl; }\n};\n\nint main() {\n    Student *arr = new Student[3]; // default constructor called 3 times\n    delete [] arr; // destructor called 3 times\n    return 0; // no destructor will be called without delete\n}\nCan I have an array of pointers to objects? Yes\n\nint main() {\n    // no constructors called\n    Student** arr2p = new Student* [3];\n\n...\n\n...\n\nfor (int i = 0, i &lt; 3; i++) {\n    arr2p[i] = new Student;\n}\n\n...\n\n...\n\nfor (int i = 0, i &lt; 3; i++) {\n    arr2p[i]-&gt;ID = i + 1;\n}\n\n...\n\n...\n\nfor (int i = 0, i &lt; 3; i++) {\n    delete arr2p[i];\n}\n\n...\n\n...\n\ndelete [] arr2p;\narr2p = NULL;"
  },
  {
    "objectID": "lecture14.html#overloading-operators--",
    "href": "lecture14.html#overloading-operators--",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Overloading operators (+, -, *, /)",
    "text": "Overloading operators (+, -, *, /)\nConsider this class\nclass Complex {\n    private:\n        double real;\n        double img;\n    public:\n        Complex() { real = 0.0; img = 0.0; }\n        Complex(double r, double i) { real = r; img = i; }\n};\n\nint main() {\n    Complex x(3,4);\n    Complex y(5,6);\n    Complex z;\n    z = x + y; // I can't do this now\n    return 0;\n}\nOperator overloading allows for z = x + y.\nThere are two operators: = and +.\nLet’s implement a function that does an addition.\nx + y is also equivalent to x.operator+(y).\n// return type: Complex\n// function name: operator+\nComplex Complex::operator+(Complex &rhs) {\n    return Complex(real + rhs.real, img + rhs.img);\n}\n\nclass Complex P{\n    private:\n        double real;\n        double img;\n    public:\n        Complex() { real = 0.0; img = 0.0; }\n        Complex(double r, double i) { real = r; img = i; }\n        // pass by reference: Complex&\n        Complex operator+(Complex& rhs);\n}\nPassing by value will create a copy of the rhs.\nThis is memory inefficient if the object has many data members.\nPass by value will not create a copy, so it is memory efficient.\n\nGood practices for safety\n\nPass the object as a constant object\nComplex Complex::operator+(const Complex& rhs) {\n    rhs.real = 0; // compile-time error!\n    return Complex(real + rhs.real, img + rhs.img);\n}\n\n\n\n\n\n\nPacha’s note\n\n\n\nInside the function, the line rhs.real = 0; attempts to modify the real member of rhs. Because rhs is a constant reference, it cannot be modified. This is why the comment indicates a compile-time error. The compiler will not allow this code to compile because it violates the const-correctness rule.\n\n\n\n\nOperator+ does not change members of the object\nUse const modifier to prevent changes to members of the object.\nComplex Complex::operator+(const Complex& rhs) const {\n    real = 0; // compile-time error!\n    return Complex(real + rhs.real, img + rhs.img);\n}"
  },
  {
    "objectID": "lecture14.html#ungraded-homework",
    "href": "lecture14.html#ungraded-homework",
    "title": "Lecture 14 - Oct 6, 2023",
    "section": "Ungraded homework",
    "text": "Ungraded homework\nSolve the exercises of Chapter 4: Pointers and Chapter 5: Dynamic Memory Allocation.\n\nChapter 4\n\n\n\n\n\n\nExercise 1\n\n\n\nQuestion 9 in Fall 2022 Midterm Exam [Intermediate]\nWrite down the standard output of the following program. Remember to write two “Check Point”, since partial marks are given based on these “stop points”. You might find it helpful to write down the memory layout.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint i[5] = {0, 2, 4, 6, 8};\nint* p;\n\nvoid foo() {\n  cout &lt;&lt; *p &lt;&lt; endl;\n  ++(*p);\n  ++p;\n}\n\nvoid bar() {\n  for (int i = 0; i &lt; 3; ++i) {\n    foo();\n  }\n}\n\nint main() {\n  p = i;\n  bar();\n  cout &lt;&lt; \"Check Point 1\" &lt;&lt; endl;\n  p = i;\n  foo();\n  cout &lt;&lt; \"Check Point 2\" &lt;&lt; endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn main(), bar() calls foo().\nIn foo():\n\ncout &lt;&lt; *p &lt;&lt; endl is used to output the value pointed to by p. The * operator is used to dereference the pointer, i.e., to get the value that p is pointing to.\nNext, ++(*p) is executed. This line increments the value pointed to by p. The parentheses are necessary because the ++ operator has a higher priority than the * operator. Without the parentheses, p would be incremented before its value is retrieved.\nFinally, ++p increments the pointer p itself, not the value it points to, and p now points to the next memory location.\nThis will print 0 2 4 before the first checkpoint.\n\nIn main(), foo() will print i[0], which was incremented to 1, before the second checkpoint.\nThe output is:\n0\n2\n4\nCheck Point 1\n1\nCheck Point 2\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nQuestion 3 in Fall 2021 Final Exam [Intermediate]\nConsider the following code snippet that manipulates pointers in a main function of a C++ program.\nint* p = nullptr;\nint* q = nullptr;\nint* r = nullptr;\nint** t = &p;\nint** s = &q;\nr = p;\np = new int;\nq = new int;\n*p = 5;\n*q = 2;\n**s = *p + **t;\nWhich of the following statements (that come after the above snippets executes) prints 5 to the standard output? You may assume iostream is included and the std namespace is used. Choose all correct answers.\ncout &lt;&lt; r;\ncout &lt;&lt; *t;\ncout &lt;&lt; *q;\ncout &lt;&lt; *p;\ncout &lt;&lt; **t;\ncout &lt;&lt; *r;\ncout &lt;&lt; *s;\ncout &lt;&lt; (**s) / 2;\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nt and s are pointers to pointers.\nr is a nullptr.\np and q point to memory for integers on the heap, these values are set to 5 and 2.\n**s is equal to 10, it adds the values pointed by p and t (t is equal to p).\n**s points to the memory location pointed by q.\nWe can pass the snippet to a function:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  int* p = nullptr;\n  int* q = nullptr;\n  int* r = nullptr;\n  int** t = &p;\n  int** s = &q;\n  r = p;\n  p = new int;\n  q = new int;\n  *p = 5;\n  *q = 2;\n  **s = *p + **t;\n\n  cout &lt;&lt; \"r \" &lt;&lt; r &lt;&lt; endl;\n  cout &lt;&lt; \"*t \" &lt;&lt; *t &lt;&lt; endl;\n  cout &lt;&lt; \"*q \" &lt;&lt; *q &lt;&lt; endl;\n  cout &lt;&lt; \"*p \" &lt;&lt; *p &lt;&lt; endl;\n  cout &lt;&lt; \"**t \" &lt;&lt; **t &lt;&lt; endl;\n  // cout &lt;&lt; \"*r \" &lt;&lt; *r &lt;&lt; endl; // segmentation fault\n  cout &lt;&lt; \"*s \" &lt;&lt; *s &lt;&lt; endl;\n  cout &lt;&lt; \"(**s) / 2 \" &lt;&lt; (**s) / 2 &lt;&lt; endl;\n\n  return 0;\n}\nThe output is:\nr 0\n*t 0x55e631f6ceb0\n*q 10\n*p 5\n**t 5\n*s 0x55e631f6ced0\nThe statements that print 5 are:\ncout &lt;&lt; *p;\ncout &lt;&lt; **t;\ncout &lt;&lt; (**s) / 2;\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nQuestion 4 in Fall 2018 Midterm Exam [Intermediate]\nConsider the following main function. The line numbers to the left are for reference and are not part of the code.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  int* first_ptr;\n  int* second_ptr;\n  int** p_ptr;\n  first_ptr = new int;\n  second_ptr = new int;\n  p_ptr = &first_ptr;\n  *first_ptr = 4;\n  *second_ptr = 8;\n  second_ptr = *p_ptr;\n  cout &lt;&lt; *first_ptr &lt;&lt; \" \" &lt;&lt; *second_ptr &lt;&lt; endl;\n  delete first_ptr;\n  delete second_ptr;\n  delete *p_ptr;\n  return (0);\n}\n\nWhat is the output produced by cout on line 14 of the code.\nThe program may have a problem with it. What is the problem, if any? Circle only one answer.\nThe program has no problem with it. 2. The program has a memory leak. 3. The delete on line 17 should not dereference p_ptr, but use it directly. 4. The program deletes the same region of memory more than once. 5. 2 and 3. 6. 2 and 4. 7. 2, 3 and 4.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe output is 4 4.\nThere is a memory leak, second_ptr = *p_ptr was called without freeing the memory it was pointing to. first_ptr and second_ptr point to the same memory location, so delete first_ptr and delete second_ptr are equivalent. delete *p_ptr is equivalent to delete first_ptr and delete second_ptr. Therefore, 2, 3 and 4 are correct.\n\nThe correct code would be:\nint main() {\n  ...\n  delete first_ptr;\n  first_ptr = nullptr;\n    second_ptr = nullptr;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nQuestion 2 in Fall 2017 Midterm Exam [Intermediate]\nConsider the following program.\nclass Point {\n  int x;\n  int y;\n\n public:\n  Point(int i, int j);\n  Point increment_x();\n  Point increment_y();\n  void print() const;\n};\n\nPoint::Point(int i, int j) {\n  x = i;\n  y = j;\n}\n\nPoint Point::increment_x() {\n  ++x;\n  return *this;\n}\n\nPoint Point::increment_y() {\n  ++y;\n  return *this;\n}\n\nvoid Point::print() const {\n  cout &lt;&lt; \"(\" &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; endl;\n}\n\nint main() {\n  Point a(2, 3);\n  // Evaluation is done left to right\n  a.increment_x().increment_y().print();\n  a.print();\n  return 0;\n}\nAssuming the C++ compiler does not optimize away copying of objects. Write the output produced by the program.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nthis is a pointer to the object itself.\nincrement_x() would increase the value of x by 1 and return a copy of the original object.\nincrement_y() would increase the value of y by 1 on the copy of the object returned by increment_x().\na.increment_x().increment_y().print() returns (3, 4) and only the change to x was permanent.\na.print() returns (3, 3).\n\n\n\n\n\nChapter 5\n\n\n\n\n\n\nExercise 1\n\n\n\nQuestion 3 in Fall 2022 Midterm Exam [Easy]\nConsider the following C++ function:\nvoid AvadaKedavra(int n) {\n  int size = n + 1;\n  int* q = NULL;\n  for (int i = 0; i &lt; 3; ++i) {\n    q = new int[size];\n  }\n}\nIf somewhere in your main function you call AvadaKedavra(1). Based on the memory layout discussed during the lecture, answer this question: from the time this function starts to execute to the time right before it returns, how many bytes are newly allocated on the stack and the heap, respectively?\nYou may assume:\n\nAll variables are put in the main memory.\nAn int takes 4 bytes.\nWe have a 32-bit machine.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nStack 4 bytes for n, 4 bytes for size, 4 bytes for q, 4 bytes for i. Total: 16 bytes.\nHeap 4 bytes for each q, 3 times, and each q consists in 2 integers. Total: 24 bytes.\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nQuestion 9 in Fall 2021 Midterm Exam [Intermediate]\nConsider the code shown below. You can assume it compiles with no errors and runs.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint a = 0;\nint* b = &a;\nint** c = &b;\n\nint* foo(int** d) {\n  (**d)++;\n  b = *d;\n  int* e = new int;\n  *e = 10;\n  return e;\n}\n\nint main() {\n  int* g = nullptr;\n  int* f = new int;\n  *f = 5;\n  a++;\n\n  // Point 1\n\n  g = foo(&f);\n  a++;\n  (*g)++;\n\n  // Point 2\n\n  return 0;\n}\nIn the table below, give the values of the variables indicated in the table columns when program execution reaches each of the two points, Point 1 and Point 2. If a value cannot be obtained due to dereferencing a nullptr pointer, write nullptr (but assume the program does not stop).\n\n|         | a | *b | **c | *g | *f |\n|---------|---|----|-----|----|----|\n| Point 1 |   |    |     |    |    |\n| Point 2 |   |    |     |    |    |\n:::\n\n::: {.callout-note icon=false collapse=\"true\"}\n## Solution\n\n|         | a | *b | **c | *g      | *f |\n|---------|---|----|-----|---------|----|\n| Point 1 | 1 | 1  | 1   | nullptr | 5  |\n| Point 2 | 2 | 6  | 6   | 11      | 6  |\n:::\n\n::: {.callout-note icon=false}\n## Exercise 3\n\nQuestion 10 in Fall 2022 Midterm Exam [Challenging]\n\nA Vtuber is an online entertainer who posts videos on Vtube. A Vtuber will have\nfollowers on Vtube. As a programmer from Vtube, you are asked to implement a\nclass for Vtuber. The class definition and description are described below.\n\n```cpp\n#include &lt;string&gt;\nusing namespace std;\n\nclass Follower {\n private:\n  string name;\n  int age;\n\n public:\n  Follower(const string& _name, int _age) {\n    name = name_;\n    age = age_;\n  }\n  string get_name() const { return name; }\n  int get_age() const { return age; }\n};\n\nclass Vtuber {\n private:\n  // Vtuber Name\n  string name;\n  // Follower array with a variable size, each element should be a dynamically\n  // allocated object of class Follower.\n  Follower** followers;\n  // The size of follower array.\n  int follower_max;\n  // Number of followers\n  int follower_num;\n\n public:\n  Vtuber(const string& _name);\n  ~Vtuber();\n  void insert_follower(const string& follower_name, int follower_age);\n  void remove_follower(const string& follower_name);\n};\nSpecifically, Vtuber’s followers member variable is an array of pointers, each pointer pointing to a Follower object. The following graph illustrates it.\n\nPart 1\nImplement the constructor for Vtuber. Vtuber name should be initialized by _name, and follower_max should be initialized to 2. In addition, you should allocate an array called followers using new, with an initial size of 2 (the value of follower_max). Every element in this array should be a pointer to an object of class Follower and initialize all these pointers to NULL.\nPart 2\nEvery Vtuber in Vtube can get new followers or lose their current followers. This is implemented by two methods: insert_follower and remove_follower. Now you are asked to implement these two methods:\n\nFor remove_follower, a follower name is given. If there is any follower in the array matching the name, you should remove it and free its memory using delete. You can assume the follower names are all unique.\nFor remove_follower, a follower name is given. If there is any follower in the array matching the name, you should remove it and free its memory using delete. You can assume the follower names are all unique.\n\nPart 3\nImplement the destructor for the Vtuber class. You should free all the dynamically allocated objects using delete. Remember to be consistent with your previous implementation, as the entire program should not trigger any segmentation fault.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nPart 1\nVtuber::Vtuber (const string& _name) {\n  name = _name;\n  follower_max = 2;\n  followers = new Follower* [follower_max];\n  for (int i = 0; i &lt; follower_max; ++i) {\n    followers[i] = NULL;\n  }\n}\nPart 2\nvoid Vtuber::insert_follower(const string& follower_name,\nint follower_age) {\n  ++follower_num;\n  for (int i = 0; i &lt; follower_max; ++i) {\n    if (followers[i] == NULL) {\n      followers[i] = new Follower(follower_name, follower_age);\n      return;\n    }\n  }\n  Follower** new_followers = new Follower* [follower_max * 2];\n  for (int i = 0; i &lt; follower_max; ++i) {\n    new_followers[i] = followers[i];\n    new_followers[i + follower_max] = NULL;\n  }\n  new_followers[follower_max] = new Follower(follower_name, follower_age);\n  delete [] followers;\n  followers = new_followers;\n  follower_max *= 2;\n  return;\n}\nvoid Vtuber::remove_follower(const string& follower_name) {\n for (int i = 0; i &lt; follower_max; ++i) {\n   if (followers[i] == NULL) {\n      continue;\n   }\n   if (followers[i]-&gt;get_name() == follower_name) {\n     delete followers[i];\n     followers[i] = NULL;\n     --follower_num;\n     break;\n   }\n  }\n  return;  \n}\nPart 3\nVtuber::~Vtuber() {\n  for (int i = 0; i &lt; follower_max; ++i) {\n    if (followers[i] != NULL) {\n      delete followers[i];\n      followers[i] = nullptr;\n    }\n  }\n  delete [] followers;\n  followers = nullptr;\n}"
  },
  {
    "objectID": "lecture15.html#summary",
    "href": "lecture15.html#summary",
    "title": "Lecture 15 - Oct 10, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we continue our discussion on operator overloading. We also discuss when we need friend functions."
  },
  {
    "objectID": "lecture15.html#last-lecture",
    "href": "lecture15.html#last-lecture",
    "title": "Lecture 15 - Oct 10, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nDynamic memory allocation and operator overloading."
  },
  {
    "objectID": "lecture15.html#today",
    "href": "lecture15.html#today",
    "title": "Lecture 15 - Oct 10, 2023",
    "section": "Today",
    "text": "Today\noperator= and operator&lt;&lt;."
  },
  {
    "objectID": "lecture15.html#operator-overloading",
    "href": "lecture15.html#operator-overloading",
    "title": "Lecture 15 - Oct 10, 2023",
    "section": "Operator overloading",
    "text": "Operator overloading\nRecall operator+: x + y &lt;=&gt; x.operator+(y).\nclass Complex {\n  private:\n    double real;\n    double img;\n  public:\n    Complex() { real = 0.0; img = 0.0; }\n    Complex(double r, double i) { real = r; img = i; }\n\n    // pass by reference to avoid copying\n    // memory efficient\n    Complex operator+(const Complex& c) const {\n      return Complex(real + c.real, img + c.img);\n    }\n}\nPassing by value will create a copy of rhs.\nThis is memory inefficient if the object has many data members.\nPass by reference will not create a copy, so it is memory efficient."
  },
  {
    "objectID": "lecture15.html#good-practice-for-safety",
    "href": "lecture15.html#good-practice-for-safety",
    "title": "Lecture 15 - Oct 10, 2023",
    "section": "Good practice for safety",
    "text": "Good practice for safety\n\nPass the object as a const object\nComplex Complex::operator+(const Complex& rhs) {\n  rhs.real = 0; // compile-time error!\n  return Complex(real + rhs.real, img + rhs.img);\n}\n\n\n\n\n\n\nPacha’s note\n\n\n\nInside the function, the line rhs.real = 0; attempts to modify the real member of rhs. Because rhs is a constant reference, it cannot be modified. This is why the comment indicates a compile-time error. The compiler will not allow this code to compile because it violates the const-correctness rule.\n\n\n\n\nOperator plus does not change members of the object\nUse const modifier to prevent changes to members of the object.\nComplex Complex::operator+(const Complex& rhs) const {\n  real = 0; // compile-time error!\n  return Complex(real + rhs.real, img + rhs.img);\n}\n\nint main() {\n  Complex x(3,5), y(4,6), z;\n  z = x + y; // now we have operator=\n}"
  },
  {
    "objectID": "lecture15.html#overloading-operator-equal",
    "href": "lecture15.html#overloading-operator-equal",
    "title": "Lecture 15 - Oct 10, 2023",
    "section": "Overloading operator equal",
    "text": "Overloading operator equal\nBy default, operator= is there. It sets all the data members in the object to the data members of the right hand side object.\nHow does the default assignment operator= look like?\nz = x (left hand side = right hand side) is equivalent to z.operator=(x).\nHow to allow chain assignments?\ny = (z = x) should return object z.\nThis is a keyword and a pointer pointing to the object on which the function was invoked (i.e., z in z = x).\n// Return by reference: Complex&, which is the object itself\nComplex& Complex::operator=(const Complex& rhs) {\n  real = rhs.real;\n  img = rhs.img;\n  return *this; // returns object z\n}\n\n\n\n\n\n\nPacha’s note\n\n\n\nthis is a pointer to the object on which the function was invoked. In this case, it is a pointer to z. *this is the object itself."
  },
  {
    "objectID": "lecture15.html#overloading-operator-insertion",
    "href": "lecture15.html#overloading-operator-insertion",
    "title": "Lecture 15 - Oct 10, 2023",
    "section": "Overloading operator insertion",
    "text": "Overloading operator insertion\nComplex z(3,4);\n\n// with standard operator &lt;&lt;\n// RHS: Complex\n// LHS: ostream (not Complex)\ncout &lt;&lt; z;\ncout is an object of ostream class.\noperator&lt;&lt; cannot be a member function of complex, since LHS is of type ostream.\noperator&lt;&lt; cannot be a non-member function as it has to access private members of Complex.\nSolution: operator&lt;&lt; can be a friend function.\nA friend function can access private members of an object, and LHS can be a non-complex type.\nclass Complex {\n  ...\n\n  public:\n    friend ostream& operator&lt;&lt;(ostream& os, const Complex& x);\n};\n\nostream& operator&lt;&lt;(ostream& os, const Complex& x) {\n  os &lt;&lt; \"(\" &lt;&lt; x.real &lt;&lt; \",\" &lt;&lt; x.img &lt;&lt; \")\";\n  return os;\n}\nRemember that operator&lt;&lt; is not a member, so there is no need for Complex::.\nint main() {\n  Complex z(3,4);\n  cout &lt;&lt; \"z = \"&lt;&lt; z &lt;&lt; endl;\n}\n\ncout is returned to allow chained cout.\ncout (and all other streams) cannot be passed or returned by value. Only by reference, as their copy constructor is deleted."
  },
  {
    "objectID": "lecture15.html#exercise",
    "href": "lecture15.html#exercise",
    "title": "Lecture 15 - Oct 10, 2023",
    "section": "Exercise",
    "text": "Exercise\nImplement operator==.\nclass Complex {\n  ...\n\n  public:\n    ...\n    \n    bool operator==(const Complex& rhs) const {\n      return (real == rhs.real) && (img == rhs.img);\n    }\n};"
  },
  {
    "objectID": "lecture16.html#summary",
    "href": "lecture16.html#summary",
    "title": "Lecture 16 - Oct 12, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we conclude our discussion on operator overloading. We introduce copy constructors and how shallow the default copy constructors are."
  },
  {
    "objectID": "lecture16.html#last-lecture",
    "href": "lecture16.html#last-lecture",
    "title": "Lecture 16 - Oct 12, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nOperator overloading: operator+, operator&lt;&lt;."
  },
  {
    "objectID": "lecture16.html#today",
    "href": "lecture16.html#today",
    "title": "Lecture 16 - Oct 12, 2023",
    "section": "Today",
    "text": "Today\nCopy constructor."
  },
  {
    "objectID": "lecture16.html#recap-shift-operator",
    "href": "lecture16.html#recap-shift-operator",
    "title": "Lecture 16 - Oct 12, 2023",
    "section": "Recap shift operator",
    "text": "Recap shift operator\nComplex z(3,4);\ncout &lt;&lt; z;\nFor the operator&lt;&lt;, the rhs is Complex and the lhS I ostream (not Complex).\ncout is an object of ostream class.\noperator&lt;&lt; cannot be a member function of Complex, since the lhs is of type ostream.\noperator&lt;&lt; cannot be a non-mmember function as it has to access private members of Complex.\nSolution. operator&lt;&lt; can be a friend function.\nA friend function can access private members of an object, and lhs can be a non-complex type.\nclass Complex\n  ...\n\n  public:\n    ...\n\n    friend ostream& operator&lt;&lt;(ostream&os, const Complex& x);\n;}\n\n// not ostream& Complex::operator&lt;&lt;\nostream& operator&lt;&lt;(ostream&os, const Complex& x) {\n  os &lt;&lt; x.real &lt;&lt; \" + \" &lt;&lt; x.img &lt;&lt; \"i\";\n  return os;\n}\nRemember that operator&lt;&lt; is not a member, so there is no need for Complex::.\nint main() {\n  Complex z(3,4);\n  cout &lt;&lt; \"z =\" &lt;&lt; z &lt;&lt; endl;\n}\nRecall the diagram from lecture 15.\n\ncout is returned to allow chained cout.\ncout (and all other streams) cannot be parsed or returned by value. Only by reference, as their copy constructor is deleted."
  },
  {
    "objectID": "lecture16.html#copy-constructor",
    "href": "lecture16.html#copy-constructor",
    "title": "Lecture 16 - Oct 12, 2023",
    "section": "Copy constructor",
    "text": "Copy constructor\nCopy constructor is a constructor used to create a copy of an existing object. When is the copy constructor called?\n\nStudent a(b);, b is an object of student.\nStudent a = b;, create and initialize on the same line. Common confusion\n\nStudent a;\na = b; // here a.operator=(b) is invoked\n\nPassing an object by value to a function.\nReturn an object by value from a function.\n\nBy default, every class has a copy constructor that copies all data members.\n\n\n\n\n\n\nPacha’s note\n\n\n\nI added the private: to the first class. Prof. Emara confirmed that we can exclude that and name and ID will be private by default.\n\n\nclass Student {\n  private:\n    string name;\n    int ID;\n\n  public:\n    // copy constructor\n    Student(const Student& other) {\n      name = other.name;\n      ID = other.ID;\n    }\n};\nWe have to pass by reference, or else there will be a compile-time error. If passed by value, the copy constructor will be called again, leading to an infinite recursion.\nConstructors has no returns.\nProblem. What happens when data members are pointers?\nclass MyString {\n  private:\n    int len;\n    char* buf;\n\n  public:\n    MyString() { len = 0; buf = nullptr; }\n    \n    Mystring(char* src) { \n      buf = new chat[srtlen(src) + 1];\n      strcpy(buf, src);\n      len = strlen(src);\n    }\n\n    void setString(char* src) {\n      if (!buf = NULL) {\n        delete[] buf;\n        buf = new char[strlen(src) + 1];\n        strcpy(buf, src);\n        len = strlen(src);\n      }\n    }\n\n    // shallow copy!\n    MyString(const MyString&x) {\n      len = x.len;\n      buf = x.buf;\n    }\n};\n\nint main() {\n  MyString a(\"Hello\");\n  MyString b(a);\n  b.setString(\"Oops\"); // we change the string in a and b\n  return 0;\n}\n\nSolution. Deep copy\nMyString::MyString(const MyString& src) {\n  buf = new char[strlen(src) + 1];\n  strcpy(buf, src.buf);\n  len = src.len;\n}\n\nint main() {\n  MyString a(\"Hello\");\n  MyString b(a);\n  b.setString(\"Oops\"); // we change the string in a and b\n  return 0;\n}"
  },
  {
    "objectID": "lecture16.html#rule-of-three",
    "href": "lecture16.html#rule-of-three",
    "title": "Lecture 16 - Oct 12, 2023",
    "section": "Rule of three",
    "text": "Rule of three\nIf a class requires one of the following, then it almost certainly needs all three.\n\nUser-defined destructor.\nUser-defined copy constructor.\nUser-defined assignment operator operator=."
  },
  {
    "objectID": "lecture17.html#summary",
    "href": "lecture17.html#summary",
    "title": "Lecture 17 - Oct 13, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we introduce how can we solve the issue of shallow copy constructors. We discuss when we need to write our own destructors, copy constructor and operator=."
  },
  {
    "objectID": "lecture17.html#last-lecture",
    "href": "lecture17.html#last-lecture",
    "title": "Lecture 17 - Oct 13, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nCopy constructor."
  },
  {
    "objectID": "lecture17.html#today",
    "href": "lecture17.html#today",
    "title": "Lecture 17 - Oct 13, 2023",
    "section": "Today",
    "text": "Today\nDeep versus shallow constructors."
  },
  {
    "objectID": "lecture17.html#recap-default-copy-constructor",
    "href": "lecture17.html#recap-default-copy-constructor",
    "title": "Lecture 17 - Oct 13, 2023",
    "section": "Recap default copy constructor",
    "text": "Recap default copy constructor\nThe default copy constructor copies all data members of an existing object.\nIn what cases do we need to implement our own copy constructor?\nProblem. What happens when data members are pointers?\nclass MyString {\n  private:\n    int len;\n    char* buf;\n\n  public:\n    MyString() { len = 0; buf = nullptr; }\n    \n    MyString(char* src) {\n      buf = new chat[strlen(src) + 1];\n      strcpy(buf, src);\n      len = strlen(src);\n    }\n\n    void setString(char* src) {\n      if (buf != NULL) {\n        delete[] buf;\n        buf = new char[strlen(src) + 1];\n        strcpy(buf, src);\n        len = strlen(src);\n      }\n    }\n\n    // shallow copy\n    MyString(const MyString& x) {\n      len = x.len;\n      buf = x.buf;\n    }\n};\nRecall the diagram from lecture 16.\n\nSolution. Deep copy.\nMyString::MyString(const MyString& src) {\n  buf = new char[strlen(src.buf) + 1];\n  strcpy(buf, src.buf);\n  len = src.len;\n}\n\nint main() {\n  MyString a(\"Hello\");\n  MyString b(a);\n  b.setString(\"Oops\"); // we change the string in a and b\n  return 0;\n}"
  },
  {
    "objectID": "lecture17.html#rule-of-three",
    "href": "lecture17.html#rule-of-three",
    "title": "Lecture 17 - Oct 13, 2023",
    "section": "Rule of three",
    "text": "Rule of three\nIf a class requires one of the following, then it almost certainly needs all three.\n\nUser-defined destructor.\nUser-defined copy constructor.\nUser-defined assignment operator operator=.\n\n1-3 are given by default.\nA deep destructor is needed for MyString.\nMyString::~MyString() {\n  if (buf != nullptr) {\n    delete[] buf;\n    buf = nullptr;\n  }\n}\nDeep assignment is needed for MyString.\nMyString& MyString::operator=(const MyString& src) {\n  // if you do the operator= on the same object\n  if (this == &src) {\n    return *this;\n  }\n\n  delete[] buf;\n  buf = new char[strlen(src.buf) + 1];\n  strcpy(buf, src.buf);\n  len = src.len;\n  return *this;\n}"
  },
  {
    "objectID": "lecture17.html#additional-exercises",
    "href": "lecture17.html#additional-exercises",
    "title": "Lecture 17 - Oct 13, 2023",
    "section": "Additional exercises",
    "text": "Additional exercises\nWhat if I want to compare two objects?\nMyString a(\"Hello\");\nMyString b(\"world\");\n\nif (a == b) {\n  cout &lt;&lt; \"Strings are the same\" &lt;&lt; endl;\n}\n\nbool MyString::operator==(const MyString& rhs) {\n  return (strcmp(buf, rhs.buf) == 0);\n}\nHow about (\"hi\" == a)?\n// define this as a friend function\nbool operator==(char* lhs, const MyString& rhs) {\n  return (strcmp(lhs, rhs.buf) == 0);\n}"
  },
  {
    "objectID": "lecture17.html#notes-on-confusing-points",
    "href": "lecture17.html#notes-on-confusing-points",
    "title": "Lecture 17 - Oct 13, 2023",
    "section": "Notes on confusing points",
    "text": "Notes on confusing points\nSimilarities and differences between copy constructor and operator=.\n\n\n\nCopy constructor\n\nUsage\nStudent x(y);\nStudent x = y;\nStudent* p = new Student(y);\nMust pass by reference. If not, compile-time error.\nArgument better passed as const to safeguard against changes.\nDefault is given.\nDoes not return anything.\n\n\n\n\n\n\nOperator equal\n\nUsage\nx=y;\nx.operator=(y);\nBetter pass by reference to avoid calling copy constructor.\nSame.\nSame.\nReturn by reference returns *this, to allow chained assignment."
  },
  {
    "objectID": "lecture18.html#summary",
    "href": "lecture18.html#summary",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we start discussing linked lists variants: stacks and queues, and where they are used."
  },
  {
    "objectID": "lecture18.html#last-lecture",
    "href": "lecture18.html#last-lecture",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nDeep copy in copy constructors."
  },
  {
    "objectID": "lecture18.html#today",
    "href": "lecture18.html#today",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Today",
    "text": "Today\nData structures: Stacks and queues."
  },
  {
    "objectID": "lecture18.html#recap-on-arrays",
    "href": "lecture18.html#recap-on-arrays",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Recap on arrays",
    "text": "Recap on arrays\nTo store and organize data of same type, we used arrays.\nint arr[3] = {1,2,3};\nAn issue with arrays is that they are not flexible. If you need more space, you need to allocate new memory with more space and copy data to this space.\nThis is where liked lists are helpful."
  },
  {
    "objectID": "lecture18.html#linked-lists",
    "href": "lecture18.html#linked-lists",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Linked lists",
    "text": "Linked lists\nA linked list is a collection of nodes that are linked together via pointers. They are easily extendable, shrinkable and flexible.\n\nIn C, each node and the linked list were a data structure. There were some functions/operations like insert and delete.\nIn C++, we can bundle operations and data into an object.\nThere are variants or linked lists: stacks, queues, doubly linked lists, etc."
  },
  {
    "objectID": "lecture18.html#class-definition-of-a-node",
    "href": "lecture18.html#class-definition-of-a-node",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Class definition of a Node",
    "text": "Class definition of a Node\nClass definition of a Node in all linked list variants.\nIn Node.h:\nclass Node {\n  private:\n    int data;\n    Node* next;\n\n  private:\n    Node() { data = 0; next = NULL; }\n    Node(int d) { data = d; next = NULL; }\n    Node(int d, Node* n) { data = d; next = n; }\n    ~Node() { delete next; }\n    int getData() { return data; }\n    Node* getNext() { return next; }\n    void setData(int d) { data = d; }\n    void setNext(Node* n) { next = n; }\n}"
  },
  {
    "objectID": "lecture18.html#stacks",
    "href": "lecture18.html#stacks",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Stacks",
    "text": "Stacks\nTwo operations: pop() and push().\nPutting a node or removing a node happens with LIFO (last-in first-out).\npop(): Remove the node that was most recently inserted.\npush(): Insert a node at the head only as pop() would remove a node from head."
  },
  {
    "objectID": "lecture18.html#class-definition-of-a-stack",
    "href": "lecture18.html#class-definition-of-a-stack",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Class definition of a Stack",
    "text": "Class definition of a Stack\nclass Stack {\n  private:\n    Node* head;\n\n  public:\n    Stack() { head = NULL; }\n    ~Stack() { delete head; }\n    void push(int d) {\n      // if stack is empty, next of new node is NULL\n      // if stack has nodes, next of new node is old head\n      Node* p = new Node(d, head);\n\n      // make new node the head\n      head = p;\n    }\n}\n\n\n\n\n\n\nstack s;\n\ns.push(3);\ns.push(2);\ns.push(1);\ns.push(0);\n\n\nint pop() {\n  // if stack is empty\n  if (head == NULL) {\n    return -1;\n  }\n\n  Node* p = head;\n  int d = p-&gt;getData(); // data is private to Node\n  head = p-&gt;getNext(); // head is private to Stack\n  p-&gt;setNext(NULL); // very important!\n  delete p;\n  return d;\n};\n\n// for the 1st pop, the most recently pushed node is 0\n// output is 0123\ncout &lt;&lt; s.pop() &lt;&lt; s.pop() &lt;&lt; s.pop() &lt;&lt; endl;\nAlways think of special cases:\n\nDoes it work if the stack is empty?\nDoes it work if the stack has only one node?"
  },
  {
    "objectID": "lecture18.html#queues",
    "href": "lecture18.html#queues",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Queues",
    "text": "Queues\nTwo operations: enqueue() and dequeue().\nPutting a node or removing a node happens with FIFO (first-in first-out).\ndequeue(): Remove the node that was first put in the list.\nenqueue(): Put a node at the end of the list."
  },
  {
    "objectID": "lecture18.html#class-implementation-of-a-queue",
    "href": "lecture18.html#class-implementation-of-a-queue",
    "title": "Lecture 18 - Oct 17, 2023",
    "section": "Class implementation of a Queue",
    "text": "Class implementation of a Queue\nclass Queue {\n  private:\n    Node* head;\n\n    // point to the end of the queue to facilitate dequeue of nodes\n    Node* tail;\n\n  public:\n    Queue() {\n      head = NULL;\n      tail = NULL;\n    }\n\n    ~Queue() { \n      // enough to free up all nodes in linked list\n      delete head;\n    }\n\n    void enqueue(int d) {\n      Node* p = new Node(d, NULL);\n      tail-&gt;setNext(p);\n      tail = p;\n      if (head == NULL) {\n        head = p;\n      }\n    }\n\n    int dequeue() {\n      if (head == NULL) {\n        return -1;\n      }\n\n      Node* p = head;\n      head = p-&gt;getNext();\n      int d = p-&gt;getData();\n      p-&gt;setNext(NULL); // very important!\n      delete p;\n      return d;\n    }\n};\n\nQueue q;\nq.enqueue(1);\nq.enqueue(2);\nq.enqueue(3);\n\n// output 123\ncout &lt;&lt; q.dequeue() &lt;&lt; q.dequeue() &lt;&lt; q.dequeue() &lt;&lt; endl;"
  },
  {
    "objectID": "lecture19.html#summary",
    "href": "lecture19.html#summary",
    "title": "Lecture 19 - Oct 19, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss queues, and start discussing ordered linked lists."
  },
  {
    "objectID": "lecture19.html#last-lecture",
    "href": "lecture19.html#last-lecture",
    "title": "Lecture 19 - Oct 19, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nStacks."
  },
  {
    "objectID": "lecture19.html#today",
    "href": "lecture19.html#today",
    "title": "Lecture 19 - Oct 19, 2023",
    "section": "Today",
    "text": "Today\nQueues and general linked lists."
  },
  {
    "objectID": "lecture19.html#recap-on-queues",
    "href": "lecture19.html#recap-on-queues",
    "title": "Lecture 19 - Oct 19, 2023",
    "section": "Recap on queues",
    "text": "Recap on queues\nTwo operations: enqueue and dequeue.\nPutting a node or removing a node happens with FIFO (first-in-first-out).\ndequeue(): Removes the node that was first put in a list.\nenqueue(): Puts a node at the end of the list."
  },
  {
    "objectID": "lecture19.html#class-implementation-of-a-queue",
    "href": "lecture19.html#class-implementation-of-a-queue",
    "title": "Lecture 19 - Oct 19, 2023",
    "section": "Class implementation of a Queue",
    "text": "Class implementation of a Queue\nclass Queue {\n  private:\n    Node* head;\n\n    // point to end of the queue to facilitate dequeue of nodes\n    Node* tail;\n\n  public:\n    Queue() {\n      head = NULL;\n      tail = NULL;\n    }\n\n    ~Queue() {\n      // enough to free up all nodes in linked list\n      delete head;\n    }\n\n    void enqueue(int d) {\n      Node* p = new Node(d, NULL);\n      tail-&gt;setNext(p);\n      tail=p;\n      if (head == NULL) {\n        head = p;\n      }\n    }\n\n    int dequeue() {\n      if (head == NULL) {\n        return -1;\n      }\n\n      Node* p = head;\n      head = p-&gt;getNext();\n      int d = p-&gt;getData();\n      p-&gt;setNext(NULL); // very important\n      delete p;\n      return d;\n    }\n};\n\nQueue q;\nq.enqueue(1);\nq.enqueue(2);\nq.enqueue(3);\n\n// output 123\ncout &lt;&lt; q.dequeue() &lt;&lt; q.dequeue() &lt;&lt; endl;\nRecall the diagram from lecture 18."
  },
  {
    "objectID": "lecture19.html#ordered-linked-lists",
    "href": "lecture19.html#ordered-linked-lists",
    "title": "Lecture 19 - Oct 19, 2023",
    "section": "Ordered linked lists",
    "text": "Ordered linked lists\nFour basic operations\n\nInsert in sorted order\nSearch\nDelete\nCopy\n\nIn List.h:\n#include \"Node.h\"\n\nclass List {\n  private:\n    Node* head;\n    \n  public:\n    List() { head = NULL; }\n    ~List() { delete head; }\n    void insertData(int d);\n    bool dataExists(int d);\n    bool deleteData(int d);\n    List(const List&); // copy constructor\n    List& operator=(const List&);\n};"
  },
  {
    "objectID": "lecture19.html#search-linked-list",
    "href": "lecture19.html#search-linked-list",
    "title": "Lecture 19 - Oct 19, 2023",
    "section": "Search linked list",
    "text": "Search linked list\nbool dataExists(int d) {\n  Node* p = head;\n  // the 2nd condition is because, otherwise, d won't be after that if\n  // linked list is sorted\n  while(p != NULL && p-&gt;getData() != d) {\n    if(p-&gt;getData() == d) {\n      return true;\n    } else {\n      p = p-&gt;getNext();\n    }\n  }\n\n  return false;\n}"
  },
  {
    "objectID": "lecture19.html#insert-into-list-general-case",
    "href": "lecture19.html#insert-into-list-general-case",
    "title": "Lecture 19 - Oct 19, 2023",
    "section": "Insert into list (general case)",
    "text": "Insert into list (general case)\n\nSearch for the first node with data greater than the data we want to insert.\nInsert the new data before that node.\n// d = 3\nbool List::insertData(int d) {\n  Node* n = new Node(d);\n  Node* p = head, *prev = NULL;\n\n  // list is empty\n  if (p == NULL) {\n    head = n;\n  }\n\n  while(p != NULL && p-&gt;getData() &lt; d) {\n    prev = p;\n    p = p-&gt;getNext();\n  }\n\n  // either p-&gt;getData() &gt; c or p == NULL\n  n-&gt;setNext(p); // case 1\n\n  if (prev == NULL) {\n    head = n; // case 2\n  } else {\n    prev-&gt;setNext(n); // case 3\n  }\n}\nCases 1, 2, 3 are shown in the diagram below.\n\nSpecial cases:\n\nIf list is empty.\nIf list has one node.\nIf we insert at head.\nIf we insert at tail.\n\nNext lecture: delete data, “copy” constructor, operator=."
  },
  {
    "objectID": "lecture20.html#summary",
    "href": "lecture20.html#summary",
    "title": "Lecture 20 - Oct 20, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we continue our discussion on ordered linked lists. We discuss operations like searching, inserting, deleting nodes in a linked list."
  },
  {
    "objectID": "lecture20.html#last-lecture",
    "href": "lecture20.html#last-lecture",
    "title": "Lecture 20 - Oct 20, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nQueues and introduced ordered linked lists."
  },
  {
    "objectID": "lecture20.html#today",
    "href": "lecture20.html#today",
    "title": "Lecture 20 - Oct 20, 2023",
    "section": "Today",
    "text": "Today\nSearch, insert, delete."
  },
  {
    "objectID": "lecture20.html#recap-on-ordered-lik",
    "href": "lecture20.html#recap-on-ordered-lik",
    "title": "Lecture 20 - Oct 20, 2023",
    "section": "Recap on ordered lik",
    "text": "Recap on ordered lik\nFour basic operations: insert in sorted order, search delete, and copy.\nIn List.h:\n#include \"Node.h\"\n\nclass List {\n  private:\n    Node* head;\n\n  public:\n    List() { head = NULL; }\n    ~List() { delete head; }\n    void insertData(int d);\n    bool dataExists(int d);\n    bool deleteData(int d);\n    List(const List&); // copy constructor\n    List& operator=(const List&);\n};"
  },
  {
    "objectID": "lecture20.html#search-linked-list",
    "href": "lecture20.html#search-linked-list",
    "title": "Lecture 20 - Oct 20, 2023",
    "section": "Search linked list",
    "text": "Search linked list\nbool dataExists(int d) {\n  Node* p = head;\n  \n  // the 2nd condition is because, otherwise, d won't be after that if\n  // the linked list is sorted\n  while (p != NULL && p-&gt;getData() &lt; d) {\n    if (p-&gt;getData() == d) {\n      return true;\n    } else {\n      p = p-&gt;getNext();\n    }\n  }\n\n  return false;\n}"
  },
  {
    "objectID": "lecture20.html#insert-into-list-general-case",
    "href": "lecture20.html#insert-into-list-general-case",
    "title": "Lecture 20 - Oct 20, 2023",
    "section": "Insert into list (general case)",
    "text": "Insert into list (general case)\nRecall the diagram from lecture 19.\n\nSearch for the first node with data greater than the data we want to insert.\nInsert the new data before that node.\n// d = 3\nbool List::insertData(int d) {\n  Node* n = new Node(d);\n  Node* p = head, *prev = NULL;\n  \n  // list is empty\n  if(p == NULL) {\n    head = n;\n  }\n\n  while(p != NULL && p_&gt;getData() &lt; d) {\n    prev = p;\n    p = p-&gt;getNext();\n  }\n\n  // either p-&gt;getData &lt; d or p == NULL\n  n-&gt;setNext(p); // case 1\n\n  if(prev == NULL) {\n    head = n; // case 2\n  } else {\n    prev-&gt;setNext(n); // case 3\n  }\n}\nCases 1, 2, 3 are shown in the diagram below.\n\nSpecial cases:\n\nIf list is empty.\nIf list has one node.\nIf we insert at head.\nIf we insert at tail."
  },
  {
    "objectID": "lecture20.html#delete-data-general-case",
    "href": "lecture20.html#delete-data-general-case",
    "title": "Lecture 20 - Oct 20, 2023",
    "section": "Delete data (general case)",
    "text": "Delete data (general case)\n\nbool List::deleteData(int d) {\n  Node* p = head, *prev = NULL;\n\n  while(p != NULL && p-&gt;getData() &lt; d) {\n    if(p-&gt;getData() == d) {\n      return false;\n    } else {\n      prev = p;\n      p = p-&gt;getNext();\n    }\n  }\n\n  // p is NULL or p-&gt;getData() == d\n  if(p == NULL) {\n    return false; // not found\n  }\n\n  // delete at front\n  if(prev == NULL) {\n    head = p-&gt;getNext();\n  } else {\n    // delete at middle or tail\n    prev-&gt;setNext(p-&gt;getNext());\n  }\n\n  // delete p\n  p-&gt;setNext(NULL);\n  delete p;\n}"
  },
  {
    "objectID": "lecture20.html#destructor",
    "href": "lecture20.html#destructor",
    "title": "Lecture 20 - Oct 20, 2023",
    "section": "Destructor",
    "text": "Destructor\nList::~List() {\n  delete head;\n}"
  },
  {
    "objectID": "lecture20.html#copy-constructor",
    "href": "lecture20.html#copy-constructor",
    "title": "Lecture 20 - Oct 20, 2023",
    "section": "Copy constructor",
    "text": "Copy constructor\nThe copy constructor creates an object from an existing one.\nThe default copy constructor does a shallow copy.\nWe need to do a deep copy:\n\nCopy one node at a time.\np to iterate original list, np to build new list.\n\nList::List(const List& original) {\n  Node *p = original.head;\n  Node *np = NULL;\n  head = NULL;\n\n  while (p != NULL) {\n    Node *n = new Node(p-&gt;getData(), NULL);\n    if (np == NULL) {\n      head = n;\n    } else {\n      np-&gt;setNext(n);\n    }\n    \n    p = p-&gt;getNext();\n    np = n;\n  }\n}"
  },
  {
    "objectID": "lecture21.html#summary",
    "href": "lecture21.html#summary",
    "title": "Lecture 21 - Oct 24, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss copy constructor and operator= of linked lists. We also review the material for the midterm."
  },
  {
    "objectID": "lecture21.html#today",
    "href": "lecture21.html#today",
    "title": "Lecture 21 - Oct 24, 2023",
    "section": "Today",
    "text": "Today\nCopy constructor, operator=, and midterm revision."
  },
  {
    "objectID": "lecture21.html#recap-on-copy-constructor",
    "href": "lecture21.html#recap-on-copy-constructor",
    "title": "Lecture 21 - Oct 24, 2023",
    "section": "Recap on copy constructor",
    "text": "Recap on copy constructor\nCreates an object from an existing one.\nThe default copy constructor does a shallow copy.\nWe need to do a deep copy:\n\nCopy one node at a time.\np to iterate original list, np to build new list.\n\nList::List(const List& original) {\n  Node *p = original.head;\n  Node *np = NULL;\n  head = NULL;\n\n  while (p != NULL) {\n    Node *n = new Node(p-&gt;getData(), NULL);\n\n    if (np == NULL) {\n      head = n;\n    } else {\n      np-&gt;setNext(n);\n    }\n\n    p = p-&gt;getNext();\n    np = n;\n  }\n}"
  },
  {
    "objectID": "lecture21.html#recap-on-operator-equals",
    "href": "lecture21.html#recap-on-operator-equals",
    "title": "Lecture 21 - Oct 24, 2023",
    "section": "Recap on operator equals",
    "text": "Recap on operator equals\nThe idea is similar to the copy constructor, except that the lhs may not be empty. We must empty lhs first.\nList& List::operator=(const List& original) {\n  if (&original == this) {\n    return *this;\n  }\n\n  if (head != NULL) {\n    delete head;\n    head = NULL;\n  }\n\n  // same as copy constructor body ----\n  Node *p = original.head;\n  Node *np = NULL;\n  \n  while(p != NULL) {\n    Node *n = new Node(p-&gt;getData(), NULL);\n\n    if (np == NULL) {\n      head = n;\n    } else {\n      np-&gt;setNext(n);\n    }\n\n    p = p-&gt;getNext();\n    np = n;\n  }\n  // ----\n\n  return *this;\n}"
  },
  {
    "objectID": "lecture21.html#recap-on-destructor",
    "href": "lecture21.html#recap-on-destructor",
    "title": "Lecture 21 - Oct 24, 2023",
    "section": "Recap on destructor",
    "text": "Recap on destructor\nList::~List() {\n  delete head;\n}"
  },
  {
    "objectID": "lecture21.html#past-exam-questions",
    "href": "lecture21.html#past-exam-questions",
    "title": "Lecture 21 - Oct 24, 2023",
    "section": "Past exam questions",
    "text": "Past exam questions\n\nFall 2019 - Q14\nThe following class is used to create objects that represent ordinary fractions n/d, consisting of a numerator n and a denominator d.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Fraction {\n  private:\n    int numerator;\n    int denominator;\n\n  public:\n    Fraction(int num, int denm);\n    int getNumerator();\n    int getDenominator();\n    void setNumerator(int num);\n    void setDenominator(int denm);\n    void print();\n};\n\nFraction::Fraction(int num, int denm) {\n  numerator = num;\n\n  // should check that denm is not 0, but ignore for now\n  denominator = denm;\n}\n\nint Fraction::getNumerator() {\n  return numerator;\n}\n\nint Fraction::getDenominator() {\n  return denominator;\n}\n\nvoid Fraction::setNumerator(int num) {\n  numerator = num;\n}\n\nvoid Fraction::setDenominator(int denm) {\n  // should check that denm is not 0, but ignore for now\n  denominator = denm;\n}\n\nvoid Fraction::print() {\n  cout &lt;&lt; numerator &lt;&lt; \"/\" &lt;&lt; denominator &lt;&lt; endl;\n}\nDefine the operator overloads for the operation:\nFraction X(1,5);\nFraction Y(4,6);\n...\n\n___ = X * Y; // the first multiply operation\n___ = X * 2; // the second multiply operation\nThe first operator is:\nFraction::Fraction operator*(Fraction& rhs) {\n  Fraction w(numerator * rhs.numerator, denominator * rhs.denominator);\n  return w;\n}\nThe second operator is:\nFraction::Fraction operator*(int x) {\n  Fraction w(x * rhs.numerator, denominator);\n  return w;\n}\n\n\nFall 2018 - Q7\nThe following is the definition/implementation of a class called Foo.\nclass Foo {\n  private:\n    int priv;\n\n  public:\n    Foo(int pv) { priv = pv; }\n    \n    Foo(const Foo src) { priv = src.priv; }\n    \n    Foo& operator=(Foo& rhs) {\n      priv = src.priv;\n      return this;\n    }\n\n    int getPriv() { return priv; }\n\n    void setPriv(int pv) { priv = pv; }\n};\nCompiling the above definition/implementation results in one or more errors. Re-write the class so it is error-free. Write your answer (the entire definition/implementation).\nThe code requires the following corrections:\n// Foo(const Foo src) { priv = src.priv; }\nFoo(const Foo& src) { priv = src.priv; }\n    \nFoo& operator=(Foo& rhs) {\n  priv = src.priv;\n  // return this;\n  return *this;\n}\nI cannot return a local variable by reference.\n\n\nFall 2021 Final - Q7\nIt is desired to implement an efficient deletion function in a linked list. You are given a linked list pointed to by head and a pointer node to a node in a linked list, which is guaranteed not to be the last node in the list (i.e., not the tail node). Write a function removeNode that removed this node from the list. You should not iterathe the nodes in the list.\nYou may assume the following is the definition of the class, ListNode. The head node of the linked list is pointed to by head.\nclass ListNode {\n  public:\n    int key;\n    ListNode *next;\n};\n\nListNode* head;\nYou are not allowed to change the function’s argument or return type.\nvoid removeNode(ListNode *node) {\n  ...\n}\nThe solution is to copy the data from the next node into the current node, and then delete the next node.\nvoid removeNode(ListNode *node) {\n  ListNode *n = node-&gt;next;\n  node-&gt;key = n-&gt;key;\n  node-&gt;next = n-&gt;next;\n  delete n;\n}"
  },
  {
    "objectID": "lecture22.html#today",
    "href": "lecture22.html#today",
    "title": "Lecture 22 - Oct 26, 2023",
    "section": "Today",
    "text": "Today\nMidterm.\nHere is some music for coding."
  },
  {
    "objectID": "lecture23.html#summary",
    "href": "lecture23.html#summary",
    "title": "Lecture 23 - Oct 23, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we introduce recursion, and we discuss how to think recursively."
  },
  {
    "objectID": "lecture23.html#last-lecture",
    "href": "lecture23.html#last-lecture",
    "title": "Lecture 23 - Oct 23, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nMidterm revision."
  },
  {
    "objectID": "lecture23.html#today",
    "href": "lecture23.html#today",
    "title": "Lecture 23 - Oct 23, 2023",
    "section": "Today",
    "text": "Today\nRecursion."
  },
  {
    "objectID": "lecture23.html#recursion",
    "href": "lecture23.html#recursion",
    "title": "Lecture 23 - Oct 23, 2023",
    "section": "Recursion",
    "text": "Recursion\nRecursion is a programming technique that involves solving a problem by breaking it into a smaller problem repeatedly until it is small enough to be solved easily. Solutions of smaller problems can then be combined to form the solution of the original bigger problem.\n\n\n\n\n\n\nExample\n\n\n\nWrite a function that gets the factorial of n recursively.\n\\[\\begin{eqnarray*}\nn! &= n \\times (n - 1) \\times (n - 2) \\times \\cdots \\times 3 \\times 2 \\times 1 \\\\\nn! &= n \\times (n - 1)! \\\\\n4! &= 4 \\times 3! = 3 \\times 2! = 2 \\times 1! = 2\n\\end{eqnarray*}\\]\n\nRecursively get the factorial of a smaller number.\nRepeat until we reach the terminating case.\nCombine the solutions to get the bigger problem’s solutions.\n\nint factorial(int n) {\n  if (n == 1 || n == 0) {\n    return 1; // base case\n  } else {\n    return n * factorial(n - 1); // recursive case\n  }\n}\n\nint main() {\n  int f = factorial(3); // f = 6\n  return 0;\n}\nThe call to factorial(3) would create recursive function calls.\nint factorial(int 3) {\n  if (3 == 1 || 3 == 0) {\n    return 1; // base case\n  } else {\n    return 3 * factorial(3 - 1); // recursive case\n  }\n}\n\n  int factorial(int 2) {\n    if (2 == 1 || 2 == 0) {\n      return 1; // base case\n    } else {\n      return 2 * factorial(2 - 1); // recursive case\n    }\n  }\n\n    int factorial(int 1) {\n      if (1 == 1 || 1 == 0) {\n        return 1; // base case\n      } else {\n        return 1 * factorial(1 - 1); // recursive case\n      }\n    }\n\n\n\n\n\n\n\n\n\nExample\n\n\n\nGiven an array of n integers, sum the elements of the array.\nsumOfArray(0-&gt;4) = array[0] + sumOfArray(1-&gt;4)\nsumOfArray(1-&gt;4) = array[1] + sumOfArray(2-&gt;4)\n...\n\nint sumOfArray(int a[], int left, int right) {\n  if (left == right) {\n    return a[left];\n  } else {\n    return a[left] + sumOfArray(a, left + 1, right);\n  }\n}\n\nWe need to communicate to the next recursive function call from where should we\nstart adding and until where (e.g. `left` and `right`).\n:::\n\n::: {.callout-note icon=false}\n## Example\n\nPrint nodes in a linked list recursively.\n\n&lt;img src=\"diagrams/lecture18-diagram1.svg\" alt=\"diagrams/lecture18-diagram1.svg\"&gt;\n\n```cpp\nclass Node {\n  public:\n    int data;\n    Node* head;\n};\n\nvoid rprint(Node* p) {\n  if (p == NULL) {\n    return; // base case\n  } else {\n    cout &lt;&lt; p-&gt;data;\n    rprint(p-&gt;next); // recursive case\n  }\n}\n\nint main() {\n  List L;\n  ...\n\n  rprint(L-&gt;getHead()); // L-&gt;getHead() = Node*\n  ...\n  \n}"
  },
  {
    "objectID": "lecture26.html#today",
    "href": "lecture26.html#today",
    "title": "Lecture 26 - Nov 14, 2023",
    "section": "Today",
    "text": "Today\nInheritance."
  },
  {
    "objectID": "lecture26.html#summary",
    "href": "lecture26.html#summary",
    "title": "Lecture 26 - Nov 14, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we continue our discussion on complexity analysis, and how we get evaluate the big-O of recursive functions."
  },
  {
    "objectID": "lecture24.html#summary",
    "href": "lecture24.html#summary",
    "title": "Lecture 24 - Oct 23, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we discuss backtracking in recursion through solving a maze."
  },
  {
    "objectID": "lecture24.html#last-lecture",
    "href": "lecture24.html#last-lecture",
    "title": "Lecture 24 - Oct 23, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nRecursion."
  },
  {
    "objectID": "lecture24.html#today",
    "href": "lecture24.html#today",
    "title": "Lecture 24 - Oct 23, 2023",
    "section": "Today",
    "text": "Today\nBacktracking."
  },
  {
    "objectID": "lecture24.html#backtracking",
    "href": "lecture24.html#backtracking",
    "title": "Lecture 24 - Oct 23, 2023",
    "section": "Backtracking",
    "text": "Backtracking\nWe have 2D array called Maze, which has the map of the maze, as in the next diagram.\n\nBlank spaces means there is a path.\nColoured spaces means there is a wall.\nWe want to leave a trail of * showing a path from “Duck” to “E”.\nIdea. If maze[i][j] is a valid step to E, then one of maze[i+1][j], maze[i-1][j], maze[i][j+1], or maze[i][j-1] is also a step to E.\n\nWe starrt with the location of “Duck”: maze[i][j].\nIs 0 &lt;= i &lt;= 4 and 0 &lt;= j &lt;= 4?\nIf yes, check if maze[i+1][j] is a valid step to E.\nOr if maze[i-1][j] is a valid step to E.\nOr if maze[i][j+1] is a valid step to E.\nOr if maze[i][j-1] is a valid step to E.\nIf yes, maze[i][j] == '*'.\nIf no, nothing changes.\n\nbool solveMaze(int row, int col) {\n  // return false if maze[row][col] is not a valid step to E\n  // true otherwise\n\n  if (row &lt; 0 || row &gt;= height) || col &lt; 0 || col &gt;= width) {\n    // outside bounds of array\n    return false;\n  }\n\n  if (maze[row][col] == \"E\") {\n    // reached exit\n    return true;\n  }\n\n  if (maze[row][col] != \"\") {\n    // reached a wall or path again '*'\n    return false;\n  }\n\n  maze[row][col] = \"*\";\n\n  if (solveMaze(row + 1, col)) {\n    return true;\n  }\n\n  if (solveMaze(row - 1, col)) {\n    return true;\n  }\n\n  if (solveMaze(row, col + 1)) {\n    return true;\n  }\n\n  if (solveMaze(row, col - 1)) {\n    return true;\n  }\n\n  // if we get here then none of the 4 directions was a valid step to \"E\"\n\n  maze[row][col] = \"\";\n  return false;\n}\nConsider the next diagram.\n\nThe code to solve the maze is:\nsolveMaze(0, 0);\n |- maze[0][0] = \"*\"\n |- solveMaze(1, 0)\n     |- maze[1][0] = \"*\"\n     |- solveMaze(2,0)\n     |   |- return false: wall\n     |- solveMaze(0, 0)\n     |   |- return false: cycle\n     |- solveMaze(1, 1)\n         |- maze[1][1] = \"*\"\n         |- solveMaze(2, 1)\n             |- maze[2][1] = \"*\"\n             |- solveMaze(3, 1)\n                 |- maze[3][1] = \"*\"\n                 |- solveMaze(4,1)\n                 |   |- maze[4][1] = \"*\"\n                 |   |- return false: outside bounds\n                 |- solveMaze(2, 1)\n                 |   |- return false: cycle\n                 |- solveMaze(3, 2)\n                 |   |- maze[3][2] = \"*\"\n                 |   |- solveMaze(4, 2)\n                 |   |   |- return false: outside bounds\n                 |   |- solveMaze(3, 3)\n                 |   |   |- maze[3][3] = \"*\"\n                 |   |   |- solveMaze(4, 3)\n                 |   |   |   |- return false: outside bounds\n                 |   |   |- solveMaze(2, 3)\n                 |   |   |   |- return false: wall\n                 |   |   |- solveMaze(3, 4)\n                 |   |   |   |- return false: outside bounds\n                 |   |   |- solveMaze(3, 2)\n                 |   |   |   |- return false: wall\n                 |   |   |- maze[3][3] = \"\"\n                 |   |   |- return false\n                 |   |- solveMaze(3,1)\n                 |   |   |- return false: cycle\n                 |   |- maze[3][2] = \"\"\n                 |   |- return false\n                 |- solveMaze(3, 0)\n                     |- maze[3][0] = \"*\"\n                     |- return true\nAt any point in time, the number of “*” was the depth of recursion!"
  },
  {
    "objectID": "lecture25.html#summary",
    "href": "lecture25.html#summary",
    "title": "Lecture 25 - Nov 2, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we start discussing how to evaluate the performance of algorithms based on time complexity."
  },
  {
    "objectID": "lecture25.html#last-lecture",
    "href": "lecture25.html#last-lecture",
    "title": "Lecture 25 - Nov 2, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nBacktracking."
  },
  {
    "objectID": "lecture25.html#today",
    "href": "lecture25.html#today",
    "title": "Lecture 25 - Nov 2, 2023",
    "section": "Today",
    "text": "Today\nComplexity analysis - time."
  },
  {
    "objectID": "lecture25.html#algorithm",
    "href": "lecture25.html#algorithm",
    "title": "Lecture 25 - Nov 2, 2023",
    "section": "Algorithm",
    "text": "Algorithm\nThe set of steps to solve a problem. For example, find a number in a list.\n\nLinear search: Worst case scenario, the number we search for will be the last number. We will need to make \\(n\\) comparisons.\nBinary search: We assume the array is ordered. We start looking in the middle. If the number we are searching for is smaller, look left. Otherwise, look right. With every comparison, you throw 1/2 of the remaining array. Worst case is when you break the array several times until the remaining element is just one. The number of comparisons is given by \\(\\frac{n}{2^x} = 1 \\implies n = 2^x \\implies x = \\log_2(n)\\).\n\nThe time it takes to run a program, depends on your computer power, nature of data, compiler, programming language, and input size.\nHowever, the choice of your algorithm matters! If you get a faster computer for a slow algorithm, as input size grows, computation will take more time than if you have used a quicker algorithm.\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\nInput size (\\(n\\))\nLinear search on fast computer\nBinary search on slow computer\n\n\n\n\n15\n7 ns\n1000 ns\n\n\n1000\n500 ns\n2500 ns\n\n\n16,000,000\n8,000,000 ns\n6000 ns\n\n\n\n\n\nWe are interested in predicting performance as input size grows.\nWe will use complexity analysis (time) to evaluate how fast an algorithm with respect to input size.\n\\(T(n)\\): run time estimate as a function of input size \\(n\\) for one operation. \\(T(n) = 1\\).\n\n\n\n\n\n\nExample\n\n\n\n\n\nCode snippet\nint i = 3;\n\n\n\nRun-time estimate\n\\(T(n) = 1\\)\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\nCode snippet\nsum = 0;\nfor (int i = 0; i &lt; n; i++) {\n  sum ++;\n}\n\n\n\nRun-time estimate\n\\(T(n) = 3n + 2\\)\n\\(n\\) times\n\n\\(i &lt; n\\)\n\\(i++\\)\n\\(sum++\\)\n\nPlus sum = 0 and int i = 0.\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\nCode snippet\nLinear search for \\(x\\) in an array a\nfor (int i = 0; i &lt; n; i++) {\n  if (a[i] == x) {\n    return true;\n  }\n  return false;\n}\n\n\n\nRun-time estimate\nBest case: \\(T(n) = 4\\).\nWorst case: \\(T(n) = 3n + 2\\). The plus two is because of int i = 0 and return true.\nAverage case: \\(T(n) = \\frac{3n + 2}{2} = 1 + frac{3}{2}n\\).\n\n\n\n\nWhat is a better \\(T(n)\\)? Is it \\(3n + 2\\) or \\(2n + 2\\)?\n\nWe do not care about constants or coefficients. A faster computer can make up this difference.\nWhat truly makes a difference is the highest order term, as it dominates when \\(n\\) is large.\nWe use Big-O notation to represent \\(T(n)\\).\n\\(T(n) = O(g(n))\\) if \\(T(n)\\)’s highest order term is \\(g(n)\\) - disregarding coefficients and constant.\n\\(O(g(n))\\) is the upper bound on \\(T(n)\\).\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\\(T(n) = 1 = O(1)\\)\n\\(T(n) = 3n + 2 = O(n)\\)\n\\(T(n) = 3n^2 + n + 1 = O(n^2)\\)\n\\(T(n) = 10,000n^2 + 2 n \\log(n) + n^3 = O(n^3)\\)\n\n\nWhich term is more dominant?\n\nlibrary(ggplot2)\nlibrary(tidyr)\n\n# plot log(n) vs n vs nlog(n) bs 2^n vs n^2\nn &lt;- seq(1, 10, 0.1)\n\ndf &lt;- data.frame(\n  log_n = log(n),\n  n = n,\n  n_times_log_n = n * log(n),\n  n_pow_2 = n^2,\n  two_pow_n = 2^n\n)\n\ndf &lt;- df %&gt;% gather(fun, time, -n)\n\nggplot(df, aes(x = n, y = time, color = fun)) +\n  geom_line() +\n  theme_minimal() +\n  theme(legend.position = \"top\")\n\n\n\n\n\\[\n\\log(n) &lt; n &lt; n \\log(n) &lt; n^2 &lt; n^3 &lt; 2^n\n\\]\n\n\n\n\n\n\nExample\n\n\n\nMatrix addition\nint n = 7;\nint A[n][n] = { ... };\nint B[n][n] = { ... };\nint C[n][n];\n\nfor (int i = 0; i &lt; n; i++) {\n  for (int j = 0; i &lt; n; i++) {\n    C[i][j] = A[i][j] + B[i][j];\n  }\n}\nEach loop runs \\(n\\) times.\nInner loop:\nint j = 0 &lt;- once\ntakes C1\n\nj &lt; n, j++, C[i][j] = ... &lt;- n times\ntakes C2\n\\(T(n) = C_1 + C_2 n = O(n)\\).\nOuter loop:\nint i = 0 &lt;- once\ntakes C3\n\ni &lt; n, i++, for loop { ... } &lt;- n times\ntakes C4    complexity O(n)\n\\(T(n) = (C_4 + O(n))n + C_3 = O(n^2)\\).\n\\(T(n)\\) for matrix addition is \\(O(n^2)\\)."
  },
  {
    "objectID": "lecture26.html#last-lecture",
    "href": "lecture26.html#last-lecture",
    "title": "Lecture 26 - Nov 14, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nComplexity analysis."
  },
  {
    "objectID": "lecture26.html#inheritance",
    "href": "lecture26.html#inheritance",
    "title": "Lecture 26 - Nov 14, 2023",
    "section": "Inheritance",
    "text": "Inheritance\nInheritance is a pillar of object-oriented programming.\nInheriting/acquiring all properties and behaviours of a parent class.\nIn Person.h:\nclass Person {\n  private:\n    string name;\n    int age;\n\n  public:\n    Person() { name = \"\"; age = 0; }\n    Person(string n, int a) { name = n; age = a; }\n    void setName(string n) { name = n; }\n    void print() {\n      cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; endl;\n      cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; endl;\n    }\n};\nI want to create a class Student. The data for this class should be: name, age, and ID. The functions should be: setName(), print(), and setNameID().\nI can reuse some of the code.\nOption 1: From scratch.\nOption 2: Copy and paste code from Person class and add setNameID(). The issues are:\n\nUnderstand all details of Person.\nIf you change Person, no changes will be reflected to Student.\n\nOption 3: Inherit from Person. The benefits are:\n\nRe-use code.\nNeed to understand what Person does.\n\nPerson is a base class.\nStudent is a derived class.\nIn Student.h:\nclass Student : public Person {\n  private:\n    int ID;\n\n  // age and name are innaccessible\n\n  // we don't inherit constructors of Person\n\n  public:\n    Student() : Person() { ID = 0; }\n\n    // setName is inherited\n    void setNameID(string n, int d) {\n      Person::setName(n);\n      ID = d;\n    }\n\n    // method overriding: replace/redefine the inherited print() from Person\n    // we define our own version for Student\n    void print() {\n      cout &lt;&lt; \"ID: \" &lt;&lt; ID &lt;&lt; endl;\n\n      // I can't access age and name\n      Person::print();\n    }\n};\nIn main.cpp:\n#include \"Person.h\"\n#include \"Student.h\"\n\nusing namespace std;\n\nint main() {\n  Person p(\"Joe\", 23);\n\n  // name and age are inaccessible\n  Student s;\n\n  // 1. we construct Person object\n  // 2. On top of it, we construct Student object\n\n  // setName is inherited from Person, so we can call it on Student\n  s.setName(\"Ryan\");\n\n  s.setNameID(\"Marina\", 125);\n}"
  },
  {
    "objectID": "lecture27.html#summary",
    "href": "lecture27.html#summary",
    "title": "Lecture 27 - Nov 14, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we introduce a new pillar of object-oriented programming: inheritance. Inheritance is a process in which a class acquires all properties and behavior of the parent class."
  },
  {
    "objectID": "lecture27.html#last-lecture",
    "href": "lecture27.html#last-lecture",
    "title": "Lecture 27 - Nov 14, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nComplexity analysis."
  },
  {
    "objectID": "lecture27.html#today",
    "href": "lecture27.html#today",
    "title": "Lecture 27 - Nov 14, 2023",
    "section": "Today",
    "text": "Today\nInheritance."
  },
  {
    "objectID": "lecture27.html#inheritance",
    "href": "lecture27.html#inheritance",
    "title": "Lecture 27 - Nov 14, 2023",
    "section": "Inheritance",
    "text": "Inheritance\nInheritance is a process in which a class acquired all properties and behaviour of the parent class. This is one of the pillar of object-oriented programming.\nThis allows programmers to extend/improve existing classes without modifying the code of these classes.\n\n\n\n\n\n\nExample\n\n\n\nIn Person.h:\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person {\n private:\n  string name;\n  int age;\n\n public:\n  Person() {\n    name = \"\";\n    age = 0;\n  }\n  Person(string n, int a) {\n    name = n;\n    age = a;\n  }\n  void setName(string n) { name = n; }\n  void print() {\n    cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; endl;\n    cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; endl;\n  }\n};\nAfter we implemented the Person class, we want another class that is more specific to aStudent.\nThe Student class has data members of name, age, ID. We want the print() member function to print all these data members. We still want setName() to set the name of the student.\nOptions:\n\nWrite the Student class from scratch. Issue: Re-write code.\nCopy and paste the Person class and change it. Issue: You need to understand all the details of Person.\nInherit the Person class.\n\n\nBenefits: Re-use code and you need to understand what Person does (not the details)\nDisadvantage: Double-sided weapon. All updates to Person will affect Student.\n\nBase class is Person.\nDerived class is Student.\nIn Student.h:\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n                // inherit from Person class\nclass Student : public Person {\n private:\n  // string name and int age are inherited\n  // age and name are innaccessible  \n  int ID;\n\n  // we don't inherit constructors of Person\n\n public:\n  Student() { ID = 0; }\n  \n  // setName is inherited and accessible\n\n  void setNameID(string n, int d = 0) {\n    // name = n // no, name is not accessible\n    Person::setName(n);\n    ID = d;\n  }\n\n  // method overriding\n  // cancel/overwrite the print function inherited from Person\n  // we write our own\n  void print() {\n    // I can't access age and name\n    Person::print();\n    cout &lt;&lt; \"ID: \" &lt;&lt; ID &lt;&lt; endl;\n  }\n};\nAn overriding method, e.g. print, is not the same as an overloaded method. Overloaded function has different arguments and/or return type.\nStudent is inherited from Person. All data and function members, except for overridden print function.\nStudent cannot access private members of Person.\nIn main.cpp:\n#include \"Person.h\"\n#include \"Student.h\"\n\nusing namespace std;\n\nint main() {\n  Person p(\"Joe\", 23); // constructor of Person\n  Student s;  // 2 constructors are called\n  // 1st is Person() default constructor\n  // 2nd is Student() default constructor\n\n  p.setName(\"Joseph\");\n  p.print();  // from Person\n\n  s.setNameID(\"Ryan\");  // setNameID is inherited from Person\n  s.print();  // from Student\n              // we invoke print on Student object, hence we call print of\n              // Student, not of person\n\n  s.setNameID(\"Marina\", 125); // from Student\n  s.print(); // from Student\n\n  return 0;\n}\nThe type of s is Student and Person. The type of p is Person."
  },
  {
    "objectID": "lecture27.html#membership",
    "href": "lecture27.html#membership",
    "title": "Lecture 27 - Nov 16, 2023",
    "section": "Membership",
    "text": "Membership\nclass Student {\n  public:\n    Person p;\n};\n\nStudent s;\n\n// s is Student\n// s is NOT person"
  },
  {
    "objectID": "lecture27.html#inheritance-versus-membership",
    "href": "lecture27.html#inheritance-versus-membership",
    "title": "Lecture 27 - Nov 14, 2023",
    "section": "Inheritance versus membership",
    "text": "Inheritance versus membership\n\nInheritance\nInheritance represents an “is-a” relationship.\nExample: Student is a Person, as Student inherits from Person.\nclass Person {\n  ...\n\n};\n\nclass Student : public Person {\n  ...\n\n};\n\nStudent s;\ns.SetName();\n\n// s is Student\n// s is Person\n\n\nMembership\nMembership represents a “has-a” relationship.\nExample: Student has a member Person p.\nclass Student {\n  private:\n    Person p;\n};\n\nStudent s;\n\n// s is Student\n// s is NOT person"
  },
  {
    "objectID": "lecture27.html#access-different-constructors",
    "href": "lecture27.html#access-different-constructors",
    "title": "Lecture 27 - Nov 16, 2023",
    "section": "Access different constructors",
    "text": "Access different constructors\nWhat if I want to access a different Person constructor (not default)?\nclass Student : public Person {\n  private:\n    int ID;\n\n  public:\n    Student() { ID = 0; }\n    // or\n    // Student() : ID(0);\n\n    // call the 2nd constructor in Person\n    // between fun() and {, the space allows an initializer's list\n    Student(string n, int a, int d) : Person(n,a) {\n      ID = d;\n    }\n};"
  },
  {
    "objectID": "lecture28.html#summary",
    "href": "lecture28.html#summary",
    "title": "Lecture 28 - Nov 16, 2023",
    "section": "Summary",
    "text": "Summary\nIn this lecture, we continue our discussion on inheritance, data protection within a derived classes and pointers to derived classes."
  },
  {
    "objectID": "lecture28.html#last-lecture",
    "href": "lecture28.html#last-lecture",
    "title": "Lecture 28 - Nov 16, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nInheritance."
  },
  {
    "objectID": "lecture28.html#today",
    "href": "lecture28.html#today",
    "title": "Lecture 28 - Nov 16, 2023",
    "section": "Today",
    "text": "Today\nInheritance continuation.\nWe inherit the attributes from Person.\nWe do not inherit constructors.\nIf we create a new setName(), it will overwrite the previous one.\nIn Person.h:\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Person {\n private:\n  string name;\n  int age;\n\n public:\n  Person() {\n    name = \"\";\n    age = 0;\n  }\n\n  Person(string n, int a) {\n    name = n;\n    age = a;\n  }\n\n  void setName(string n) { name = n; }\n\n  void print() {\n    cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; endl;\n    cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; endl;\n  }\n};\nIn Student.h:\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Student : public Person {\n private:\n  int ID;\n\n  // age and name are innaccessible\n\n  // we don't inherit constructors of Person\n\n public:\n  Student() { ID = 0; }\n\n  // setName is inherited\n  \n  void setNameID(string n, int d = 0) {\n    Person::setName(n);\n    ID = d;\n  }\n\n  // cancel/overwrite the print function inherited from Person\n  // we write our own\n  void print() {\n    // I can't access age and name\n    Person::print();\n    cout &lt;&lt; \"ID: \" &lt;&lt; ID &lt;&lt; endl;\n  }\n\n  ~Student() { cout &lt;&lt; \"Student destructor\" &lt;&lt; endl; }\n};\nIn main.cpp:\n#include \"Person.h\"\n#include \"Student.h\"\n\nusing namespace std;\n\nint main() {\n  Person p(\"Joe\", 23);\n  Student s;  // 2 constructors are called\n  // 1st is Person() default constructor\n  // 2nd is Student() default constructor\n  p.setName(\"Joseph\");\n  p.print();  // print name and age\n\n  s.setNameID(\"Ryan\");  // setNameID is inherited from Person\n  s.print();  // we invoke print on Student object, hence we call print of\n              // Student, not of person\n\n  s.setNameID(\"Marina\", 125);\n  s.print();\n\n  return 0;\n}"
  },
  {
    "objectID": "lecture28.html#inheritance-versus-membership",
    "href": "lecture28.html#inheritance-versus-membership",
    "title": "Lecture 28 - Nov 16, 2023",
    "section": "Inheritance versus membership",
    "text": "Inheritance versus membership\n\nInheritance\nInheritance represents an “is-a” relationship.\nExample: Student is a Person, as Student inherits from Person.\nclass Person {\n  ...\n\n};\n\nclass Student : public Person {\n  ...\n\n};\n\nStudent s;\ns.SetName();\n\n// s is Student\n// s is Person\n\n\nMembership\nMembership represents a “has-a” relationship.\nExample: Student has a member Person p.\nclass Student {\n  private:\n    Person p;\n};\n\nStudent s;\n\n// s is Student\n// s is NOT person\n\n\nAccess different constructors\nWhat if I want to call a different Person constructor when I create a Student object?\nclass Student : public Person {\n  private:\n    int ID;\n\n  public:\n    Student() { ID = 0; }\n    // or\n    // Student() : ID(0);\n\n    // call the 2nd constructor in Person\n    // between fun() and {, the space allows an initializer's list\n    Student(string n, int a, int d) : Person(n,a) {\n      ID = d;\n    }\n};\n\nint main() {\n  // 1. Person(n,a)\n  // 2. Student(n,a,d)\n  Student s(\"Armaan\", 20, 354);\n}"
  },
  {
    "objectID": "lecture28.html#data-protection",
    "href": "lecture28.html#data-protection",
    "title": "Lecture 28 - Nov 16, 2023",
    "section": "Data protection",
    "text": "Data protection\nprotecteddata and function members are inherited and accessible to derived classes but not to all classes (somewhere between public and private).\nclass Person {\n  protected:\n    int age;\n    string name;\n};\n\nclass Student : public Person {\n  private:\n    int ID;\n  public:\n    Student(string n, int a, int d) {\n      Person::name = n;\n      Person::age = a;\n      ID = d;\n    }\n};\nImportant. We do not inherit\n\nConstructors: You can call them.\nCopy constructors\nOperator equal\nDestructors\n\n2-4: You can create derived’s own version of them.\nint main() {\n  Student s;\n  Person p;\n\n  p = s; // =&gt; p.operator=(s)\n         // Person& operator=(Person& rhs) { ... }\n\n  s = p; // =&gt; s.operator=(p) - LHS is student, RHS is person =&gt; ERROR\n}\nVery important. student is a Person and Student. person is a Person only.\nStudent* s1;\nPerson* p1;\n\np1 = &s;\np1 pointer can be used to access Person members which also exist in Student s.\np1-&gt;setName(\"Selim\"); // calls setName of Person\np1-&gt;print(); // calls print of Person\n// p1-&gt;setNameID(); // error, because setNameID is not a member of Person\ns1 pointer cannot access all Student members as not all of them exist in Person (base class).\n// s1 = &p; // error"
  },
  {
    "objectID": "lecture29.html#recap",
    "href": "lecture29.html#recap",
    "title": "Lecture 29 - Nov 17, 2023",
    "section": "Recap",
    "text": "Recap\nWhat of I want to call a different Person constructor when I create a Student object?\nclass Student : public Person {\n private:\n  int ID;\n\n public:\n  Student() { ID = 0; }\n  // or\n  Student() : Person(), ID(0) { }\n\n  // initializer's list after the :\n  Student(string n, int a, int d) : Person(n,a) {\n    ID = d;\n  }\n};\n\nint main() {\n  Student s(\"Armaan\", 20, 354);\n  // 1. Person(n,a)\n  // 2. Student(n,a,d)\n}\nWe have data (private data members) that is inaccesible from the base class.\nThere is a way to inherit data members and make all of it accessible in the derived class, but mainstain privacy to this data in other classes.\nclass Person {\n  protected:\n    // inherited and accessible\n    int age;\n    string name;\n};\n\nclass Student : public Person {\n  protected:\n    int ID;\n\n  public:\n    Student(string n, int a, int d) {\n      Person::name = n;\n      Person::age = a;\n      ID = d;\n    }\n};\n\nStudent s(\"Armaan\", 20, 354);\n\n// s.name will not work\n// name is a protected member of Person\n// it can't be accessed outside of Person and Student\n::: {.callout-note icon=false} ## Example\nMultiple inheritances: Insert wheel image with wheel circle radius.\nclass Circle {\n  protected:\n    int radius;\n\n  public:\n    void print() { cout &lt;&lt; \"Circle\" &lt;&lt; radius &lt;&lt; endl; }\n};\n\nclass Wheel : public Circle {\n  // inherits radius and print\n\n  protected:\n    int radius; // another variable with identical name to inherited radius\n\n  public:\n    Wheel(int rw) {\n      radius = rw;\n    }\n\n    Wheel(int rc, int rw) : Circle(rc) { \n      radius = rw;\n    }\n\n    void print() {\n      // radius of circle\n      Circle::print();\n      \n      // radius of wheel\n      cout &lt;&lt; \"Wheel\" &lt;&lt; radius &lt;&lt; endl;\n    }\n}\n\nclass Tire : public Wheel {\n  // inherits radius of wheel, radius of circle, and print of wheel\n  protected:\n    int radius;\n\n  public:\n    Tire(int rc, int rw, int rt) : Wheel(rc, rw) { \n      radius = rt;\n    }\n\n    Tire(int rc, int rw, int rt) : Wheel(rw), Circle(rc) {\n      radius = rt;\n    }\n\n    void print() {\n      Wheel::print();\n      cout &lt;&lt; \"Tire\" &lt;&lt; radius &lt;&lt; endl;\n    }\n\n    void set(int rc, int rw, int rt) {\n      Circle::radius = rc;\n      Wheel::radius = rw;\n      radius = rt;\n    }\n};\n\nint main() {\n  Tire t; // 1. Default constructor of Circle\n          // 2. Default constructor of Wheel\n          // 3. Default constructor of Tire is called\n          //    It's provided by the compiler\n\n  t.set(3,4,6); // circle = 3, wheel = 4, tire = 6\n  t.print();\n}"
  },
  {
    "objectID": "lecture29.html#class-hierarchy",
    "href": "lecture29.html#class-hierarchy",
    "title": "Lecture 29 - Nov 17, 2023",
    "section": "Class hierarchy",
    "text": "Class hierarchy\nADD DIAGRAM\nclass Person {\n  // ...\n};\n\nclass Student : public Person {\n  // ...\n}\n\nclass Employee : public Person {\n  // ...\n}\n\nclass Grad : public Student {\n  // ...\n}\n\nclass TA : public Grad, public Employee {\n  // ...\n}"
  },
  {
    "objectID": "lecture29.html#pointers-to-dynamic-memory-in-a-derived-class",
    "href": "lecture29.html#pointers-to-dynamic-memory-in-a-derived-class",
    "title": "Lecture 29 - Nov 17, 2023",
    "section": "Pointers to dynamic memory in a derived class",
    "text": "Pointers to dynamic memory in a derived class\nWe do not inherit\n\nConstructors\nCopy constructors\nOperator equal\nDestructors\n\n1: Specify. 2-4: We have to create our own if we need to."
  },
  {
    "objectID": "lecture29.html#today",
    "href": "lecture29.html#today",
    "title": "Lecture 29 - Nov 17, 2023",
    "section": "Today",
    "text": "Today\nInheritance continuation"
  },
  {
    "objectID": "lecture30.html#last-lecture",
    "href": "lecture30.html#last-lecture",
    "title": "Lecture 30 - Nov 21, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nInheritance continuation and polymorphism"
  },
  {
    "objectID": "lecture30.html#today",
    "href": "lecture30.html#today",
    "title": "Lecture 30 - Nov 21, 2023",
    "section": "Today",
    "text": "Today\nDynamic memory allocation and polymorphism"
  },
  {
    "objectID": "lecture30.html#pointers-to-dynamic-memory-in-derived-class",
    "href": "lecture30.html#pointers-to-dynamic-memory-in-derived-class",
    "title": "Lecture 30 - Nov 21, 2023",
    "section": "Pointers to dynamic memory in derived class",
    "text": "Pointers to dynamic memory in derived class\nWhen a class has members that point to dynamically allocated memory , we should have our own operator= and copy constructor.\nclass Person {\n  private:\n    int age;\n    char* name;\n\n  public:\n    // asume Person() and Person(int, char*) are implemented\n    Person(const Person& original) {\n      name = new char[strlen(original.name) + 1];\n      strcpy(name, original.name);\n      age = original.age;\n    }\n\n    Person& operator=(const Person& rhs) {\n      if (&rhs == this) {\n        return *this;\n      }\n      delete[] name;\n      name = new charr[strlen(rhs.name) + 1];\n      strcpy(name, rhs.name);\n      age = rhs.age;\n      return *this;\n    }\n\n    ~Person() {\n      delete[] name;\n    }\n}\n\nclass Student : public Person {\n  private:\n    int ID;\n\n  public:\n    // assume Student() and Student(int, char*, int) are implemented\n    // You have to explicitly call the copy constructor\n    // Otherwise, the default copy constructor will be called\n    Student(const Student& original) : Person(original) {\n      ID = original.ID;\n    }\n\n    Student& operator=(const Student& rhs) {\n      // rhs is also Person we can pass it to operator= of Person\n      Person::operator=(rhs);\n      ID = rhs.ID;\n      return *this;\n    }\n}"
  },
  {
    "objectID": "lecture30.html#dynamic-versus-static-binding",
    "href": "lecture30.html#dynamic-versus-static-binding",
    "title": "Lecture 30 - Nov 21, 2023",
    "section": "Dynamic versus static binding",
    "text": "Dynamic versus static binding\nclass Polygon {\n  protected:\n    int width, height;\n\n  public:\n    void set(int w, int h) {\n      width = w;\n      height = h;\n    }\n};\n\nclass Rectangle : public Polygon {\n  public:\n    int area() {\n      return width * height;\n    }\n};\n\nclass Triangle : public Polygon {\n  public:\n    int area() {\n      return width * height / 2;\n    }\n};\n\nint main() {\n  Polygon p;\n  Rectangle r;\n\n  p = r; // p.operator = (s)\n         // p = polygon\n         // s = rectangle\n         // ok\n         // Polygon& operator=(Polygon& rhs) { ... }\n\n  r = p; // r.operator = (p)\n         // r = rectangle\n         // p = polygon - not rectangle\n         // error\n\n  // important\n  // rectangle: polygon and rectangle too\n  // polygon: polygon only\n\n  Rectangle* r1;\n  Polygon* p1;\n  pl = &r;\n\n  // p1 pointer can be used to access Polygon members which also exist in rectangle\n\n  p1 &lt;- set(3,4); // calls set of Polygon - ok\n\n  cout &lt;&lt; p1 -&gt; area(); // error as area() is a member of Rectangle, not Polygon\n\n  r1 = &p; // error\n\n  // r1 pointer cannot access all Rectangle members as not all of them exist in\n  // Polygon p (base class)\n}\nProblem: we cannot access members of a Derived object if the pointer pointing to it is of Base* type.\nSolution: virtual functions."
  },
  {
    "objectID": "lecture30.html#virtual-functions",
    "href": "lecture30.html#virtual-functions",
    "title": "Lecture 30 - Nov 21, 2023",
    "section": "Virtual functions",
    "text": "Virtual functions\nIf a function is declared as a virtual function in the base class, then redefined or overriden in a derived class, a class to that function through a Base* pointer will invoke the function depending on the type of object (not pointer).\nclass Polygon {\n  protected:\n    int width, height;\n\n  public:\n    void set(int w, int h) {\n      width = w;\n      height = h;\n    }\n\n    virtual int area() {\n      return 0;\n    }\n};\n\np1 -&gt; area(); // will invoke the area function of what p1 is pointing to\n              // i.e., Rectangle = 12\n\n// if we remove virtual\n// p1 -&gt; area() and p2 -&gt; area() will both return 0\nNon-virtual functions are invoked depending on the type of pointer. This is known at compile-time.\nVirtual functions are invoked depending on the type the pointer points to. This is known at run-time.\nA class that inherits a virtual function is called polymorphic class (e.g., Rectangle and Triangle).\nWhy is this helpful? We can have an array of Polygon* and have different shapes on it.\n\nfor (int i = 0; i &lt; 5; i++) {\n  cout &lt;&lt; a[i] -&gt; area(); // will print out area according to shape\n}"
  },
  {
    "objectID": "lecture31.html#last-lecture",
    "href": "lecture31.html#last-lecture",
    "title": "Lecture 31 - Nov 23, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nInheritance continuation and polymorphism."
  },
  {
    "objectID": "lecture31.html#today",
    "href": "lecture31.html#today",
    "title": "Lecture 31 - Nov 23, 2023",
    "section": "Today",
    "text": "Today\nVirtual functions and abstract classes."
  },
  {
    "objectID": "lecture31.html#recap",
    "href": "lecture31.html#recap",
    "title": "Lecture 31 - Nov 23, 2023",
    "section": "Recap",
    "text": "Recap\nclass Polygon {\n  protected:\n    int width, height;\n\n  public:\n    void set(int w, int h) {\n      width = w;\n      height = h;\n    }\n};\n\nclass Rectangle: public Polygon {\n  public:\n    int area() {\n      return width * height;\n    }\n};\n\nclass Triangle : public Polygon {\n  public:\n    int area() {\n      return width * height / 2;\n    }\n};\n\nint main() {\n  Rectangle r; r.set(3,4); Polygon* pr = &r;\n  cout &lt;&lt; pr -&gt; area(); // cannot invoke area as it is a member of Rectangle\n}\nProblem: We cannot access members of a Derived object if the pointer pointing to it is of Base* type.\nSolution: If a function is declared as a virtual function in base class, and redefined/overriden in derived class, a call to that function through a Base* pointer will invoke the function depending on the type of object (not pointer).\nclass Polygon {\n  protected:\n    int width, height;\n\n  public:\n    void set(int w, int h) {\n      width = w;\n      height = h;\n    }\n    virtual int area() = 0;\n    // if we remove virtual p1 -&gt; area() will return 0\n}\nNon-virtual functions are invoked depending on the type of pointer. This is known at compile time.\nVirtual function are invoked depending on the type the pointer points to. This is known at run time.\nA class that inherits a virtual function is called polymorphic class (e.g., Rectangle and Triangle)\n\nfor (int i = 0; i &lt; 3; i++) {\n  cout &lt;&lt; a[i] -&gt; area(); // will print out area according to shape\n}\nIf the function is virtual, it is also the destructor.\nclass Polygon {\n  protected:\n    int width;\n\n  public:\n    virtual ~Polygon() {}; // does nothing\n};\n\nclass Rectangle:public Polygon {\n  protected:\n    int* length;\n\n  public:\n    Rectangle() {\n      length = new int;\n    }\n\n    ~Rectangle() {\n      delete length;\n    }\n};\n\nint main() {\n  Polygon* p = new Rectangle;\n  delete p; // if the destructor was not virtual\n            // the destructor of Polygon will be called\n            // and the length will not be freed\n  return 0;\n}\nProblem: This neccessitates that we implement the area() function in Polygon. We may need Polygon class to exist with some functions, but never implement these functions as we will not need them.\nclass Polygon {\n  protected:\n    int width, length;\n\n  public:\n    void set(int w, int l) { ... };\n    virtual int area() = 0; // pure virtual function\n};\nA class with a pure virtual function is an abstract class.\nYou cannot instantiate an object of an abstract class.\nPolygon p; is incorrect as p is of abstract class.\nRectangle r;\nPolygon* pr = &r;\ncout &lt;&lt; pr -&gt; area(); // will invoke Rectangle::area()"
  },
  {
    "objectID": "lecture32.html#last-lecture",
    "href": "lecture32.html#last-lecture",
    "title": "Lecture 32 - Nov 24, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nInheritance."
  },
  {
    "objectID": "lecture32.html#today",
    "href": "lecture32.html#today",
    "title": "Lecture 32 - Nov 24, 2023",
    "section": "Today",
    "text": "Today\nBinary trees.\nRecall: We used linked lists to have a more dynamic and flexible data structure to store information.\nHowever, the way a data structure is organized can “speed up” or “slow down” the run time of some operations like searching, inserting, and deleting nodes."
  },
  {
    "objectID": "lecture32.html#trees",
    "href": "lecture32.html#trees",
    "title": "Lecture 32 - Nov 24, 2023",
    "section": "Trees",
    "text": "Trees\nTrees is another data structure that stores data for different purposes (e.g., to store directories/files in Unix)"
  },
  {
    "objectID": "lecture32.html#properties-of-trees",
    "href": "lecture32.html#properties-of-trees",
    "title": "Lecture 32 - Nov 24, 2023",
    "section": "Properties of trees",
    "text": "Properties of trees\n\nHave nodes and edges connect nodes\nHave no cycles\nHave 1 parent, multiple children\nHave 1 root (or empty trees have no root)\n\nThis is a tree\n  A\n /\nB\nThis is not a tree (cycle)\n  A\n / \\\nB - C"
  },
  {
    "objectID": "lecture32.html#binary-trees",
    "href": "lecture32.html#binary-trees",
    "title": "Lecture 32 - Nov 24, 2023",
    "section": "Binary trees",
    "text": "Binary trees\n\nThe root is at the top and leaves are at the bottom\nEach node stores some data\nEach node has at most 2 child nodes, and one parent (Except root)\nAn edge links a node to its children\nNodes with no children are leaf nodes\n\n\nIn binary search trees (BST), an additional feature is that for every node:\n\nAll nodes in the left subtree have values less than the node’s value\nAll nodes in the right subtree have values greater than the node’s value\n\nFacts:\n\nThe minimum value is in the most left node\nThe maximum value is in the most right node\n\nAs opposed to linked lists and arrays, BST is organized in such a way that allows quick search.\n\n\n\n\n\n\nExample\n\n\n\nSearch for a number \\(x\\)\n\\(T(n) = O(n)\\), where \\(n\\) is the size of the array\n1 | 3 | 4 | 8 | 9 | 10 | 11\nStart from the root\n     8\n   /   \\\n  3     10\n / \\   /  \\\n1   4 9    11\nIf \\(x&lt;8\\), go left If \\(x&gt;8\\), go right\nWorst case will find \\(x\\) at a left node.\n\\(\\text{No. of steps} = \\text{height of BST}\\)"
  },
  {
    "objectID": "lecture32.html#complexity-cases",
    "href": "lecture32.html#complexity-cases",
    "title": "Lecture 32 - Nov 24, 2023",
    "section": "Complexity cases",
    "text": "Complexity cases\nIf BST\n      8\n     /\n    4\n   /\n  3\n /\n1 \nHeight is \\(n\\). Then \\(T(n) = O(n)\\), like arrays or linked lists.\nIf BST\n     8\n   /   \\\n  3     10\n / \\   /  \\\n1   4 9    11\nHeight is \\(\\log(n)\\). Then \\(T(n) = O(\\log(n))\\)."
  },
  {
    "objectID": "lecture32.html#bst-implementation",
    "href": "lecture32.html#bst-implementation",
    "title": "Lecture 32 - Nov 24, 2023",
    "section": "BST implementation",
    "text": "BST implementation\nclass BSTNode {\n  private:\n    int value;\n    BSTNode *left, *right;\n\n  public:\n    BSTNode(int v) { value = v; left = right = NULL; }\n    ~BSTnode() { delete left; delete right; }\n    int getValue() { return value; }\n    BSTNode *getRight() { return left; }\n    BSTNode *getLeft() { return left; }\n    void setRight(BSTNode *r) { right = r; }\n    void setLeft(BSTNode *l) { left = l; }\n};\n\nclass BSTree {\n  private:\n    BSTNode* root;\n    bool searchNode(int v, BSTNode *n) {\n      if (n == NULL) {\n        return false;\n      } else if (n-&gt;getValue() == v) {\n        return true;\n      } else if (n-&gt;getValue() &gt; v) {\n        return searchNode(v, n-&gt;getLeft());\n      } else {\n        return searchNode(v, n-&gt;getRight());\n      } \n    }\n  \n  public:\n    BSTree() { root = NULL; }\n    ~BSTree() { delete root; }\n    BSTNode* getRoot() { return root; }\n    bool search(int v) { return searchNode(v, root); }\n    \n    // next lecture: print insert\n}"
  },
  {
    "objectID": "lecture33.html#last-lecture",
    "href": "lecture33.html#last-lecture",
    "title": "Lecture 33 - Nov 28, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nIntroduction to trees, binary trees and binary search trees.\nSearch."
  },
  {
    "objectID": "lecture33.html#today",
    "href": "lecture33.html#today",
    "title": "Lecture 33 - Nov 28, 2023",
    "section": "Today",
    "text": "Today\nRecursive print and insert operations in binary search trees."
  },
  {
    "objectID": "lecture34.html#last-lecture",
    "href": "lecture34.html#last-lecture",
    "title": "Lecture 34 - Nov 30, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nBST (insert and print)"
  },
  {
    "objectID": "lecture34.html#today",
    "href": "lecture34.html#today",
    "title": "Lecture 34 - Nov 30, 2023",
    "section": "Today",
    "text": "Today\nDelete a node in a BST."
  },
  {
    "objectID": "lecture33.html#recursive-print-and-insert-in-bst",
    "href": "lecture33.html#recursive-print-and-insert-in-bst",
    "title": "Lecture 33 - Nov 28, 2023",
    "section": "Recursive print and insert in BST",
    "text": "Recursive print and insert in BST\n     8\n   /   \\\n  4     10\n / \\      \\\n1   6      12\nclass BSTNode {\n  private:\n    int value;\n    BSTNode *left, *right;\n  \n  public:\n    BSTNode(int v) {\n      value v;\n      left = right = NULL;\n    }\n    ~BSTNode() {\n      delete left;\n      delete right;\n    }\n    int getValue() {\n      return value;\n    }\n    BSTNode *getLeft() {\n      return left;\n    }\n    BSTNode *getRight() {\n      return right;\n    }\n    void setLeft(BSTNode *l) {\n      left = l;\n    }\n    void setRight(BSTNode *r) {\n      right = r;\n    }\n};\n\nclass BSTree {\n  private:\n    BSTNode* root;\n\n    bool searchNode(int v, BSTNode* n) {\n      if (n == NULL) {\n        return false;\n      } else if (n-&gt;getValue() == v) {\n        return true;\n      } else if (n-&gt;getValue() &gt; v) {\n        return searchNode(v, n-&gt;getLeft());\n      } else {\n        return searchNode(v, n-&gt;getRight());\n      }\n    }\n\n    void insertHelper(int v, BSTNode* n);\n    void printInOrderHelper(BSTNode* n);\n\n  public:\n    BSTree() {\n      root = NULL;\n    }\n    ~BSTree() {\n      delete root;\n    }\n    BSTNode* getRoot() {\n      return root;\n    }\n    bool search(int v) {\n      return searchNode(v, root);\n    }\n    void insert(int v);\n    void printInOrder();\n};\n\nvoid BSTree::insertHelper(int v, BSTNode* n) {\n  if (n-&gt;getValue() == v) {\n    return; // no two nodes have the same value\n  } else if (v &lt; n-&gt;getValue()) {\n    if (n-&gt;getLeft() == NULL) {\n      n-&gt;setLeft(new BSTNode(v)); // insert to the left of a leaf node\n    } else {\n      insertHelper(v, n-&gt;getLeft());\n    }\n  } else {\n    if (n-&gt;getRight() == NULL) {\n      n-&gt;setRight(new BSTNode(v)); // insert to the right of a leaf node\n    } else {\n      insertHelper(v, n-&gt;getRight());\n    }\n  }\n}\n\nvoid BSTree::printInOrderHelper(BSTNode* n) {\n  if (n != NULL) {\n    print(n-&gt;getLeft());\n    cout &lt;&lt; n-&gt;getValue() &lt;&lt; \" \";\n    print(n-&gt;getRight());\n  }\n}\nprint(8)\n|- print(4)\n|  |- print(NULL)\n|  |- cout &lt;&lt; 4\n|  |- print(6)\n|     |- print(NULL)\n|     |- cout &lt;&lt; 6\n|     |- print(NULL)\n|- cout &lt;&lt; 8\n|- print(10)\n   |- print(NULL)\n   |- cout &lt;&lt; 10\n   |- print(NULL)\nvoid BSTree::printInOrder() {\n  return printInOrderHelper(root);\n}\nWe may print the BST in different orders\nvoid BSTree::printPreOrderHelper(BSTNode* n) {\n  if (n != NULL) {\n    cout &lt;&lt; n-&gt;getValue() &lt;&lt; \" \";\n    printPreOrder(n-&gt;getLeft());\n    printPreOrder(n-&gt;getRight());\n  }\n}\n| 8 | 4 | 6 | 10 |\nprints node first, then left, then right subtree\nvoid BSTree::printPostOrderHelper(BSTNode* n) {\n  if (n != NULL) {\n    printPostOrder(n-&gt;getLeft());\n    printPostOrder(n-&gt;getRight());\n    cout &lt;&lt; n-&gt;getValue() &lt;&lt; \" \";\n  }\n}\n| 6 | 4 | 10 | 8 |\nprints left subtree first, then right, then node\nHomework: Implement minValueNode and maxValueNode.\nBSTNode* BSTree::minValueNode(BSTNode* n) {\n  return minValueNodeHelper(n-&gt;getLeft());\n}\n\n\n\n\n\n\nPacha’s note\n\n\n\nHere is the implementation of minValueNodeHelper:\nBSTNode* BSTree::minValueNodeHelper(BSTNode* n) {\n  // n != NULL in case the root is NULL\n  if (n != NULL && n-&gt;getLeft() !== NULL) {\n    return minValueNodeHelper(n-&gt;getLeft());\n  } else {\n    return n;\n  }\n}\nBSTNode* BSTree::maxValueNode(BSTNode* n) {\n  return maxValueNodeHelper(n-&gt;getRight());\n}\n\nBSTNode* BSTree::maxValueNodeHelper(BSTNode* n) {\n  if (n != NULL && n-&gt;getRight() !== NULL) {\n    return maxValueNodeHelper(n-&gt;getRight());\n  } else {\n    return n;\n  }\n}"
  },
  {
    "objectID": "lecture34.html#node-deletion-in-bst",
    "href": "lecture34.html#node-deletion-in-bst",
    "title": "Lecture 34 - Nov 30, 2023",
    "section": "Node deletion in BST",
    "text": "Node deletion in BST\nclass BSTNode {\n  private:\n    int value;\n    BSTNode *left, *right;\n\n  public:\n    BSTNode(int v) { value = v; left = right = NULL; }\n    ~BSTNode() { delete left; delete right; }\n    int getValue() { return value; }\n    BSTNode *getLeft() { return left; }\n    BSTNode *getRight() { return right; }\n    void setLeft(BSTNode *l) { left = l; }\n    void setRight(BSTNode *r) { right = r; }\n};\n\nclass BSTree {\n  private:\n    BSTNode *root;\n    bool searchNode(int v, BSTNode *n);\n    void insertHelper(int v, BSTNode *n);\n    void printInOrderHelper(BSTNode *n);\n    BSTNode* minValueNodeHelper(BSTNode *n);\n  \n  public:\n    BSTree() { root = NULL; }\n    ~BSTree() { delete root; }\n    BSTNode* getRoot() { return root; }\n    bool search(int v);\n    void insert(int v);\n    void printInOrder();\n    BSTNode* minValueNode();\n};\n\nBSTNode* BSTree::minValueNode() {\n  return minValueNodeHelper(root);\n}\n\nBSTNode* BSTree::minValueNodeHelper(BSTNode* p) {\n  // p != NULL in case the root is NULL\n  if (p != NULL && p-&gt;getLeft() != NULL) {\n    return minValueNodeHelper(p-&gt;getLeft());\n  } else {\n    return p;\n  }\n}\nTo delete a node in a BST, we have to make sure the properties of a BST are maintained when the node is removed.\n\nFind the node\nIf the node has no children, delete node and update parent node pointer\n\n     8\n   /   \\\n  3     10\n / \\      \\\n1   6      14\n   / \\    /\n  4   7 13\nFor example, nodes 1, 4, 7 and 13.\n\nIf the node has only one subtree, make the parent node point to the parent of the subtree\n\nFor example, nodes 10 and 14.\n\nIf the node has two subtrees, replace the node data with the minimum in the right subtree, delete the node with the minimum value in the right subtree\n\nFor example, delete 3.\n     8\n   /   \\\n  4     10\n / \\      \\\n1   6      14\n     \\    /\n      7 13\nCould 4 have children? Yes, in the right subtree. Delete 4 by calling the delete node function on 4.\n     8\n   /   \\\n  4     10\n / \\      \\\n1   6      14\n   / \\    /\n  5   7 13\nBSTNode* BSTree::deleteNode(int v, BSTNode* node) {\n  if (node == NULL) {\n    return node;\n  }\n\n  if (v &lt; node-&gt;getValue()) {\n    node-&gt;setLeft(deleteNode(v, node-&gt;getLeft()));\n  } else if (v &gt; node-&gt;getValue()) {\n    node-&gt;setRight(deleteNode(v, node-&gt;getRight()));\n  } else {\n    // one or no children\n    if (node-&gt;getLeft() == NULL) {\n      BSTNode* temp = node-&gt;getRight();\n      node-&gt;setRight(NULL);\n      delete node;\n      return temp; // want to put it in the BST back\n    } else if (node-&gt;getRight() == NULL) {\n      // one child on left\n      BSTNode* temp = node-&gt;getLeft();\n      delete node;\n      return temp; // we want to put it in the BST back\n    } else {\n      // node has two children\n      BSTNode* temp = minValue(node-&gt;getRight());\n      node-&gt;setValue(temp-&gt;getValue());\n      // look in the right subtree\n      node-&gt;setRight(deleteNode(temp-&gt;getValue(), node-&gt;getRight()));\n    }\n  }\n\n  return node;\n}\nTrace:\nBefore\n   3\n /   \\\n1     6\n     / \\\n    4   7\n     \\\n      5\nAfter\n   3\n /   \\\n1     6\n     / \\\n    5   7"
  },
  {
    "objectID": "lecture35.html#last-lecture",
    "href": "lecture35.html#last-lecture",
    "title": "Lecture 35 - Dec 1, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nDelete a node in BST."
  },
  {
    "objectID": "lecture35.html#today",
    "href": "lecture35.html#today",
    "title": "Lecture 35 - Dec 1, 2023",
    "section": "Today",
    "text": "Today\nHash tables"
  },
  {
    "objectID": "lecture35.html#data-structures-and-run-time-of-operations",
    "href": "lecture35.html#data-structures-and-run-time-of-operations",
    "title": "Lecture 35 - Dec 1, 2023",
    "section": "Data structures and run time of operations",
    "text": "Data structures and run time of operations\n       | Unsorted List | Sorted List | BST      |\nInsert | O(1)          | O(n)        | O(log n) |\nSearch | O(n)          | O(log n)    | O(log n) |"
  },
  {
    "objectID": "lecture35.html#hash-tables",
    "href": "lecture35.html#hash-tables",
    "title": "Lecture 35 - Dec 1, 2023",
    "section": "Hash tables",
    "text": "Hash tables\nHash tables provides average performance on search/insert/deletion.\n\nVery large array\nEach key maps to a unique index\nHash function \\(h(k)\\) maps key to array index\n\nExample: \\(h(k) = k \\% (m + 1)\\)\nUse cases:\n\nDatabases\nCaching\n\nIn both cases quick data retrieval is critical.\nExample: \\(h(key) = k \\% 7\\)\ninsert(16): h(16) = 2\ninsert(25): h(25) = 4\ninsert(77): h(77) = 0\ninsert(7): h(7) = 2\n0 | 77\n1 |\n2 | 16\n3 |\n4 | 25\n5 |\n6 |"
  },
  {
    "objectID": "lecture35.html#problem",
    "href": "lecture35.html#problem",
    "title": "Lecture 35 - Dec 1, 2023",
    "section": "Problem",
    "text": "Problem\nCollision happens when two keys map to the same index."
  },
  {
    "objectID": "lecture35.html#solution-1-hashing-with-chaining",
    "href": "lecture35.html#solution-1-hashing-with-chaining",
    "title": "Lecture 35 - Dec 1, 2023",
    "section": "Solution 1: Hashing with chaining",
    "text": "Solution 1: Hashing with chaining\nEach hash table entry contrains a pointer to a linked list of keys that map to the same entry.\nBut we may have collisions always and one array entry has a linked list of all keys. This leads to an \\(O(n)\\) search.\nUsually, good hash functions can reduce the number of collisions. Ideally, we want the length of each linked list to be one maximum.\nUsually, good hash function involve multiplying key with large prime number (e.g., \\(h(k) = 3k \\% m\\), where \\(m\\) is the size of the array)\n0 | 77 -&gt; 7\n1\n2 | 16\n3\n4 | 25\n5\n6\nclass Node {\n  // for simplicity, all data members are public\n  public:\n    int key;\n    Node *next;\n    ~Node() { delete next; }\n};\n\nclass List {\n  public:\n    List(); // sets head to NULL\n    bool isEmpty(); // returns true if head is NULL\n    void insert(int v); // inserts at head\n    ListNode* remove(int k); // removes first node with key = k\n    bool isFound(int k); // returns true if key k is found\n    ~List();\n};\n\n#define SIZE 7\n\nclass HashTable {\n  private:\n    List** table;\n  public:\n    HashTable() {\n      table = new List*[SIZE];\n      for (int i = 0; i &lt; SIZE; i++) {\n        table[i] = NULL;\n      }\n    }\n\n    bool search(int v) {\n      int idx = v % SIZE;\n      if (table[idx] != NULL) {\n        // table[idx] is of class List*\n        return table[idx]-&gt;isFound(v);\n      } else {\n        return false; // the list where v should be is not there\n      }\n    }\n\n    void insert(int v) {\n      if (search(v)) { // value already there\n        return;\n      } else {\n        int idx = v % SIZE;\n        if (table[idx] == NULL) {\n          table[idx] = new List();\n        }\n        // table[idx] is of class List*\n        table[idx]-&gt;insert(v);\n      }\n    }\n\n    ~HashTable() {\n      for (int i = 0; i &lt; SIZE; i++) {\n        delete table[i];\n      }\n      delete[] table;\n    }\n\n    void remove(int v);\n};\nDIAGRAM PENDING\nHomework: Implement remove for HashTable.\n\n\n\n\n\n\nPacha’s note\n\n\n\nHere is the implementation\nListNode* List::remove(int k) {\n  if (isEmpty()) {\n    return NULL;\n  }\n\n  Node *current = head;\n  Node *previous = NULL;\n\n  while (current != NULL && current-&gt;key != k) {\n    previous = current;\n    current = current-&gt;next;\n  }\n\n  if (current == NULL) {\n    return NULL; // key not found in the list\n  }\n\n  if (previous == NULL) {\n    // The node to be removed is the head\n    head = current-&gt;next;\n  } else {\n    // The node to be removed is not the head\n    previous-&gt;next = current-&gt;next;\n  }\n\n  current-&gt;next = NULL; // Prevent recursive deletion of the entire list\n  return current; // Return the removed node\n}"
  },
  {
    "objectID": "lecture35.html#solution-2-closed-hashing-with-linear-probing",
    "href": "lecture35.html#solution-2-closed-hashing-with-linear-probing",
    "title": "Lecture 35 - Dec 1, 2023",
    "section": "Solution 2: Closed hashing with linear probing",
    "text": "Solution 2: Closed hashing with linear probing\nIf hash function lead to collision, insert value at the next available space in the table.\n\n\n\n\n\n\nExample\n\n\n\n\nIf it collides at \\(h(k)\\) then try \\([h(k) + 1] \\% SIZE\\)\nIf it collides at \\(h(k)\\) then try \\([h(k) + 2] \\% SIZE\\)\nIf it collides at \\(h(k)\\) then try \\([h(k) + 3] \\% SIZE\\)\n\n\n\nLinear probing is used tp find the next available space in the table."
  },
  {
    "objectID": "lecture35.html#additional-code-from-the-class",
    "href": "lecture35.html#additional-code-from-the-class",
    "title": "Lecture 35 - Dec 1, 2023",
    "section": "Additional code from the class",
    "text": "Additional code from the class\nList.h:\n#ifndef LIST_H_\n#define LIST_H_\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Node {\n public:\n  int key;\n  Node* next;\n  ~Node(){delete next;}\n};\n\nclass List {\n private:\n  Node* head;\n\n public:\n  List(){head = NULL;}\n\n  bool isFound(int k) {\n    Node* p = head;\n    while (p != NULL) {\n      // cout &lt;&lt; \"p-&gt;name is \" &lt;&lt; p-&gt;name &lt;&lt; \" and name is \" &lt;&lt; name &lt;&lt; endl;\n      if (p-&gt;key == k) {\n        return true;\n      }\n      p = p-&gt;next;\n    }\n    return false;\n  }\n  Node* remove(int v) {\n    Node* p = head;\n    Node* prev = NULL;\n    while (p != NULL) {\n      if (p-&gt;key == v) {\n        if (prev != NULL) {\n          prev-&gt;next = p-&gt;next;\n          p-&gt;next = NULL;\n        } else {\n          head = p-&gt;next;\n          p-&gt;next = NULL;\n        }\n        return p;\n      }\n      prev = p;\n      p = p-&gt;next;\n    }\n    return NULL;\n  }\n  void insert(int v) {\n    Node* node = new Node;\n    node-&gt;key = v;\n    node-&gt;next = NULL;\n    node-&gt;next = head;\n    head = node;\n  }\n  void print(){\n    Node* current = head;\n    while(current != NULL){\n        cout &lt;&lt; current-&gt;key &lt;&lt; \" \";\n        current = current-&gt;next;\n    }\n    cout &lt;&lt; endl;\n  }\n  ~List() { delete head; }\n};\n\n#endif\nHashTable.h:\n#ifndef HASH_H_\n#define HASH_H_\n#define SIZE 7\n#include \"List.h\"\n\nclass HashTable {\n private:\n  List** table;\n\n public:\n  HashTable() {\n    table = new List*[SIZE];\n    for (int i = 0; i &lt; SIZE; i++) {\n      table[i] = NULL;\n    }\n  }\n  bool search(int v) {\n    int idx = v % SIZE;\n    if (table[idx] != NULL) {\n      return table[idx]-&gt;isFound(v);\n    } else {\n      return false;\n    }\n  }\n  void insert(int v) {\n    if (search(v)) {\n      return;\n    } else {\n      int idx = v % SIZE;\n      if (table[idx] == NULL) {\n        table[idx] = new List;\n      }\n      table[idx]-&gt;insert(v);\n    }\n  }\n  void display() {\n    for (int i = 0; i &lt; SIZE; i++) {\n      if (table[i] != NULL) {\n        table[i]-&gt;print();\n      }\n    }\n  }\n  void remove(int v) {\n    if (!search(v)) {\n      return;\n    } else {\n      int idx = v % SIZE;\n      if (table[idx] == NULL) {\n        return;\n      } else {\n        delete table[idx]-&gt;remove(v);\n      }\n    }\n  }\n  ~HashTable() {\n    for (int i = 0; i &lt; SIZE; i++) {\n      delete table[i];\n    }\n    delete[] table;\n  }\n};\n\n#endif\nmain.cpp:\n#include &lt;iostream&gt;\n#include \"HashTable.h\"\nusing namespace std;\n\nint main(){\n    HashTable H;\n    H.insert(4);\n    H.insert(7);\n    H.insert(77);\n    \n    H.remove(77);\n    H.display();\n    return 0;\n}"
  },
  {
    "objectID": "lecture36.html#last-lecture",
    "href": "lecture36.html#last-lecture",
    "title": "Lecture 35 - Dec 5, 2023",
    "section": "Last lecture",
    "text": "Last lecture\nHash tables."
  },
  {
    "objectID": "lecture36.html#today",
    "href": "lecture36.html#today",
    "title": "Lecture 35 - Dec 5, 2023",
    "section": "Today",
    "text": "Today\nHashing with chaining and linear probing."
  },
  {
    "objectID": "lecture36.html#recap",
    "href": "lecture36.html#recap",
    "title": "Lecture 35 - Dec 5, 2023",
    "section": "Recap",
    "text": "Recap\nHashing with chaining\nclass Node {\n  // for simplicity, all data members are public\n  public:\n    int key;\n    Node* next;\n    ~Node() { delete next; }\n};\n\nclass List {\n  private:\n    Node* head;\n\n  public:\n    List(); // sets head to NULL\n    void insert(int v); // inserts at head\n    ListNode* remove (int k); // remove node with key = k\n    bool isFound(int k); // returns true if node with key = k is found\n    ~List(); // deletes head\n}\n\n#define SIZE 7\n\nclass HashTable {\n  private:\n    List** table;\n  public:\n    HashTable() {\n      table = new List*[SIZE];\n      for (int i = 0; i &lt; SIZE; i++) {\n        table[i] = NULL;\n      }\n    }\n\n    bool search(int v) {\n      int idx = v % SIZE;\n      if (table[idx] != NULL) {\n        // table[idx] is of class List*\n        return table[idx]-&gt;isFound(v);\n      } else {\n        return false; // the list where v should be is not there\n      }\n    }\n\n    void insert(int v) {\n      if (search(v)) { // value already there\n        return;\n      } else {\n        int idx = v % SIZE;\n        if (table[idx] == NULL) {\n          table[idx] = new List();\n        }\n        // table[idx] is of class List*\n        table[idx]-&gt;insert(v);\n      }\n    }\n\n    ~HashTable() {\n      for (int i = 0; i &lt; SIZE; i++) {\n        delete table[i];\n      }\n      delete[] table;\n    }\n\n    void remove(int v);\n};\nHashing with linear probing:\nIf hash function lead to collision, insert value at the next available space in the table.\n\n\n\n\n\n\nExample\n\n\n\n\nIf it collides at \\(h(k)\\) then try \\([h(k) + 1] \\% SIZE\\)\nIf it collides at \\(h(k)\\) then try \\([h(k) + 2] \\% SIZE\\)\nIf it collides at \\(h(k)\\) then try \\([h(k) + 3] \\% SIZE\\)\n\n\n\nLinear probing is used tp find the next available space in the table."
  },
  {
    "objectID": "lecture36.html#solution-2-hashing-with-linear-probing",
    "href": "lecture36.html#solution-2-hashing-with-linear-probing",
    "title": "Lecture 35 - Dec 5, 2023",
    "section": "Solution 2: Hashing with linear probing",
    "text": "Solution 2: Hashing with linear probing\nclass Element {\n  public:\n    int key; // may want to store more data\n};\n\nint hash(int k); // hash function\n\n#define SIZE 7\n\nclass HashTable {\n  private:\n    Element** table;\n    int size;\n\n  public:\n    HashTable() {\n      table = new Element*[SIZE];\n      for (int i = 0; i &lt; SIZE; i++) {\n        table[i] = NULL;\n      }\n      size = 0;\n    }\n\n  // we return false if table is full\n  // return true if we inserted or the node was there\n  bool insert(int v) {\n    int idx = hash(v);\n    if (size == SIZE) { return false; }\n    for (int i=0; table[idx] != NULL; i++) {\n      // duplicate found\n      // table[idx] is of class Element*\n      if (table[idx]-&gt;key == v) { return true; }\n      idx = (hash(v) + i) % SIZE;\n    }\n    // exit loop when table[idx] == NULL\n    Element* temp = new Element;\n    temp-&gt;key = v;\n    table[idx] = temp;\n    size++;\n    return true;\n  }\n}\nUsing (hash(v) + i) % SIZE has a disadvantage: It would cause clustering of nodes in one area in the hashtable\nSolution: try uniformly distribution nodes by probing elsewhere."
  },
  {
    "objectID": "lecture36.html#solution-3-quadratic-probing",
    "href": "lecture36.html#solution-3-quadratic-probing",
    "title": "Lecture 35 - Dec 5, 2023",
    "section": "Solution 3: Quadratic probing",
    "text": "Solution 3: Quadratic probing\n(hash(v) + i*i) % SIZE"
  },
  {
    "objectID": "lecture36.html#solution-4-double-probing",
    "href": "lecture36.html#solution-4-double-probing",
    "title": "Lecture 35 - Dec 5, 2023",
    "section": "Solution 4: Double probing",
    "text": "Solution 4: Double probing\n(hash1(v) + i * hash2(v)) % SIZE"
  },
  {
    "objectID": "lecture36.html#exam-question",
    "href": "lecture36.html#exam-question",
    "title": "Lecture 35 - Dec 5, 2023",
    "section": "Exam question",
    "text": "Exam question\nChange Int class in such a way that there are no memory leaks, and output is 4 4 (not 4 3).\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Int {\n  private:\n    int* p;\n  public:\n    Int(int i) {\n      p = new int;\n      *p = i;\n    }\n    void set_val(int i) { *p = i; }\n    int get_val() { return *p; }\n    virtual void print() = 0;\n};\n\nclass SuperInt : public Int {\n  private:\n    int* q;\n  public:\n    SuperInt(int i) : Int(i) {\n      q = new int;\n      *q = i;\n    }\n    \n    ~SuperInt() {\n      delete q;\n    }\n\n    void set_val() {\n      Int::set_val(i);\n      *q = i;\n    }\n\n    void print() {\n      cout &lt;&lt; Int::get_val() &lt;&lt; \" \" &lt;&lt; q* &lt;&lt; endl;\n    }\n};\n\n// do not change main\nint main() {\n  Int* s = new SuperInt(3);\n  s-&gt;set_val(4);\n  s-&gt;print();\n  delete s;\n  return 0;\n}\nIn the class definition:\n\nInt is an abstract class\nvirtual void print() = 0; is a pure virtual function\nWe need to add virtual ~Int() { delete p; } to avoid memory leaks\nAlso prepend virtual to void set_val(int i) { *p = i; }\n\nIn main:\n\nIf set_val is virtual, it calls set_val depending on object type (not s type)\nIf the destructor is virtual, it calls the destructor of SuperInt as s points to SuperInt"
  }
]